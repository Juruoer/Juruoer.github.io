<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Sophon 深度学习框架</title>
      <link href="/2023/sophon/"/>
      <url>/2023/sophon/</url>
      
        <content type="html"><![CDATA[<p>最近一段时间在学习机器学习，学习过程中也自己实现了一个简单的深度学习框架。</p><h2 id="简介">简介</h2><p><code>Sophon</code> 是英文版 《三体》 中对 “智子” 的翻译，虽然这个名称已经被一个叫星环科技的公司用来给他的智能分析工具命名了（我这样不会侵权吧！），既然叫星环科技，应该也是受到 《三体》的启发（《三体》中程心的公司叫星环集团）。</p><p>这个框架使用 <code>python</code> 语言和 <code>numpy</code> 库搭建，包括常见的激活函数（<code>linear</code>、<code>relu</code>、<code>sigmoid</code>、<code>softmax</code>）和损失函数（平方差损失、二元交叉熵、稀疏分类交叉熵），以及 <code>CNN</code> 中需要的卷积层和池化层。实现了正向传播和反向传播（但还没有研究自动求导，但这个简单的框架中实现了对上述激活函数和损失函数的求导）。实现了一些优化手段，包括 <code>miniBatch</code>、<code>momentum</code>、<code>RMSprop</code>、<code>Adam</code>。这个框架还有很多东西没有完善，实际最后也不会去使用他，但目的在于检验学习成果并更好的了解神经网络运行的过程。</p><h2 id="源码">源码</h2><p>框架的源码在 <a href="https://github.com/Juruoer/SophonNN/tree/master">SophonNN</a>。</p><h2 id="使用方法">使用方法</h2><h3 id="导入-sophon">导入 sophon</h3><p>首先确保当前计算机已经配置了 <code>Python</code> 环境，并且安装了 <code>numpy</code> 库。</p><p>下载好 <code>Sophon</code> 源码解压缩到任意一个文件夹下，记住 <code>Sophon</code> 文件夹路径，例如：<code>G:\Machine_Learning\Sophon\</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">G:\Machine_Learning</span><br><span class="line">├─Sophon</span><br><span class="line">│  │</span><br><span class="line">│  ├─sophon</span><br></pre></td></tr></table></figure><p>然后找到计算机中存放 <code>python</code> 包的目录，<code>Anaconda</code> 环境一般在 <code>\Anaconda\Lib\site-packages</code>，非 Anaconda 环境一般在 <code>\Pythonxx\Lib\site-packages</code>（<code>xx</code>指 <code>Python</code> 版本），在 <code>site-packages</code> 文件夹下创建 <code>cus_sophon.pth</code> 文件，使用记事本打开并写入 <code>Sophon</code> 文件夹的路径，例如上述的 <code>G:\Machine_Learning\Sophon\</code> (注意最后一定要有 <code>\</code>)。</p><h2 id="构建神经网络示例">构建神经网络示例</h2><p>假设需要一个模型来判断烘烤咖啡豆的最佳时间和温度，并且假设下图中红叉表示的为优秀的烘烤情况，蓝圈表示失败的烘烤情况，数据来自：<a href="https://www.coursera.org/learn/neural-networks-deep-learning">deeplearning.ai 的神经网络课程</a>。</p><img src="/2023/sophon/coffdate.png" class="" title="coffdate"><p>创建一个 <code>.py</code> 文件，写入以下代码即可构建一个两层的二元分类神经网络来完成该任务：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sophon</span><br><span class="line"><span class="keyword">import</span> sophon.neuralNetwork.layers <span class="keyword">as</span> layers</span><br><span class="line"><span class="keyword">from</span> sophon.neuralNetwork.nn <span class="keyword">import</span> sequence</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt <span class="comment"># 这个示例中需要使用 matplotlib 画出最终测试的结果图，如果没有安装 matplotlib，可以将下面使用 plt 的代码注释，这不会影响程序运行，只是缺少图像直观的检测结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建训练数据，这是一个模拟烤咖啡的最佳时间和温度的数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_coffee_data</span>(<span class="params">trainSize:<span class="built_in">int</span>, testSize:<span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    创建靠咖啡的时间和温度的数据</span></span><br><span class="line"><span class="string">    烘烤时间: 在 12-15 分钟之间最佳</span></span><br><span class="line"><span class="string">    温度范围: 在 175-260 C 之间最佳</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    trainSize : int</span></span><br><span class="line"><span class="string">        训练集大小</span></span><br><span class="line"><span class="string">    testSize : int</span></span><br><span class="line"><span class="string">        测试集大小</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    TYPE</span></span><br><span class="line"><span class="string">        训练集和测试集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    rng = np.random.default_rng(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 生成 (trainSize + testSize) * 2 个在 0 到 1 之间的随机数</span></span><br><span class="line">    <span class="comment"># 改变形状为 X: [trainSize + testSize, 2]</span></span><br><span class="line">    X = rng.random((trainSize + testSize) * <span class="number">2</span>).reshape(-<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    X[:,<span class="number">0</span>] = X[:,<span class="number">0</span>] * (<span class="number">285</span>-<span class="number">150</span>) + <span class="number">150</span>  <span class="comment"># X[i, 0] 表第 i 个示例的温度，将它们分散到 150 到 285 之间</span></span><br><span class="line">    X[:,<span class="number">1</span>] = X[:,<span class="number">1</span>] * <span class="number">4</span> + <span class="number">11.5</span>          <span class="comment"># X[i, 1] 表第 i 个示例的时间，将它们分散到 11.5 到 15.5 之间</span></span><br><span class="line">    Y = np.zeros(<span class="built_in">len</span>(X)) <span class="comment"># 初始化标签</span></span><br><span class="line">    </span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> t,d <span class="keyword">in</span> X:</span><br><span class="line">        <span class="comment"># 并不是满足温度在 175 ~ 260 之间且时间在 12 ~ 15 度之间的烘烤方案就一定好</span></span><br><span class="line">        <span class="comment"># 温度和之间之间的关系也需要衡量，温度高时烘烤时间要更短，反之则反</span></span><br><span class="line">        <span class="comment"># 以 t 和 d 为坐标轴，最佳的烘烤方案其实在一个三角形范围</span></span><br><span class="line">        y = -<span class="number">3</span>/(<span class="number">260</span>-<span class="number">175</span>)*t + <span class="number">21</span></span><br><span class="line">        <span class="keyword">if</span> (t &gt; <span class="number">175</span> <span class="keyword">and</span> t &lt; <span class="number">260</span> <span class="keyword">and</span> d &gt; <span class="number">12</span> <span class="keyword">and</span> d &lt; <span class="number">15</span> <span class="keyword">and</span> d&lt;=y ):</span><br><span class="line">            Y[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            Y[i] = <span class="number">0</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    Y = Y.reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># X: [trainSize + testSize, 2], Y: [trainSize + testSize, 1]</span></span><br><span class="line">    <span class="keyword">return</span> X[:trainSize, :], Y[:trainSize, :], X[trainSize:,:], Y[trainSize:, :]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n靠咖啡豆测试&quot;</span>)</span><br><span class="line">train_x, train_y, test_x, test_y = load_coffee_data(<span class="number">400</span>, <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特征值相差很大，归一化</span></span><br><span class="line">mu = np.mean(train_x, axis=<span class="number">0</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">sigma = np.std(train_x, axis=<span class="number">0</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">train_x_norm = somath.normalize(train_x, mu, sigma)</span><br><span class="line">test_x_norm = somath.normalize(test_x, mu, sigma) <span class="comment"># 注意测试集的归一化应当使用训练集的分布</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建两层网络</span></span><br><span class="line">nnet = sequence(train_x_norm.shape[<span class="number">1</span>:],  <span class="comment"># 输入数据的形状</span></span><br><span class="line">        [layers.dense(<span class="number">3</span>, <span class="string">&quot;sigmoid&quot;</span>),     <span class="comment"># 一个 3 个神经元的 sigmoid 层</span></span><br><span class="line">         layers.dense(<span class="number">1</span>, <span class="string">&quot;sigmoid&quot;</span>)],    <span class="comment"># 一个 1 个神经元的 sigmoid 层</span></span><br><span class="line">        <span class="number">1234</span>)                            <span class="comment"># 随机种子，以影响权重和偏移量的初始化</span></span><br><span class="line"></span><br><span class="line">nnet.showOutputShape() <span class="comment"># 显示每层的输出形状</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 方案一：学习率为 0.01，不使用优化器</span></span><br><span class="line"><span class="comment"># nnet.options(lr = 0.01)</span></span><br><span class="line"><span class="comment"># history = nnet.fit(train_x_norm, train_y, epochs=125000) # 未使用 adam 优化器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方案二：学习率为 0.01，使用 adam 优化器</span></span><br><span class="line">nnet.options(lr = <span class="number">0.01</span>, optimizer=opt.adam())</span><br><span class="line">history = nnet.fit(train_x_norm, train_y, epochs=<span class="number">5000</span>) <span class="comment"># 使用 adam 后，加快了成本下降</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示最终权重和偏移量</span></span><br><span class="line">W1 = nnet.layerList[<span class="number">0</span>].weight</span><br><span class="line">b1 = nnet.layerList[<span class="number">0</span>].bias</span><br><span class="line">W2 = nnet.layerList[<span class="number">1</span>].weight</span><br><span class="line">b2 = nnet.layerList[<span class="number">1</span>].bias</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;成本记录：\n<span class="subst">&#123;history&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第一层权重：\n<span class="subst">&#123;W1&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第一层偏移量：\n<span class="subst">&#123;b1&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第二层权重：\n<span class="subst">&#123;W2&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第二层偏移量：\n<span class="subst">&#123;b2&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;训练数据原始图像：&quot;</span>)</span><br><span class="line">plt.scatter(train_x[:, <span class="number">0</span>], train_x[:, <span class="number">1</span>], c=train_y[:, <span class="number">0</span>])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">prob_y = nnet.prediction(train_x_norm)</span><br><span class="line">pre_y = np.where(prob_y &gt;= <span class="number">0.5</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;训练数据预测图像：&quot;</span>)</span><br><span class="line">plt.scatter(train_x[:, <span class="number">0</span>], train_x[:, <span class="number">1</span>], c=pre_y[:, <span class="number">0</span>])</span><br><span class="line">plt.show()</span><br><span class="line">acc = np.<span class="built_in">sum</span>(pre_y == train_y) / pre_y.shape[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;训练数据准确率：<span class="subst">&#123;acc&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;测试数据原始图像：&quot;</span>)</span><br><span class="line">plt.scatter(test_x[:, <span class="number">0</span>], test_x[:, <span class="number">1</span>], c=test_y[:, <span class="number">0</span>])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">prob_y = nnet.prediction(test_x_norm)</span><br><span class="line">pre_y = np.where(prob_y &gt;= <span class="number">0.5</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;测试数据预测图像：&quot;</span>)</span><br><span class="line">plt.scatter(test_x[:, <span class="number">0</span>], test_x[:, <span class="number">1</span>], c=pre_y[:, <span class="number">0</span>])</span><br><span class="line">plt.show()</span><br><span class="line">acc = np.<span class="built_in">sum</span>(pre_y == test_y) / pre_y.shape[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;测试数据准确率：<span class="subst">&#123;acc&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>准确度如下：</p><p>方案一：训练数据准确率：0.98，测试数据准确率：0.96</p><p>方案二：训练数据准确率：0.995，测试数据准确率：0.98</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速幂</title>
      <link href="/2023/expBySqr/"/>
      <url>/2023/expBySqr/</url>
      
        <content type="html"><![CDATA[<p>在 <a href="https://leetcode.cn/">LeetCode</a> 的 <a href="https://leetcode.cn/contest/weekly-contest-330/">第 330 场周赛</a> 的 <a href="https://leetcode.cn/problems/count-collisions-of-monkeys-on-a-polygon/">T2：猴子碰撞的方法数</a> 中遇到了快速幂的问题，于是写了这篇笔记。</p><p>本文章引用了 <a href="https://www.zhihu.com/">知乎</a> 用户 <a href="https://www.zhihu.com/people/one-seventh">Pecco</a> 的文章：<a href="https://zhuanlan.zhihu.com/p/95902286">算法学习笔记(4)：快速幂</a> 的部分内容。</p><h2 id="要求">要求</h2><p>计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>n</mi></msup><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mi>m</mi></mrow><annotation encoding="application/x-tex">a ^ n \bmod m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> ，以下假定 <code>m = 1e9 + 7</code>。</p><h2 id="朴素的想法">朴素的想法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function">ll <span class="title">pow1</span><span class="params">(ll a, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll rst = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">        rst = (rst * a) % MOD;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。</p><h2 id="递归快速幂">递归快速幂</h2><p>根据 n 的奇偶性，可以将计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">a^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 转化为计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">a^{n - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mfrac><mi>n</mi><mn>2</mn></mfrac></msup></mrow><annotation encoding="application/x-tex">a^{\frac{n}{2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8471em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8471em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span> 的子问题，子问题又可以转化为新的子问题：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>a</mi><mi>n</mi></msup><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>a</mi><mo>⋅</mo><msup><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>if </mtext><mi>n</mi><mtext> is odd</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msup><mi>a</mi><mfrac><mi>n</mi><mn>2</mn></mfrac></msup><mo>⋅</mo><msup><mi>a</mi><mfrac><mi>n</mi><mn>2</mn></mfrac></msup><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>if </mtext><mi>n</mi><mtext> is even but not 0</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>if </mtext><mi>n</mi><mtext> is 0</mtext></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">a^n =\begin{cases}a \cdot a^{n - 1} , &amp; \text{if }n\text{ is odd} \\a^{\frac{n}{2}} \cdot a^{\frac{n}{2}}, &amp; \text{if }n\text{ is even but not 0} \\1, &amp; \text{if }n\text{ is 0}\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7144em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.32em;vertical-align:-1.91em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35em;"><span style="top:-2.2em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.192em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.316em' style='width:0.8889em' viewBox='0 0 888.89 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.316em' style='width:0.8889em' viewBox='0 0 888.89 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style="top:-4.6em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.85em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8471em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8471em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mpunct">,</span></span></span><span style="top:-1.53em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.91em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">if </span></span><span class="mord mathnormal">n</span><span class="mord text"><span class="mord"> is odd</span></span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">if </span></span><span class="mord mathnormal">n</span><span class="mord text"><span class="mord"> is even but not 0</span></span></span></span><span style="top:-1.53em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">if </span></span><span class="mord mathnormal">n</span><span class="mord text"><span class="mord"> is 0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.91em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>可以得到一个递归算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function">ll <span class="title">pow2</span><span class="params">(ll a, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="comment">// n is 0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) <span class="comment">// n is odd</span></span><br><span class="line">        <span class="keyword">return</span> ((<span class="built_in">pow2</span>(a, n - <span class="number">1</span>) * a) % MOD);</span><br><span class="line">    <span class="comment">// n is even but not 0</span></span><br><span class="line">    ll t = <span class="built_in">pow2</span>(a, n &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (t * t) % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。</p><h2 id="非递归快速幂">非递归快速幂</h2><p>假设 <code>n = 10</code>，<code>10</code> 的二进制为 <code>1010B</code>， 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mn>10</mn></msup><mo>=</mo><msup><mi>a</mi><mrow><mo stretchy="false">(</mo><mn>1010</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow></msup><mo>=</mo><msup><mi>a</mi><mrow><mo stretchy="false">(</mo><mn>1000</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow></msup><mo>⋅</mo><msup><mi>a</mi><mrow><mo stretchy="false">(</mo><mn>10</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow></msup><mo>=</mo><msup><mi>a</mi><msup><mn>2</mn><mn>3</mn></msup></msup><mo>⋅</mo><msup><mi>a</mi><msup><mn>2</mn><mn>1</mn></msup></msup></mrow><annotation encoding="application/x-tex">a^{10} = a^{(1010)_{2}} = a^{(1000)_2} \cdot a^{(10)_2} = a^{2^3} \cdot a ^ {2^1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1010</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1000</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">10</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9869em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9869em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>一般地，若：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>n</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><msub><mi>n</mi><mi>t</mi></msub><msub><mi>n</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>⋯</mo><msub><mi>n</mi><mn>1</mn></msub><msub><mi>n</mi><mn>0</mn></msub><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mi>n</mi><mi>t</mi></msub><msup><mn>2</mn><mi>t</mi></msup><mo>+</mo><msub><mi>n</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><msup><mn>2</mn><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>n</mi><mn>1</mn></msub><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><msub><mi>n</mi><mn>0</mn></msub><msup><mn>2</mn><mn>0</mn></msup></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align}n &amp; = (n_tn_{t-1} \cdots n_1n_0)_2 \nonumber\\&amp; = n_t2^t + n_{t-1}2^{t-1} + \cdots + n_12^1 + n_02^0 \nonumber\end{align}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0241em;vertical-align:-1.2621em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7621em;"><span style="top:-3.9221em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-2.3979em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2621em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7621em;"><span style="top:-3.9221em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.3979em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8436em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2621em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>则：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msup><mi>a</mi><mi>n</mi></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msup><mi>a</mi><mrow><msub><mi>n</mi><mi>t</mi></msub><msup><mn>2</mn><mi>t</mi></msup><mo>+</mo><msub><mi>n</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><msup><mn>2</mn><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>n</mi><mn>1</mn></msub><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><msub><mi>n</mi><mn>0</mn></msub><msup><mn>2</mn><mn>0</mn></msup></mrow></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msup><mi>a</mi><mrow><msub><mi>n</mi><mi>t</mi></msub><msup><mn>2</mn><mi>t</mi></msup></mrow></msup><mo>×</mo><msup><mi>a</mi><mrow><msub><mi>n</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><msup><mn>2</mn><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow></msup><mo>×</mo><mo>⋯</mo><mo>×</mo><msup><mi>a</mi><mrow><msub><mi>n</mi><mn>1</mn></msub><msup><mn>2</mn><mn>1</mn></msup></mrow></msup><mo>×</mo><msup><mi>a</mi><mrow><msub><mi>n</mi><mn>0</mn></msub><msup><mn>2</mn><mn>0</mn></msup></mrow></msup></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{alignat}{2}a^n &amp; = a^{n_t2^t + n_{t-1}2^{t-1} + \cdots + n_12^1 + n_02^0} \nonumber\\&amp; = a^{n_t2^t} \times a^{n_{t-1}2^{t-1}} \times \cdots \times a^{n_12^1} \times a^{n_02^0} \nonumber\end{alignat}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.3938em;vertical-align:-1.4469em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.9469em;"><span style="top:-3.9469em;"><span class="pstrut" style="height:3.0369em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.0369em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4469em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.9469em;"><span style="top:-3.9469em;"><span class="pstrut" style="height:3.0369em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2963em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8703em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2025em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="minner mtight">⋯</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.0369em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0222em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2963em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8703em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2025em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4469em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>我们遍历 <code>n</code> 的二进制（从低位到高位），如果 <code>n</code> 的二进制的第 <code>t</code> 位为 <code>1</code>，则让结果乘以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><msup><mn>2</mn><mi>t</mi></msup></msup></mrow><annotation encoding="application/x-tex">a^{2^t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9722em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9722em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8703em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> ，而将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><msup><mn>2</mn><mi>t</mi></msup></msup></mrow><annotation encoding="application/x-tex">a ^ {2^t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9722em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9722em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8703em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> 转化为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><msup><mn>2</mn><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msup></msup></mrow><annotation encoding="application/x-tex">a^{2^{t + 1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9869em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> 只需要计算一次平方：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><msup><mn>2</mn><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msup></msup><mo>=</mo><msup><mrow><mo stretchy="false">(</mo><msup><mi>a</mi><msup><mn>2</mn><mi>t</mi></msup></msup><mo stretchy="false">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">a^{2^{t + 1}} = {(a ^ {2^t})} ^ 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9869em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4262em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9722em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8703em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.1762em;"><span style="top:-3.4251em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> ，那么就可以使用循环将计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">a ^ {n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span> 的时间复杂度降低为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> （<code>n</code> 的二进制的位数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo stretchy="false">⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lfloor \log_{2}n\rfloor + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function">ll <span class="title">pow3</span><span class="params">(ll a, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll rst = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 第 i 次循环时，n 的二进制的最后一位为函数调用时的 n 的二进制的第 i 位，i 从 0 开始计</span></span><br><span class="line">        <span class="comment">// 第 i 次循环时，a 已经成为函数调用时的 a 的 2^i 次方</span></span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) <span class="comment">// 若函数调用时的 n 的二进制中第 i 位为 1</span></span><br><span class="line">            rst = (rst * a) % MOD; <span class="comment">// rst *= a ^ (2 ^ i)，注意代码中的 a 已经不是最开始调用函数时的 a 了</span></span><br><span class="line">        a = (a * a) % MOD; <span class="comment">// a ^ (2 ^ (i + 1)) = (a ^ (2 ^ i)) ^ 2</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>; <span class="comment">// 以便下一个循环中，取 n 的二进制的下一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。</p><h2 id="对比">对比</h2><p>运行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> a = <span class="number">2</span>, n = <span class="number">1000000000</span>, m = <span class="number">1e9</span> + <span class="number">7</span>, rst;</span><br><span class="line">    DWORD time_star, time_end;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*********** pow1 ************&quot;</span> &lt;&lt; endl;</span><br><span class="line">    time_star = <span class="built_in">GetTickCount</span>();</span><br><span class="line">    rst = <span class="built_in">pow1</span>(a, n);</span><br><span class="line">    time_end = <span class="built_in">GetTickCount</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rst: &quot;</span> &lt;&lt; rst &lt;&lt; <span class="string">&quot;, time: &quot;</span> &lt;&lt; time_end - time_star &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*********** pow2 ************&quot;</span> &lt;&lt; endl;</span><br><span class="line">    time_star = <span class="built_in">GetTickCount</span>();</span><br><span class="line">    rst = <span class="built_in">pow2</span>(a, n);</span><br><span class="line">    time_end = <span class="built_in">GetTickCount</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rst: &quot;</span> &lt;&lt; rst &lt;&lt; <span class="string">&quot;, time: &quot;</span> &lt;&lt; time_end - time_star &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*********** pow3 ************&quot;</span> &lt;&lt; endl;</span><br><span class="line">    time_star = <span class="built_in">GetTickCount</span>();</span><br><span class="line">    rst = <span class="built_in">pow3</span>(a, n);</span><br><span class="line">    time_end = <span class="built_in">GetTickCount</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rst: &quot;</span> &lt;&lt; rst &lt;&lt; <span class="string">&quot;, time: &quot;</span> &lt;&lt; time_end - time_star &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*********** pow1 ************</span><br><span class="line">rst: 140625001, time: 5797ms</span><br><span class="line">*********** pow2 ************</span><br><span class="line">rst: 140625001, time: 0ms</span><br><span class="line">*********** pow3 ************</span><br><span class="line">rst: 140625001, time: 0ms</span><br></pre></td></tr></table></figure><h2 id="拓展">拓展</h2><h3 id="泛型非递归快速幂">泛型非递归快速幂</h3><p>在计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">a ^ {n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span> 时，若 <code>a</code> 的类型 <code>a</code> 支持 <strong>乘法</strong>，并且满足 <strong>乘法结合律</strong> （因为快速幂改变了乘法的运算顺序）便可以使用快速幂，例如传说中的矩阵快速幂。</p><p>实现方式与之前的方法非常类似。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">powT</span><span class="params">(T a, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T ans = <span class="number">1</span>; <span class="comment">// 赋值为乘法单位元，可能要根据构造函数修改，例如数字的乘法单位元为 1，矩阵的乘法单位元为单位矩阵</span></span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * a;</span><br><span class="line">        a = a * a;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>c</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(c \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span> 为此类型计算一次乘法的时间复杂度，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> （结果不应看作额外空间）。</p><h3 id="矩阵快速幂">矩阵快速幂</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span> <span class="comment">// 2 * 2 矩阵，也可以使用二维数组进行模拟，但也要重载乘法</span></span><br><span class="line">&#123;</span><br><span class="line">    ll a1, a2, b1, b2;</span><br><span class="line">    <span class="built_in">matrix</span>(ll a1, ll a2, ll b1, ll b2) : <span class="built_in">a1</span>(a1), <span class="built_in">a2</span>(a2), <span class="built_in">b1</span>(b1), <span class="built_in">b2</span>(b2) &#123;&#125;</span><br><span class="line">    matrix <span class="keyword">operator</span>*(<span class="type">const</span> matrix &amp;y) <span class="comment">// 重载乘法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">matrix <span class="title">ans</span><span class="params">((a1 * y.a1 + a2 * y.b1) % MOD,</span></span></span><br><span class="line"><span class="params"><span class="function">                   (a1 * y.a2 + a2 * y.b2) % MOD,</span></span></span><br><span class="line"><span class="params"><span class="function">                   (b1 * y.a1 + b2 * y.b1) % MOD,</span></span></span><br><span class="line"><span class="params"><span class="function">                   (b1 * y.a2 + b2 * y.b2) % MOD)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">powM</span><span class="params">(matrix a, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">matrix <span class="title">ans</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 单位矩阵</span></span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * a;</span><br><span class="line">        a = a * a;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用-计算斐波那契数列">应用-计算斐波那契数列</h3><p>斐波那契数列：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>F</mi><mi>n</mi></msub><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>⩽</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>&gt;</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">F_n =\begin{cases}1, &amp; (n \leqslant 2) \\F_{n - 1} + F_{n - 2}, &amp; (n &gt; 2)\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>n</mi></msub><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mi>m</mi></mrow><annotation encoding="application/x-tex">F_n \bmod m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> ，以下假定 <code>m = 1e9 + 7</code>。</p><h4 id="常规非递归算法">常规非递归算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function">ll <span class="title">Fib</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a = <span class="number">0</span>, b = <span class="number">1</span>, c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(--n)</span><br><span class="line">    &#123;</span><br><span class="line">        c = (a + b) % MOD;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。</p><h4 id="矩阵快速幂算法">矩阵快速幂算法</h4><p>设</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.16em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">A = \begin{pmatrix}0 &amp; 1 \\1 &amp; 1\end{pmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span></span></span></span></p><p>则有：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>F</mi><mi>n</mi></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>=</mo><mi>A</mi><mrow><mo fence="true">(</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>F</mi><mi>n</mi></msub></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>=</mo><msup><mi>A</mi><mn>2</mn></msup><mrow><mo fence="true">(</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>=</mo><mo>⋯</mo><mo>=</mo><msup><mi>A</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo fence="true">(</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{pmatrix}F_{n} \\F_{n + 1}\end{pmatrix}= A\begin{pmatrix}F_{n-1} \\F_{n}\end{pmatrix}= A^2\begin{pmatrix}F_{n-2} \\F_{n-1}\end{pmatrix}= \cdots= A ^ {n-1}\begin{pmatrix}1 \\1\end{pmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span></span></span></span></p><p>若</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>A</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.16em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>a</mi><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>a</mi><mn>2</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>b</mi><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>b</mi><mn>2</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">A^{n - 1} = \begin{pmatrix}a1 &amp; a2 \\b1 &amp; b2\end{pmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8641em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mord">2</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span></span></span></span></p><p>即有：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>F</mi><mi>n</mi></msub><mo>=</mo><mi>a</mi><mn>1</mn><mo>+</mo><mi>a</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">F_n = a1 + a2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal">a</span><span class="mord">2</span></span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function">ll <span class="title">Fib</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">matrix <span class="title">A</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    A = <span class="built_in">powM</span>(A, n - <span class="number">1</span>); <span class="comment">// A^(n - 1)</span></span><br><span class="line">    <span class="keyword">return</span> (A.a1 + A.a2) % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，空间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。</p><h4 id="对比-2">对比</h4><p>运行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> a = <span class="number">2</span>, n = <span class="number">1000000000</span>, m = <span class="number">1e9</span> + <span class="number">7</span>, rst;</span><br><span class="line">    DWORD time_star, time_end;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*********** Fib ************&quot;</span> &lt;&lt; endl;</span><br><span class="line">    time_star = <span class="built_in">GetTickCount</span>();</span><br><span class="line">    rst = <span class="built_in">Fib</span>(n);</span><br><span class="line">    time_end = <span class="built_in">GetTickCount</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rst: &quot;</span> &lt;&lt; rst &lt;&lt; <span class="string">&quot;, time: &quot;</span> &lt;&lt; time_end - time_star &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*********** FibM ************&quot;</span> &lt;&lt; endl;</span><br><span class="line">    time_star = <span class="built_in">GetTickCount</span>();</span><br><span class="line">    rst = <span class="built_in">FibM</span>(n);</span><br><span class="line">    time_end = <span class="built_in">GetTickCount</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rst: &quot;</span> &lt;&lt; rst &lt;&lt; <span class="string">&quot;, time: &quot;</span> &lt;&lt; time_end - time_star &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*********** Fib ************</span><br><span class="line">rst: 21, time: 5297ms</span><br><span class="line">*********** FibM ************</span><br><span class="line">rst: 21, time: 0ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道好题：矩阵转换后的秩</title>
      <link href="/2023/lc1632/"/>
      <url>/2023/lc1632/</url>
      
        <content type="html"><![CDATA[<p>前两天刷 <a href="https://leetcode.cn/">LeetCode</a> 每日一题的时候，遇到一道不错的并查集题目。</p><h2 id="原题">原题</h2><blockquote><p><a href="https://leetcode.cn/problems/rank-transform-of-a-matrix/">1632. 矩阵转换后的秩</a></p><p>给你一个 <code>m x n</code> 的矩阵 <code>matrix</code> ，请你返回一个新的矩阵 <code>answer</code> ，其中 <code>answer[row][col]</code> 是 <code>matrix[row][col]</code> 的秩。</p><p>每个元素的 <strong>秩</strong> 是一个整数，表示这个元素相对于其他元素的大小关系，它按照如下规则计算：</p><p>秩是从 <code>1</code> 开始的一个整数。<br>如果两个元素 <code>p</code> 和 <code>q</code> 在 <strong>同一行</strong> 或者 <strong>同一列</strong> ，那么：</p><ul><li>如果 <code>p &lt; q</code> ，那么 <code>rank(p) &lt; rank(q)</code></li><li>如果 <code>p == q</code> ，那么 <code>rank(p) == rank(q)</code></li><li>如果 <code>p &gt; q</code> ，那么 <code>rank(p) &gt; rank(q)</code></li></ul><p><strong>秩</strong> 需要越 <strong>小</strong> 越好。<br>题目保证按照上面规则 <code>answer</code> 数组是唯一的。</p><p>示例 1：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank1.jpg" alt="示例 1"></p><p>输入：matrix = [[1,2],[3,4]]</p><p>输出：[[1,2],[2,3]]</p><p>解释：</p><p>matrix[0][0] 的秩为 1 ，因为它是所在行和列的最小整数。</p><p>matrix[0][1] 的秩为 2 ，因为 matrix[0][1] &gt; matrix[0][0] 且 matrix[0][0] 的秩为 1 。</p><p>matrix[1][0] 的秩为 2 ，因为 matrix[1][0] &gt; matrix[0][0] 且 matrix[0][0] 的秩为 1 。</p><p>matrix[1][1] 的秩为 3 ，因为 matrix[1][1] &gt; matrix[0][1]， matrix[1][1] &gt; matrix[1][0] 且 matrix[0][1] 和 matrix[1][0] 的秩都为 2 。</p><p>示例2：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank2.jpg" alt="示例 2"></p><p>输入：matrix = [[7,7],[7,7]]</p><p>输出：[[1,1],[1,1]]</p><p>示例 3：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank3.jpg" alt="示例 3"></p><p>输入：matrix = [[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]</p><p>输出：[[4,2,3],[1,3,4],[5,1,6],[1,3,4]]</p><p>示例 4：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank4.jpg" alt=""></p><p>输入：matrix = [[7,3,6],[1,4,5],[9,8,2]]</p><p>输出：[[5,1,4],[1,2,3],[6,3,1]]</p><p>提示：</p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 500</code></li><li><code>-1e9 &lt;= matrix[row][col] &lt;= 1e9</code></li></ul></blockquote><h2 id="注意事项">注意事项</h2><p>此题有一个翻译错误，英文版的题目中使用的 <strong>rank</strong> 不应该翻译成 <strong>秩</strong>，因为矩阵的秩在线性代数中是有定义的，在下面的题解中我将使用 <strong>rank</strong> 来代替 <strong>秩</strong>。</p><p>要解决该题，需要的前置知识：并查集、拓扑排序。</p><h2 id="朴素的想法-2">朴素的想法</h2><p>首先我们思考一种简单的情况：矩阵中没有相同的元素。</p><p>如果一个元素其所在的行、列中比值它小的元素的 rank 已经确定了，那么该元素的 rank 应该是对少呢？</p><p>很显然，该元素的 rank 值比它所在的行中的所有比它小的元素的 rank 大，也比它所在列中的所有比它小的元素的的 rank 大，并且要求每个元素的 rank 值取最小。</p><p>那么我们只需要按元素值大小从小打到遍历每一个元素，然后查看其所在行、列中比它小的元素中 rank 值最大的元素的 rank 值是多少（假设为 r），那么该元素的 rank 值就是 r + 1。由于是从小到大遍历，所以在遍历各元素时，比它小的元素的 rank 值已经求出。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrixRankTransform</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;matrix)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>(), t = m * n;</span><br><span class="line">        pii nums[t]; <span class="comment">// 记录 matrix 中每个数字的下标，因为我们需要根据元素值找到其在矩阵中的行和列</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">rst</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j, ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[k].first = i;</span><br><span class="line">                nums[k].second = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums, nums + t, [&amp;](<span class="type">const</span> pii &amp;a, <span class="type">const</span> pii &amp;b) <span class="comment">// 根据元素大小排序</span></span><br><span class="line">             &#123; <span class="keyword">return</span> matrix[a.first][a.second] &lt; matrix[b.first][b.second]; &#125;);</span><br><span class="line">        <span class="type">int</span> rowHave[m]; <span class="comment">// rowHave[i] 记录第 i 行已有的最大 rank</span></span><br><span class="line">        <span class="type">int</span> colHave[n]; <span class="comment">// colHave[j] 记录第 j 列已有的最大 rank</span></span><br><span class="line">        <span class="built_in">memset</span>(rowHave, <span class="number">0</span>, <span class="built_in">sizeof</span>(rowHave));</span><br><span class="line">        <span class="built_in">memset</span>(colHave, <span class="number">0</span>, <span class="built_in">sizeof</span>(colHave));</span><br><span class="line">        <span class="keyword">for</span> (pii &amp;x : nums) <span class="comment">// 按从小到大遍历所有元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> num = matrix[x.first][x.second]; <span class="comment">// num 是位于 x.first 行，x.second 列的元素</span></span><br><span class="line">            <span class="type">int</span> rr = rowHave[x.first];    <span class="comment">// num 所在行已有的最大 rank</span></span><br><span class="line">            <span class="type">int</span> cr = colHave[x.second];   <span class="comment">// num 所在列已有的最大 rank</span></span><br><span class="line">            rst[x.first][x.second] = rowHave[x.first] = colHave[x.second] = <span class="built_in">max</span>(rr, cr) + <span class="number">1</span>; <span class="comment">// 取得 num 的 rank 值并更新其所在行、列已有的最大 rank</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在的问题是，存在相同的元素，如果仍然使用上述代码会怎样？</p><p>运行示例 2，会发现结果为：<code>[[1,2],[2,3]]</code>。</p><p>一种直观的修改方案是：</p><p>不仅记录各行与各列已有的最大 rank（假设为 r），而且记录该 rank 的元素值，如果当前元素与最大 rank 的元素值相同，那么该元素的 rank 也为 r，否则为 r + 1。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrixRankTransform</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;matrix)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>(), t = m * n;</span><br><span class="line">        pii nums[m * n]; <span class="comment">// 记录 matrix 中每个数字的下标，因为我们需要根据元素值找到其在矩阵中的行和列</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">rst</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j, ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[k].first = i;</span><br><span class="line">                nums[k].second = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums, nums + t, [&amp;](<span class="type">const</span> pii &amp;a, <span class="type">const</span> pii &amp;b) <span class="comment">// 根据元素大小排序</span></span><br><span class="line">             &#123; <span class="keyword">return</span> matrix[a.first][a.second] &lt; matrix[b.first][b.second]; &#125;);</span><br><span class="line">        pii rowHave[m]; <span class="comment">// rowHave[i] 记录第 i 行已有的最大 rank 及其元素值</span></span><br><span class="line">        pii colHave[n]; <span class="comment">// colHave[j] 记录第 j 列已有的最大 rank 及其元素值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">            rowHave[i].first = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            rowHave[j].first = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (pii &amp;x : nums) <span class="comment">// 按从小到大遍历所有元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> num = matrix[x.first][x.second];</span><br><span class="line">            <span class="type">int</span> rr = rowHave[x.first].first + ((rowHave[x.first].first == <span class="number">0</span>) || (rowHave[x.first].second != num)); <span class="comment">// num 在行的限制下的最小 rank（与上一个代码的含义稍微不同）</span></span><br><span class="line">            <span class="type">int</span> cr = colHave[x.second].first + ((colHave[x.second].first == <span class="number">0</span>) || (colHave[x.second].second != num)); <span class="comment">// num 在列的限制下的最小 rank（与上一个代码的含义稍微不同）</span></span><br><span class="line">            rst[x.first][x.second] = rowHave[x.first].first = colHave[x.second].first = <span class="built_in">max</span>(rr, cr); <span class="comment">// 取得 num 的 rank 并更新行、列已有的最大 rank，取两限制下的最大值</span></span><br><span class="line">            rowHave[x.first].second = colHave[x.second].second = num; <span class="comment">// 更新行、列已有的最大 rank 的数的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在运行示例 2，结果正确，但提交后发现 WA：</p><p>输入：<code>[[-37,-50,-3,44],[-37,46,13,-32],[47,-42,-3,-40],[-17,-22,-39,24]]</code></p><p>输出：<code>[[2,1,3,6],[2,6,5,4],[5,2,4,3],[4,3,1,5]]</code></p><p>预期：<code>[[2,1,4,6],[2,6,5,4],[5,2,4,3],[4,3,1,5]]</code></p><p>发现第 0 行第 2 列的 rank 值应该是 4，但上述代码计算得出为 3。</p><p>原因在于，我们先计算了第 0 行第 2 列的 -3 的 rank 值为 3 后，再计算第 2 行第 2 列的 -3 的 rank 值，并发现其为 4，根据题干要求，同一行（列）相同元素的 rank 值应该相同，那么当我们计算完第 2 个 -3 的 rank 后应该把与其同行（列）的同为 -3 的且已经计算完 rank 值的元素的 rank 值也更新为 4。</p><p>这也就是这道题的难点。</p><h2 id="最终的方案">最终的方案</h2><p>经过以上分析，发现位于同一行、同一列的相同的元素的 rank 值相同，所以应该将其视为一个整体，并计算该整体的 rank 值，这与这个整体中每个元素所在行、列都有关。</p><p>假设有两个整体 s1 和 s2，元素值分别为 a 和 b，如果整体 s1 中存在某个元素 n1 与 s2 中的另一个元素 n2 同行或者同列，那么 a、b 一定不相等，否则由于 n1、n2 同行或同列，s1 和 s2 应该为同一个整体。若 a &lt; b，则 s1 的 rank 小于 s2 的 rank，反之则反。</p><p>如果将每个整体视为一个结点，并且 rank 值小的结点有一条指向 rank 值大的结点的有向边（或有向路径），形成一个有向无循环图，就可以通过拓扑排序来得出每个整体的 rank 值。</p><p>那么如何构建这个有向无循环图呢？</p><p>在每一行（列）中，按元素值去重，再对去重后该行（列）的元素进行排序，排行后相邻的元素中，元素值小的元素所在的整体就有一条指向元素值大的元素所在的整体的有向边，对每一行（列）执行该过程，就形成了一个满足要求的有向无循环图（有点像织毛衣的感觉）。去重是因为同一行（列）中相同的元素属于一个整体。</p><p>现在的问题是，各整体如何表示？容易想到使用并查集来维护各个整体。</p><p>最后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> <span class="comment">// 并查集类</span></span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;vector&lt;pii&gt;&gt; roots; <span class="comment">// 并查集中的各个元素的根节点，记录根节点的下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> m, <span class="type">int</span> n) <span class="comment">// 构造函数，初始时个元素的根节点为其自身</span></span><br><span class="line">    &#123;</span><br><span class="line">        roots = vector&lt;vector&lt;pii&gt;&gt;(m, <span class="built_in">vector</span>&lt;pii&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                roots[i][j] = <span class="built_in">make_pair</span>(i, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">pii <span class="title">find</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> <span class="comment">// 查询在矩阵中下标为 (i, j) 的元素的根节点</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pii r = roots[i][j];</span><br><span class="line">        <span class="keyword">if</span>(r.first != i || r.second != j)</span><br><span class="line">            roots[i][j] = <span class="built_in">find</span>(r.first, r.second);</span><br><span class="line">        <span class="keyword">return</span> roots[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unio</span><span class="params">(<span class="type">int</span> i1, <span class="type">int</span> j1, <span class="type">int</span> i2, <span class="type">int</span> j2)</span> <span class="comment">// 将矩阵中下标为 (i1, j1) 和下标为 (i2, j2) 的两个元素所在的集合合并为一个集合</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pii r1 = <span class="built_in">find</span>(i1, j1), r2 = <span class="built_in">find</span>(i2, j2);</span><br><span class="line">        <span class="keyword">if</span>(r1 != r2)</span><br><span class="line">            roots[r2.first][r2.second] = r1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrixRankTransform</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;matrix)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(m, n)</span></span>; <span class="comment">// 并查集</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建并查集，使相同行或相同列且值相同的元素合并为一个集合，同一个集合中的所有元素的 rank 相同</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; num2indexList; <span class="comment">// 记录第 i 行中相同元素的列下标</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)                    <span class="comment">// 将同一行中，相同的元素的列下标放入一个列表中</span></span><br><span class="line">                num2indexList[matrix[i][j]].<span class="built_in">emplace_back</span>(j);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [_, indexList] : num2indexList)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> t = indexList[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; indexList.<span class="built_in">size</span>(); ++k) <span class="comment">// 将同一行中，相同元素放入合并为一个集合</span></span><br><span class="line">                    uf.<span class="built_in">unio</span>(i, t, i, indexList[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map &lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; num2indexList; <span class="comment">// 记录第 j 列中相同元素的行下标</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)                     <span class="comment">// 将同一列中，相同元素的行下标放入一个列表中</span></span><br><span class="line">                num2indexList[matrix[i][j]].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> [_, indexList] : num2indexList)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> t = indexList[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; indexList.<span class="built_in">size</span>(); ++k) <span class="comment">// 将同一列中，相同元素放入合并为一个集合</span></span><br><span class="line">                    uf.<span class="built_in">unio</span>(t, j, indexList[k], j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将每个集合看作一个结点，结点的值为该集合的根节点的下标的一维展开值，即下标 (i, j) 展开为 i * n + j</span></span><br><span class="line">        <span class="comment">// 若某个集合 s1 中存在一个元素小于与其同行或同列的另一个元素，且该元素在集合 s2 中，那么集合 s1 的 rank 小于集合 s2 的 rank</span></span><br><span class="line">        <span class="comment">// 那么集合 s1 的结点有一条指向集合 s2 的结点的有向边（或路径），可以通过拓扑排序来确定所有集合的 rank 的大小关系，第 i 大的集合，rank 为 i</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; inDegrees; <span class="comment">// 每个结点的入度</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; outEdges; <span class="comment">// 每个结点的出边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) <span class="comment">// 初始化入度</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                pii r = uf.<span class="built_in">find</span>(i, j);</span><br><span class="line">                inDegrees[r.first * n + r.second] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; num2index; <span class="comment">// 记录同一行中相同元素中任意一个元素的列下标，用于去重</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                num2index[matrix[i][j]] = j;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; sortArr; <span class="comment">// 记录同一行中所有的元素，相同元素只保存一个，并排序</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> [key, _] : num2index)</span><br><span class="line">                sortArr.<span class="built_in">emplace_back</span>(key);</span><br><span class="line">            <span class="built_in">sort</span>(sortArr.<span class="built_in">begin</span>(), sortArr.<span class="built_in">end</span>());</span><br><span class="line">            <span class="comment">// 如果一个元素 num1 小于其所在行中的另一个元素 num2，那么 num1 所在的集合 s1 的 rank 小于 num2 所在集合 s2 的 rank，s1 有一条指向 s2 的有向边（或路径）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; sortArr.<span class="built_in">size</span>(); ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                pii r1 = uf.<span class="built_in">find</span>(i, num2index[sortArr[k - <span class="number">1</span>]]);</span><br><span class="line">                pii r2 = uf.<span class="built_in">find</span>(i, num2index[sortArr[k]]);</span><br><span class="line">                <span class="type">int</span> idx1 = r1.first * n + r1.second;</span><br><span class="line">                <span class="type">int</span> idx2 = r2.first * n + r2.second;</span><br><span class="line">                <span class="comment">// r1 指向 r2</span></span><br><span class="line">                ++inDegrees[idx2];</span><br><span class="line">                outEdges[idx1].<span class="built_in">emplace_back</span>(idx2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; num2index; <span class="comment">// 记录同一列中相同元素中任意一个元素的行下标，用于去重</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">                num2index[matrix[i][j]] = i;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; sortArr; <span class="comment">// 记录同一列中所有的元素，相同元素只保存一个，并排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [key, _] : num2index)</span><br><span class="line">                sortArr.<span class="built_in">emplace_back</span>(key);</span><br><span class="line">            <span class="built_in">sort</span>(sortArr.<span class="built_in">begin</span>(), sortArr.<span class="built_in">end</span>());</span><br><span class="line">            <span class="comment">// 如果一个元素 num1 小于其所在列中的另一个元素 num2，那么 num1 所在的集合 s1 的 rank 小于 num2 所在集合 s2 的 rank，s1 有一条指向 s2 的有向边（或路径）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; sortArr.<span class="built_in">size</span>(); ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                pii r1 = uf.<span class="built_in">find</span>(num2index[sortArr[k - <span class="number">1</span>]], j);</span><br><span class="line">                pii r2 = uf.<span class="built_in">find</span>(num2index[sortArr[k]], j);</span><br><span class="line">                <span class="type">int</span> idx1 = r1.first * n + r1.second;</span><br><span class="line">                <span class="type">int</span> idx2 = r2.first * n + r2.second;</span><br><span class="line">                <span class="comment">// r1 指向 r2</span></span><br><span class="line">                ++inDegrees[idx2];</span><br><span class="line">                outEdges[idx1].<span class="built_in">emplace_back</span>(idx2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拓扑排序并计算集合（根）的 rank</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q, temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [key, dgeress] : inDegrees)</span><br><span class="line">            <span class="keyword">if</span>(dgeress == <span class="number">0</span>)</span><br><span class="line">                q.<span class="built_in">emplace</span>(key);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> r = <span class="number">1</span>; <span class="comment">// 当前的 rank</span></span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                matrix[u / n][u % n] = r;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> v : outEdges[u])</span><br><span class="line">                &#123;</span><br><span class="line">                    --inDegrees[v];</span><br><span class="line">                    <span class="keyword">if</span>(inDegrees[v] == <span class="number">0</span>)</span><br><span class="line">                        temp.<span class="built_in">emplace</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++r;</span><br><span class="line">            <span class="built_in">swap</span>(q, temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 元素的 rank 与其根的 rank 相同</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                pii r = uf.<span class="built_in">find</span>(i, j);</span><br><span class="line">                matrix[i][j] = matrix[r.first][r.second];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 并查集 </tag>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当考研遇上新冠</title>
      <link href="/2022/kaoyan/"/>
      <url>/2022/kaoyan/</url>
      
        <content type="html"><![CDATA[<p>  我大概是在小学三年级的时候第一次接触计算机，并且直到高二以前都只会开机、关机和玩游戏。高中的班主任对我说，玩游戏并不厉害，会做游戏会写程序的才厉害，我才发现，我对计算机的认识是那样的短浅，我对我曾熬夜通宵也要玩的游戏的认识是那样的短浅，于是我就开始探索游戏是如何开发出来的。</p><p>  小县城对计算机教育不重视，微机课就是给学生们用来放松的，我去图书馆里找答案，第一次接触到了 “编程” 两个字。</p><p>  高考完我看视频自学了 c 语言的基础语法，也跟着教程做了几个不错的小案例，便下定决心以后一定往这方面发展。填报志愿的时候所有学校的专业都填的计算机，并且不服从调剂，然后滑档了。我一个同学和我填了一个一样的学校，并且接受调剂，总分比我高两分，他考上了，计算机专业。然后我就只能选择一所二本的学院，并且已经不招计算机专业了，最终选择了生物技术专业，我想着到时候申请转专业。</p><p>  但我失算了，本来这个学校的生物技术专业第一轮就没招满才有第二轮滑档的来选，就说明这个专业人不多，学院自然是不希望有过多的人转出去的。学生手册上说只要通过了转专业考试就可以转走，但事实是参加这个考试需要院长的签字，但我没能得到这个签字，而另一些人，走了一些渠道，成功转走了。</p><p>  于是大学四年我一边学着本科专业，一边又零零散散的学了 C++、C#、Java、Qt、Unity3D、Unreal, 准备自己开发游戏，开发软件，但学的都不系统，各种教程杂七杂八的乱学，好在本科专业是一科也没挂。开始也没有考研的想法，到了大三才知道还可以跨考，于是匆匆忙忙准备，之前也没有接触过计算机组成原理、计算机网络和计算机操作系统，对数据结构了解不多，只会一些简单的数据结构，高数倒是主修课里有的，但也只教了一部分，英语还是我的死穴，相当于完全从零开始跨考，考的还是最难的 11408。</p><p>  一战考英语的时候阅读完全不会写，考完以为单科过不了线，数学和 408 就随便考了，没想到最后英语过线了，总分 302（68 + 46 + 83 + 105）。</p><p>  考研一战失利后，又花了半年多的时间复习，本来是信心满满的一年（目标是考355分以上），但感觉这次又无了。</p><p>  第一天考英语的时候就感觉不对劲，虽然那天中午一直在背一些句子想着写作文的时候用，就没有休息，但考试的时候却困的不寻常，而且开始流鼻涕（之前一直都没有过任何症状），并且英语一直都是我的短板，好在中午背的句子里有一句是关于传统文化的，也算是压到了一点点题，但阅读理解做的非常差。</p><p>  第一天考完之后困意就更大了，回家后洗了个澡，勉强精神了一些，就想再复习一下数学和 408 ，但没看两眼又困起来了，只能去睡觉了。 00 : 01 的时候突然就惊醒了，感觉全身发烫，心率也非常快（测了一下一分钟 140），我意识到应该是阳了，当时就想阳了也要去考，就挣扎着想睡着，但是心跳动静很大（我听见心跳声就睡不着），就一直调整姿势让心跳的震感小一些，但是这样每睡着一段时间就醒来，醒来后再挣扎着睡着，一晚上醒醒睡睡了六七次，终于熬到了六点多爬起来去考试。</p><p>  上午的时候头很晕，感觉脑袋里面有一半的水，一晃脑袋就胀的很，吃了一片缓解头晕的药，到考数学的时候稍微有了点效果，但还是不清醒，而且完全没有做题目的动力，平常写模拟题的时候都是开足了功率每道题都想着速战速决的，但这次真的没力气，思考的效率极低。考完数学就知道数学无了。</p><p>  下午好了很多，但是吃不下饭，买了两包面包勉强吃完一包，然后就开始睡觉，考 408 的时候已经好了很多，而且 408 是最后翻盘的希望了，今年的 408 也不难，但第二道大题考的是外部排序的归并段划分方法，这个确实很久没看了，所以就没做出来，其他大题都还做的不错，但本来这种难度的题目平常至少多了半小时的时间来检查一遍，而考试时仅仅是考前五分钟左右才写完。</p><p>  考完那天晚上七点就睡了，睡了整整 11 个小时，醒来发现头不晕了，我整个人直接大无语，偏偏赶上考研那两天发烧。然后去网上找了找数学答案（这些机构出答案的速度是真的快），对了一下，果然，选择填空题错了 5 个，大题也没写好。</p><p>  最后估了一下分，大概只有 325 分左右。如果这次没考上那真的是没有办法了，不会三战了，家里条件也不好，得去找工作了，并且很可能不会是和计算机相关的，一切就真的结束了。</p><div class='poem'><div class='poem-title'>忆秦娥·娄山关</div><div class='poem-author'>毛泽东</div><p>西风烈，长空雁叫霜晨月。<br>霜晨月，马蹄声碎，喇叭声咽。<br>雄关漫道真如铁，而今迈步从头越。<br>从头越，苍山如海，残阳如血。</p></div><p>  本来这首词是准备考好了再念的，但也算是对未来的期望吧。</p>]]></content>
      
      
      <categories>
          
          <category> 记事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 新冠 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 LeetCode 周赛题解或停止更新决定的公告</title>
      <link href="/2022/Anouncement/"/>
      <url>/2022/Anouncement/</url>
      
        <content type="html"><![CDATA[<p>现在感觉考研复习的时间越来越紧张了，所以之后的 <a href="https://leetcode.cn/">LeetCode</a> 周赛题解 <s>(虽然次周赛的题解只会花费一个下午的时间)</s> 可能会停止更新，或者只对部分题发布题解，但是周赛一定会继续参加。</p>]]></content>
      
      
      <categories>
          
          <category> 记事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录 LeetCode 第 300 场周赛</title>
      <link href="/2022/LC-WeeklyContext-300/"/>
      <url>/2022/LC-WeeklyContext-300/</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p><a href="https://leetcode.cn/contest/weekly-contest-300/">本次周赛</a> 十分可惜，很有可能 AK 的比赛却仅写出前两题。第三题带错了一个动态规划初始值，第四题没看题目，赛后十分钟给 AC 了。</p></div><h1>战局详情</h1><table><thead><tr><th>排名</th><th>用户名</th><th>得分</th><th>完成时间</th><th>题目1（3）</th><th>题目2（4）</th><th>题目3（5）</th><th>题目4（6）</th></tr></thead><tbody><tr><td>2385 / 6792</td><td>Juruoer</td><td>7</td><td>0:29:56</td><td>0:10:57</td><td>0:24:56 <i class="fa-solid fa-bug"></i> 1</td><td></td><td></td></tr></tbody></table><h1>题目及解答</h1><div class="tabs" id="problems"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#problems-1">题目1</button></li><li class="tab"><button type="button" data-href="#problems-2">题目2</button></li><li class="tab"><button type="button" data-href="#problems-3">题目3</button></li><li class="tab"><button type="button" data-href="#problems-4">题目4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="problems-1"><details class="folding-tag" ><summary> 解密消息 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/decode-the-message/">6108. 解密消息</a></p><p>给你字符串 <code>key</code> 和 <code>message</code> ，分别表示一个加密密钥和一段加密消息。解密 <code>message</code> 的步骤如下：</p><ol><li><p>使用 <code>key</code> 中 26 个英文小写字母第一次出现的顺序作为替换表中的字母 <strong>顺序</strong> 。</p></li><li><p>将替换表与普通英文字母表对齐，形成对照表。</p></li><li><p>按照对照表 <strong>替换</strong> <code>message</code> 中的每个字母。</p></li><li><p>空格 <code>' '</code> 保持不变。</p></li></ol><ul><li>例如，<code>key = &quot;happy boy&quot;</code>（实际的加密密钥会包含字母表中每个字母 <strong>至少一次</strong>），据此，可以得到部分对照表（<code>'h' -&gt; 'a'</code>、<code>'a' -&gt; 'b'</code>、<code>'p' -&gt; 'c'</code>、<code>'y' -&gt; 'd'</code>、<code>'b' -&gt; 'e'</code>、<code>'o' -&gt; 'f'</code>）。</li></ul><p>返回解密后的消息。</p><div class="note info flat"><p>提示：</p><ul><li><code>26 &lt;= key.length &lt;= 2000</code></li><li><code>key</code> 由小写英文字母及 <code>' '</code> 组成</li><li><code>key</code> 包含英文字母表中每个字符（<code>'a'</code> 到 <code>'z'</code>）至少一次</li><li><code>1 &lt;= message.length &lt;= 2000</code></li><li><code>message</code> 由小写英文字母和 <code>' '</code> 组成</li></ul></div><div class="note primary flat"><p>示例一：</p><img src = "https://assets.leetcode.com/uploads/2022/05/08/ex1new4.jpg" alt = "示例一图"><p>输入：key = “the quick brown fox jumps over the lazy dog”, message = “vkbs bs t suepuv”<br>输出：“this is a secret”<br>解释：对照表如上图所示。<br>提取 “the quick brown fox jumps over the lazy dog” 中每个字母的首次出现可以得到替换表。</p></div><div class="note primary flat"><p>示例二：</p><img src = "https://assets.leetcode.com/uploads/2022/05/08/ex2new.jpg" alt = "示例二图"><p>输入：key = “eljuxhpwnyrdgtqkviszcfmabo”, message = “zwx hnfx lqantp mnoeius ycgk vcnjrdb”<br>输出：“the five boxing wizards jump quickly”<br>解释：对照表如上图所示。<br>提取 “eljuxhpwnyrdgtqkviszcfmabo” 中每个字母的首次出现可以得到替换表。</p></div>              </div>            </details><p>解决方案：</p><p>模拟 + 映射：</p><p>使用一个数组来映射每个字母转换后的字母，然后模拟即可。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">decodeMessage</span><span class="params">(string key, string message)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">to</span><span class="params">(<span class="number">26</span>, <span class="string">&#x27; &#x27;</span>)</span></span>; <span class="comment">// 映射数组，字母 i + &#x27;a&#x27; 被映射到 to[i]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> k : key) <span class="comment">// 构建映射数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="string">&#x27; &#x27;</span> || to[k - <span class="string">&#x27;a&#x27;</span>] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            to[k - <span class="string">&#x27;a&#x27;</span>] = c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ++c;</span><br><span class="line">        &#125;</span><br><span class="line">        string rst;</span><br><span class="line">        <span class="comment">// 模拟替换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> k : message)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                rst.<span class="built_in">push_back</span>(k);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rst.<span class="built_in">push_back</span>(to[k - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mn>1</mn><mo>+</mo><mi>n</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n1 + n2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">2</span><span class="mclose">)</span></span></span></span> ；空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>c</mi><mo>+</mo><mi>n</mi><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(c + n1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。<code>c</code> 为字母种类数，为 <code>26</code> ，<code>n1</code> 为 <code>message</code> 长度，<code>n2</code> 为 <code>key</code> 长度。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-2"><details class="folding-tag" ><summary> 螺旋矩阵 IV </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/spiral-matrix-iv/">6111. 螺旋矩阵 IV</a></p><p>给你两个整数：<code>m</code> 和 <code>n</code> ，表示矩阵的维数。</p><p>另给你一个整数链表的头节点 <code>head</code> 。</p><p>请你生成一个大小为 <code>m x n</code> 的螺旋矩阵，矩阵包含链表中的所有整数。链表中的整数从矩阵 <strong>左上角</strong> 开始、<strong>顺时针</strong> 按 <strong>螺旋</strong> 顺序填充。如果还存在剩余的空格，则用 <code>-1</code> 填充。</p><p>返回生成的矩阵。</p><div class="note info flat"><p>提示：</p><ul><li><code>1 &lt;= m, n &lt;= 1e5</code></li><li><code>1 &lt;= m * n &lt;= 1e5</code></li><li>链表中节点数目在范围 <code>[1, m * n]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 1000</code></li></ul></div><div class="note primary flat"><p>示例一：<br><img src = "https://assets.leetcode.com/uploads/2022/05/09/ex1new.jpg" alt = "示例一图"></p><p>输入：m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0]<br>输出：[[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]]<br>解释：上图展示了链表中的整数在矩阵中是如何排布的。<br>注意，矩阵中剩下的空格用 -1 填充。</p></div><div class="note primary flat"><p>示例二：<br><img src = "https://assets.leetcode.com/uploads/2022/05/11/ex2.jpg" alt = "示例一图"></p><p>输入：m = 1, n = 4, head = [0,1,2]<br>输出：[[0,1,2,-1]]<br>解释：上图展示了链表中的整数在矩阵中是如何从左到右排布的。<br>注意，矩阵中剩下的空格用 -1 填充。</p></div>              </div>            </details><p>解决方案：</p><p>模拟：</p><p>本题同 <a href="https://leetcode.cn/">LeetCode</a> 上 <a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a> 。只需修改数据的流向即可。这里仅给出我的代码做参考。（但其实我这个写的有点复杂，不是很好描述，有很多更清晰明了的解法可以去  <a href="https://leetcode.cn/">LeetCode</a> 上查找。）</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">spiralMatrix</span>(<span class="type">int</span> m, <span class="type">int</span> n, ListNode *head)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrix</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line">        <span class="type">int</span> stepi = m;</span><br><span class="line">        <span class="type">int</span> stepj = n;</span><br><span class="line">        <span class="type">int</span> cnt;</span><br><span class="line">        <span class="type">int</span> i, j, dir; <span class="comment">// dir表示方向，0为右，1为下，2为左，3为上</span></span><br><span class="line">        i = dir = <span class="number">0</span>;</span><br><span class="line">        j = <span class="number">-1</span>;</span><br><span class="line">        --stepi;</span><br><span class="line">        <span class="keyword">while</span> (head)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">switch</span> (dir)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//右</span></span><br><span class="line">                <span class="keyword">while</span> (head &amp;&amp; cnt &lt; stepj)</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[i][++j] = head-&gt;val;</span><br><span class="line">                    head = head-&gt;next;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                --stepj;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//下</span></span><br><span class="line">                <span class="keyword">while</span> (head &amp;&amp; cnt &lt; stepi)</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[++i][j] = head-&gt;val;</span><br><span class="line">                    head = head-&gt;next;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                --stepi;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//左</span></span><br><span class="line">                <span class="keyword">while</span> (head &amp;&amp; cnt &lt; stepj)</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[i][--j] = head-&gt;val;</span><br><span class="line">                    head = head-&gt;next;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                --stepj;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">while</span> (head &amp;&amp; cnt &lt; stepi)</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[--i][j] = head-&gt;val;</span><br><span class="line">                    head = head-&gt;next;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                --stepi;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++dir;</span><br><span class="line">            dir %= <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。<code>matrix</code> 算结果数组不计入额外空间复杂度。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-3"><details class="folding-tag" ><summary> 知道秘密的人数 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/number-of-people-aware-of-a-secret/">6109. 知道秘密的人数</a></p><p>在第 <code>1</code> 天，有一个人发现了一个秘密。</p><p>给你一个整数 <code>delay</code> ，表示每个人会在发现秘密后的 <code>delay</code> 天之后，<strong>每天Z</strong> 给一个新的人 <strong>分享</strong> 秘密。同时给你一个整数 <code>forget</code> ，表示每个人在发现秘密 <code>forget</code> 天之后会 <strong>忘记</strong> 这个秘密。一个人 <strong>不能</strong> 在忘记秘密那一天及之后的日子里分享秘密。</p><p>给你一个整数 <code>n</code> ，请你返回在第 <code>n</code> 天结束时，知道秘密的人数。由于答案可能会很大，请你将结果对 <code>1e9 + 7</code> <strong>取余</strong> 后返回。</p><div class="note info flat"><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= delay &lt; forget &lt;= n</code></li></ul></div><div class="note primary flat"><p>示例一：</p><p>输入：n = 6, delay = 2, forget = 4<br>输出：5<br>解释：</p><ul><li>第 1 天：假设第一个人叫 A 。（一个人知道秘密）</li><li>第 2 天：A 是唯一一个知道秘密的人。（一个人知道秘密）</li><li>第 3 天：A 把秘密分享给 B 。（两个人知道秘密）</li><li>第 4 天：A 把秘密分享给一个新的人 C 。（三个人知道秘密）</li><li>第 5 天：A 忘记了秘密，B 把秘密分享给一个新的人 D 。（三个人知道秘密）</li><li>第 6 天：B 把秘密分享给 E，C 把秘密分享给 F 。（五个人知道秘密）</li></ul></div><div class="note primary flat"><p>示例二：</p><p>输入：n = 4, delay = 1, forget = 3<br>输出：6<br>解释：</p><ul><li>第 1 天：第一个知道秘密的人为 A 。（一个人知道秘密）</li><li>第 2 天：A 把秘密分享给 B 。（两个人知道秘密）</li><li>第 3 天：A 和 B 把秘密分享给 2 个新的人 C 和 D 。（四个人知道秘密）</li><li>第 4 天：A 忘记了秘密，B、C、D 分别分享给 3 个新的人。（六个人知道秘密）</li></ul></div>              </div>            </details><p>解决方案：</p><p>动态规划：</p><p>本题动态规划的写法有好多中，其中时间复杂度 <code>O(n^2)</code> 的比较简单，此处给出我的时间复杂度 <code>O(n)</code> 的解法（也还有其他不错 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的解法）。</p><p>首先有如下几条显而易见的递推关系：</p><ul><li>第 <code>i</code> 天知道秘密的人数 =  第 <code>i - 1</code> 天知道秘密的人数 - 第 <code>i</code> 天新忘记秘密的人数 + 第 <code>i</code> 天新知道秘密的人数。</li><li>第 <code>i</code> 天新忘记秘密的人数 = 在第 <code>i - forget</code> 天新知道秘密的人数（只有这些人刚好过了 <code>forget</code> 天到达第 <code>i</code> 天）。</li><li>第 <code>i</code> 天新知道秘密的人数 = 第 <code>i - delay</code> 天所有知道秘密的人数 - 从第 <code>i - delay</code> 天之后所有忘记秘密的人数（因为 <code>forget</code> &gt; <code>delay</code> 所以所有在第 <code>i - delay</code> 天之后忘记秘密的人在第 <code>i - delay</code> 天都记得秘密，而其他没有忘记秘密的人则是第 <code>i</code> 天可以传播秘密的人）。</li><li>第 <code>i</code> 天为止所有忘记秘密的人数 = 第 <code>i - 1</code> 天所有忘记秘密的人数 + 第 <code>i</code> 天新忘记秘密的人数。</li></ul><p>我们维护三个数组：</p><ul><li><code>dp[i]</code> 表示第 <code>i</code> 天知道秘密的人数。</li><li><code>f[i]</code> 表示到第 <code>i</code> 天为止所有忘记秘密的人数。</li><li><code>k[i]</code> 表示第 <code>i</code> 天新知道秘密的人数。</li></ul><p>那么有：</p><ul><li><code>f[i] = f[i - 1] + k[i - forget]</code> 。</li><li><code>k[i] = dp[i - delay] - (f[i] - f[i - delay])</code> 。</li><li><code>dp[i] = dp[i - 1] - k[i - forget] + k[i]</code> 。</li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peopleAwareOfSecret</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> delay, <span class="type">int</span> forget)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="type">int</span> f[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// f[i] = 到第 i 天为止所有忘记秘密的人数</span></span><br><span class="line">        <span class="type">int</span> k[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// k[i] = 第 i 天新知道秘密的人数</span></span><br><span class="line">        <span class="type">int</span> dp[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// dp[i] = 第 i 天知道秘密的人数</span></span><br><span class="line">        <span class="comment">// dp[i] = dp[i - 1] - 第 i 天新忘记秘密的人数 + 第 i 天新知道秘密的人数</span></span><br><span class="line">        <span class="comment">// 第 i 天新忘记秘密的人数 = 第 i - forget 天增加的知道秘密的人数</span></span><br><span class="line">        <span class="comment">// 第 i 天新知道秘密的人数 = 第 i - delay 天所有知道秘密的人数 - 从第 i - delay 天之后所有忘记秘密的人数</span></span><br><span class="line">        <span class="comment">// 第 i 天为止所有忘记秘密的人数 = 第 i - 1 天所有忘记秘密的人数 + 第 i 天新忘记秘密的人数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// f[i] = f[i - 1] + k[i - forget]</span></span><br><span class="line">        <span class="comment">// k[i] = dp[i - delay] - (f[i] - f[i - delay])</span></span><br><span class="line">        <span class="comment">// dp[i] = dp[i - 1] - k[i - forget] + k[i]</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        f[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        k[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> d;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i &gt; forget)</span><br><span class="line">                f[i] = (f[i] + k[i - forget]) % MOD;</span><br><span class="line"></span><br><span class="line">            k[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; delay)</span><br><span class="line">                k[i] = (dp[i - delay] - (f[i] - f[i - delay] + MOD) % MOD + MOD) % MOD;</span><br><span class="line"></span><br><span class="line">            dp[i] = (dp[i - <span class="number">1</span>] + k[i]) % MOD;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; forget)</span><br><span class="line">                dp[i] = (dp[i] - k[i - forget] + MOD) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ；空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-4"><details class="folding-tag" ><summary> 网格图中递增路径的数目 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid/">6110. 网格图中递增路径的数目</a></p><p>给你一个 <code>m x n</code> 的整数网格图 <code>grid</code> ，你可以从一个格子移动到 <code>4</code> 个方向相邻的任意一个格子。</p><p>请你返回在网格图中从 <strong>任意</strong> 格子出发，达到 <strong>任意</strong> 格子，且路径中的数字是 <strong>严格递增</strong> 的路径数目。由于答案可能会很大，请将结果对 <code>1e9 + 7</code> <strong>取余</strong> 后返回。</p><p>如果两条路径中访问过的格子不是完全相同的，那么它们视为两条不同的路径。</p><div class="note info flat"><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 1000</code></li><li><code>1 &lt;= m * n &lt;= 1e5</code></li><li><code>1 &lt;= grid[i][j] &lt;= 1e5</code></li></ul></div><div class="note primary flat"><p>示例一：</p><img src = "https://assets.leetcode.com/uploads/2022/05/10/griddrawio-4.png"  alt = "示例一图"><p>输入：grid = [[1,1],[3,4]]<br>输出：8<br>解释：严格递增路径包括：</p><ul><li>长度为 1 的路径：[1]，[1]，[3]，[4] 。</li><li>长度为 2 的路径：[1 -&gt; 3]，[1 -&gt; 4]，[3 -&gt; 4] 。</li><li>长度为 3 的路径：[1 -&gt; 3 -&gt; 4] 。</li></ul><p>路径数目为 4 + 3 + 1 = 8 。</p></div><div class="note primary flat"><p>示例二：<br>输入：grid = [[1],[2]]<br>输出：3<br>解释：严格递增路径包括：</p><ul><li>长度为 1 的路径：[1]，[2] 。</li><li>长度为 2 的路径：[1 -&gt; 2] 。</li></ul><p>路径数目为 2 + 1 = 3 。</p></div>              </div>            </details><p>解决方案：</p><p>DFS 记忆化搜索：</p><p>设 <code>dp[i][j]</code> 表示以 <code>grid[i][j]</code> 为终点的路径数，那么可以递归计算 <code>grid[i][j]</code> 四个方向上所有值小于其的格子的路径数。若某个格子的路径数已经计算完毕，则下次递归到它的时候可以直接返回 <code>dp</code> 。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        dp[x][y] = <span class="number">1</span>; <span class="comment">// 自身长度为 1 的路径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) <span class="comment">// 遍历四个方向上的格子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> ny = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(nx &gt;=<span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;=<span class="number">0</span> &amp;&amp; ny &lt; n &amp;&amp; grid[nx][ny] &lt; grid[x][y]) <span class="comment">// 满足条件的前驱格子</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[nx][ny] == <span class="number">0</span>) <span class="comment">// 若没有计算过就计算它</span></span><br><span class="line">                    <span class="built_in">dfs</span>(grid, nx, ny);</span><br><span class="line">                dp[x][y] = (dp[x][y] + dp[nx][ny]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPaths</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m = grid.<span class="built_in">size</span>();</span><br><span class="line">        n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        dp = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>)); <span class="comment">// 初始化为 0 而不是 1 的作用是判断该格子的路径数是否已经计算过了</span></span><br><span class="line">        <span class="type">int</span> i, j, rst = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; ++i) <span class="comment">// 计算以 grid[i][j] 为终点的路径数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] == <span class="number">0</span>) <span class="comment">// 若没有计算过就计算它</span></span><br><span class="line">                    <span class="built_in">dfs</span>(grid, i, j);</span><br><span class="line">                rst = (rst + dp[i][j]) % MOD; <span class="comment">// 最终结果是所有路径的总和</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>dp[i][j]</code> 只计算一次，时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ；空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode周赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 题解 </tag>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录 LeetCode 第 299 场周赛</title>
      <link href="/2022/LC-WeeklyContext-299/"/>
      <url>/2022/LC-WeeklyContext-299/</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p><a href="https://leetcode.cn/contest/weekly-contest-299/">本次周赛</a>依旧只写出前三题。</p></div><h1>战局详情</h1><table><thead><tr><th>排名</th><th>用户名</th><th>得分</th><th>完成时间</th><th>题目1（3）</th><th>题目2（4）</th><th>题目3（5）</th><th>题目4（6）</th></tr></thead><tbody><tr><td>639 / 6108</td><td>Juruoer</td><td>12</td><td>0:36:29</td><td>0:04:27</td><td>0:15:56</td><td>0:31:29 <i class="fa-solid fa-bug"></i> 1</td><td></td></tr></tbody></table><h1>题目及解答</h1><div class="tabs" id="problems"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#problems-1">题目1</button></li><li class="tab"><button type="button" data-href="#problems-2">题目2</button></li><li class="tab"><button type="button" data-href="#problems-3">题目3</button></li><li class="tab"><button type="button" data-href="#problems-4">题目4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="problems-1"><details class="folding-tag" ><summary> 判断矩阵是否是一个 X 矩阵 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/check-if-matrix-is-x-matrix/">2319. 判断矩阵是否是一个 X 矩阵</a></p><p>如果一个正方形矩阵满足下述 全部 条件，则称之为一个 <strong>X</strong> 矩阵 ：</p><ul><li>矩阵对角线上的所有元素都 <strong>不是 0</strong></li><li>矩阵中所有其他元素都是 <strong>0</strong></li></ul><p>给你一个大小为 <code>n x n</code> 的二维整数数组 <code>grid</code> ，表示一个正方形矩阵。如果 <code>grid</code> 是一个 <strong>X 矩阵</strong> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><div class="note info flat"><p>提示：</p><ul><li><code>n == grid.length == grid[i].length</code></li><li><code>3 &lt;= n &lt;= 100</code></li><li><code>0 &lt;= grid[i][j] &lt;= 1e5</code></li></ul></div><div class="note primary flat"><p>示例一：</p><img src = "https://assets.leetcode.com/uploads/2022/05/03/ex1.jpg" alt = "示例一图"><p>输入：grid = [[2,0,0,1],[0,3,1,0],[0,5,2,0],[4,0,0,2]]<br>输出：true<br>解释：矩阵如上图所示。<br>X 矩阵应该满足：绿色元素（对角线上）都不是 0 ，红色元素都是 0 。<br>因此，grid 是一个 X 矩阵。</p></div><div class="note primary flat"><p>示例二：</p><img src = "https://assets.leetcode.com/uploads/2022/05/03/ex2.jpg" alt = "示例二图"><p>输入：grid = [[5,7,0],[0,3,1],[0,5,0]]<br>输出：false<br>解释：矩阵如上图所示。<br>X 矩阵应该满足：绿色元素（对角线上）都不是 0 ，红色元素都是 0 。<br>因此，grid 不是一个 X 矩阵。</p></div>              </div>            </details><p>解决方案：</p><p>模拟：</p><p>遍历二维数组（设为 n 行 n 列），若某元素下标 <code>i</code>，<code>j</code> 满足：<code>i == j </code> 或 <code>i + j == n - 1</code> 则为对角线元素，否则为非对角线元素。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkXMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((i == j) || (i + j == n - <span class="number">1</span>)) <span class="comment">// 对角线元素</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">if</span>(grid[i][j] != <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ；空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-2"><details class="folding-tag" ><summary> 统计放置房子的方式数 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/count-number-of-ways-to-place-houses/">2320. 统计放置房子的方式数</a></p><p>一条街道上共有 <code>n * 2</code> 个 地块 ，街道的两侧各有 <code>n</code> 个地块。每一边的地块都按从 <code>1</code> 到 <code>n</code> 编号。每个地块上都可以放置一所房子。</p><p>现要求街道同一侧不能存在两所房子相邻的情况，请你计算并返回放置房屋的方式数目。由于答案可能很大，需要对 <code>1e9 + 7</code> 取余后再返回。</p><p>注意，如果一所房子放置在这条街某一侧上的第 <code>i</code> 个地块，不影响在另一侧的第 <code>i</code> 个地块放置房子。</p><div class="note info flat"><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 1e4</code></li></ul></div><div class="note primary flat"><p>示例一：</p><p>输入：n = 1<br>输出：4<br>解释：<br>可能的放置方式：</p><ol><li>所有地块都不放置房子。</li><li>一所房子放在街道的某一侧。</li><li>一所房子放在街道的另一侧。</li><li>放置两所房子，街道两侧各放置一所。</li></ol></div><div class="note primary flat"><p>示例二：</p><img src = "https://assets.leetcode.com/uploads/2022/05/12/arrangements.png" alt = "示例二图"><p>输入：n = 2<br>输出：9<br>解释：如上图所示，共有 9 种可能的放置方式。</p></div>              </div>            </details><p>解决方案：</p><p>动态规划：</p><p>因为街道一侧的房子并不影响另一侧房子的摆放方式，所以只需要计算出一侧的摆放方式，其平分即为两侧摆放的总方式。</p><p>对于某一侧，设：</p><ul><li><code>dp[i][0]</code> 表示自第 <code>0</code> 个地块起到第 <code>i</code> 个地块为止，且第 <code>i</code> 个地块 <strong>不摆放</strong> 房子的方式数，它是前一个位置摆放房子的方式数和前一个位置不摆放房子的方式数的总和。</li><li><code>dp[i][1]</code> 表示自第 <code>0</code> 个地块起到第 <code>i</code> 个地块为止，且第 <code>i</code> 个地块 <strong>摆放</strong> 房子的方式数，它与前一个位置不摆放房子的方式数相同（两所房子不能相邻）。</li></ul><p>那么有：</p><ul><li><code>dp[i][0] = dp[i - 1][0] + dp[i - 1][1]</code> 。</li><li><code>dp[i][1] = dp[i - 1][0]</code> 。</li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countHousePlacements</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[n][<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="comment">// dp[i][0] = dp[i - 1][0] + dp[i - 1][1]</span></span><br><span class="line">        <span class="comment">// dp[i][1] = dp[i][0]</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = (dp[i - <span class="number">1</span>][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">1</span>]) % MOD;</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x = (dp[n - <span class="number">1</span>][<span class="number">0</span>] + dp[n - <span class="number">1</span>][<span class="number">1</span>]) % MOD;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1LL</span> * x * x) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ；空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。由于 <code>dp[i]</code> 只依赖于 <code>dp[i - 1]</code> ， 故空间复杂度可以优化到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>  <s>(非常简单就不写了)</s> 。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-3"><details class="folding-tag" ><summary> 拼接数组的最大分数 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/maximum-score-of-spliced-array/">2321. 拼接数组的最大分数</a></p><p>给你两个下标从 <strong>0</strong> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> ，长度都是 <code>n</code> 。</p><p>你可以选择两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>0 &lt;= left &lt;= right &lt; n</code> ，接着 <strong>交换</strong> 两个子数组 <code>nums1[left...right]</code> 和 <code>nums2[left...right]</code> 。</p><ul><li>例如，设 <code>nums1 = [1,2,3,4,5]</code> 和 <code>nums2 = [11,12,13,14,15]</code> ，整数选择 <code>left = 1</code> 和 <code>right = 2</code>，那么 <code>nums1</code> 会变为 <code>[1,12,13,4,5]</code> 而 <code>nums2</code> 会变为 <code>[11,2,3,14,15]</code> 。</li></ul><p>你可以选择执行上述操作 <strong>一次</strong> 或不执行任何操作。</p><p>数组的 <strong>分数</strong> 取 <code>sum(nums1)</code> 和 <code>sum(nums2)</code> 中的最大值，其中 <code>sum(arr)</code> 是数组 <code>arr</code> 中所有元素之和。</p><p>返回 <strong>可能的最大分数</strong> 。</p><p><strong>子数组</strong> 是数组中连续的一个元素序列。<code>arr[left...right]</code> 表示子数组包含 <code>nums</code> 中下标 <code>left</code> 和 <code>right</code> 之间的元素（<strong>含</strong> 下标 <code>left</code> 和 <code>right</code> 对应元素）。</p><div class="note info flat"><p>提示：</p><ul><li><code>n == nums1.length == nums2.length</code></li><li><code>1 &lt;= n &lt;= 1e5</code></li><li><code>1 &lt;= nums1[i], nums2[i] &lt;= 1e4</code></li></ul></div><div class="note primary flat"><p>示例一：</p><p>输入：nums1 = [60,60,60], nums2 = [10,90,10]<br>输出：210<br>解释：选择 left = 1 和 right = 1 ，得到 nums1 = [60,90,60] 和 nums2 = [10,60,10] 。<br>分数为 max(sum(nums1), sum(nums2)) = max(210, 80) = 210 。</p></div><div class="note primary flat"><p>示例二：</p><p>输入：nums1 = [20,40,20,70,30], nums2 = [50,20,50,40,20]<br>输出：220<br>解释：选择 left = 3 和 right = 4 ，得到 nums1 = [20,40,20,40,20] 和 nums2 = [50,20,50,70,30] 。<br>分数为 max(sum(nums1), sum(nums2)) = max(140, 220) = 220 。</p></div><div class="note primary flat"><p>示例三：</p><p>输入：nums1 = [7,11,13], nums2 = [1,1,1]<br>输出：31<br>解释：选择不交换任何子数组。<br>分数为 max(sum(nums1), sum(nums2)) = max(31, 3) = 31 。</p></div>              </div>            </details><p>解决方案：</p><p>动态规划：</p><p>分为两种情况：</p><ul><li>最终结果为 <code>nums2</code> 的子数组被交换到了 <code>nums1</code> 中。</li><li>最终结果为 <code>nums1</code> 的子数组被交换到了 <code>nums2</code> 中。</li></ul><p>这两种情况隐含了没有交换子数组的情况。</p><p>我们先研究第一种情况：</p><p>朴素的想法是，我们枚举出所有的子数组范围，然后挨个计算交换后 <code>nums1</code> 的元素和，取最大值。但是其中有一些范围，若我们交换后 <code>nums1</code> 元素和反而减少了，这种情况是可以优化排除掉的。</p><p>应当找出所有交换后 <code>nums1</code> 元素和增大的情况，可以使用双指针法：</p><p>设某个范围起点为 <code>i</code> ，终点为 <code>j</code>，不断增加 <code>j</code> 以扩大交换范围，并在此过程中计算每一次 <code>j</code> 变化后的 <code>nums2</code> 和 <code>nums1</code> 在该范围的元素和的差值，记录最大的差值，直到某次增加 <code>j</code> 后，差值为负，说明该范围 <code>nums2</code> 的元素和小于 <code>nums1</code> 的元素和，那么以 <code>i</code> 为起点的范围便就此结束，最终的结果的范围一定不会是自 <code>i</code> 到此时 <code>j</code> 之后的范围（但可能是 <code>i</code> 到 <code>j</code> 之前的某个范围，所以我们需要记录每次 <code>j</code> 增加后的差值，取最大值），因为范围 <code>i</code> 到 <code>j</code> 已然相当于一个累赘，之后的范围加上这个范围，差值只会更小，所以要从 <code>j</code> 处开始新的范围了（即令 i = j）。</p><p>这个过程中 <code>i</code> 是可以不显式的表示出来的。</p><p>若 <code>dp[j]</code> 表示 <code>i</code> （<code>i</code> 在什么位置无需知道）到 <code>j</code> 范围内交换元素，<code>nums1</code> 可以获得的增量，任何情况下 <code>dp[j] &gt;= 0</code> ，当增量为负时，范围起点变为 <code>j</code> 增量变为 <code>0</code> 相当于不交换元素的增量。在此过程中，用 <code>_max</code> 记录最大的增量。则有：</p><ul><li><code>dp[j] = max(dp[j - 1] + (nums2[j] - nums1[j]), 0);</code></li><li><code>_max = _max(_max, dp[j]);</code></li></ul><p>同理，第二种情况也是如此。</p><p>由于 <code>dp[j]</code> 只依赖 <code>dp[j - 1]</code> ，所以可以使用一个 <code>int dp</code> 来优化空间。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumsSplicedArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums1, vector&lt;<span class="type">int</span>&gt; &amp;nums2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum1 = <span class="built_in">accumulate</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>(), <span class="number">0</span>); <span class="comment">// nums1 的元素和</span></span><br><span class="line">        <span class="type">int</span> sum2 = <span class="built_in">accumulate</span>(nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>(), <span class="number">0</span>); <span class="comment">// nums2 的元素和</span></span><br><span class="line">        <span class="type">int</span> i, n = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dp1, dp2;</span><br><span class="line">        <span class="comment">// dp1 和 max1 记录情况一，dp2 和 max2 记录情况二</span></span><br><span class="line">        dp1 = <span class="built_in">max</span>(nums2[<span class="number">0</span>] - nums1[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">        dp2 = <span class="built_in">max</span>(nums1[<span class="number">0</span>] - nums2[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> max1, max2;</span><br><span class="line">        max1 = dp1;</span><br><span class="line">        max2 = dp2;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++i) <span class="comment">// 范围自 i 之前的某个位置到 i（此处 i 为上述分析的 j）</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp1 = <span class="built_in">max</span>(dp1 + (nums2[i] - nums1[i]), <span class="number">0</span>); <span class="comment">// 当 dp1 + (nums2[i] - nums1[i]) &lt; 0 时，即是改变范围起点之时，新的范围开始时，dp1 = 0</span></span><br><span class="line">            dp2 = <span class="built_in">max</span>(dp2 + (nums1[i] - nums2[i]), <span class="number">0</span>); <span class="comment">// dp2 同理</span></span><br><span class="line">            max1 = <span class="built_in">max</span>(max1, dp1); <span class="comment">// 在此过程中更新最大的差值</span></span><br><span class="line">            max2 = <span class="built_in">max</span>(max2, dp2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(sum1 + max1, sum2 + max2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ；空间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。<code>n</code> 为数组长度。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-4"><details class="folding-tag" ><summary> 从树中删除边的最小分数 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/minimum-score-after-removals-on-a-tree/">2322. 从树中删除边的最小分数</a></p><p>存在一棵无向连通树，树中有编号从 <code>0</code> 到 <code>n - 1</code> 的 <code>n</code> 个节点， 以及 <code>n - 1</code> 条边。</p><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，长度为 <code>n</code> ，其中 <code>nums[i]</code> 表示第 <code>i</code> 个节点的值。另给你一个二维整数数组 <code>edges</code> ，长度为 <code>n - 1</code> ，其中 <code>edges[i] = [ai, bi]</code> 表示树中存在一条位于节点 <code>ai</code> 和 <code>bi</code> 之间的边。</p><p>删除树中两条 <strong>不同</strong> 的边以形成三个连通组件。对于一种删除边方案，定义如下步骤以计算其分数：</p><ol><li>分别获取三个组件 <strong>每个</strong> 组件中所有节点值的异或值。</li><li><strong>最大</strong> 异或值和 <strong>最小Z</strong> 异或值的 <strong>差值</strong> 就是这一种删除边方案的分数。</li></ol><ul><li>例如，三个组件的节点值分别是：<code>[4,5,7]</code>、<code>[1,9]</code> 和 <code>[3,3,3]</code> 。三个异或值分别是 <code>4 ^ 5 ^ 7 = 6</code>、<code>1 ^ 9 = 8</code> 和 <code>3 ^ 3 ^ 3 = 3</code> 。最大异或值是 <code>8</code> ，最小异或值是 <code>3</code> ，分数是 <code>8 - 3 = 5</code> 。<br>返回在给定树上执行任意删除边方案可能的 <strong>最小</strong> 分数。</li></ul><div class="note info flat"><p>提示：</p><ul><li><code>n == nums.length</code></li><li><code>3 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= 1e8</code></li><li><code>edges.length == n - 1</code></li><li><code>edges[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; n</code></li><li><code>ai != bi</code></li><li><code>edges</code> 表示一棵有效的树</li></ul></div><div class="note primary flat"><p>示例一：</p><img src = "https://assets.leetcode.com/uploads/2022/05/03/ex1drawio.png" alt = "示例一图"><p>输入：nums = [1,5,5,4,11], edges = [[0,1],[1,2],[1,3],[3,4]]<br>输出：9<br>解释：上图展示了一种删除边方案。</p><ul><li>第 1 个组件的节点是 [1,3,4] ，值是 [5,4,11] 。异或值是 5 ^ 4 ^ 11 = 10 。</li><li>第 2 个组件的节点是 [0] ，值是 [1] 。异或值是 1 = 1 。</li><li>第 3 个组件的节点是 [2] ，值是 [5] 。异或值是 5 = 5 。</li></ul><p>分数是最大异或值和最小异或值的差值，10 - 1 = 9 。<br>可以证明不存在分数比 9 小的删除边方案。</p></div><div class="note primary flat"><p>示例二：</p><img src = "https://assets.leetcode.com/uploads/2022/05/03/ex2drawio.png" alt = "示例一图"><p>输入：nums = [5,5,2,4,4,2], edges = [[0,1],[1,2],[5,2],[4,3],[1,3]]<br>输出：0<br>解释：上图展示了一种删除边方案。</p><ul><li>第 1 个组件的节点是 [3,4] ，值是 [4,4] 。异或值是 4 ^ 4 = 0 。</li><li>第 2 个组件的节点是 [1,0] ，值是 [5,5] 。异或值是 5 ^ 5 = 0 。</li><li>第 3 个组件的节点是 [2,5] ，值是 [2,2] 。异或值是 2 ^ 2 = 0 。</li></ul><p>分数是最大异或值和最小异或值的差值，0 - 0 = 0 。<br>无法获得比 0 更小的分数 0 。</p></div>              </div>            </details><p>解决方案：<br>DFS：</p><p>本方法参考至大佬 <a href="https://leetcode.cn/u/endlesscheng/">灵茶山艾府</a> 的 <a href="https://leetcode.cn/problems/minimum-score-after-removals-on-a-tree/solution/dfs-shi-jian-chuo-chu-li-shu-shang-wen-t-x1kk/">题解</a> 。</p><p>首先为无向连通图设立一个根节点，假设为 <code>0</code> 节点。</p><p>对于这棵树，可以通过 <code>dfs</code> 算法来计算各个子树的异或值（假设 <code>_xor[i]</code> 为以 <code>i</code> 为根节点的子树的异或值），然后遍历所有可能的删边情况，计算各种情况下的分数。</p><p>假设删除了两条边： <code>x1-y1</code> 和 <code>x2-y2</code>，其中 <code>x1</code> 为 <code>y1</code> 的父节点，<code>x2</code> 为 <code>y2</code> 的父节点，那么我们就将树大体分为了三部分，以 <code>y1</code> 为根节点的子树 <code>tree[y1]</code>，以 <code>y2</code> 为根节点的子树 <code>tree[y2]</code> ，树的其他部分 <code>tree[0] - （tree[y1] ∪ tree[y2]）</code> 。但还有一个问题，<code>tree[y1]</code> 和 <code>tree[y2]</code> 可能有交集，也就是说 <code>tree[y1]</code> 可能是 <code>tree[y2]</code> 的子树，或者相反。我们先不管如何判断谁是谁的子树，先给出各种情况下各部分的异或值，设三部分的异或值分别为 <code>x</code> 、<code>y</code> 、<code>z</code>：</p><ul><li><code>tree[y1]</code> 是 <code>tree[y2]</code> 的子树：<code>x = _xor[y1], y = </code>_xor[y2] ^ x, z = _xor[0] ^ _xor[y2]` 。</li><li><code>tree[y2]</code> 是 <code>tree[y1]</code> 的子树：<code>x = _xor[y2], y = </code>_xor[y1] ^ x, z = _xor[0] ^ _xor[y1]` 。</li><li><code>tree[y2]</code> 和 <code>tree[y1]</code> 没有交集：<code>x = _xor[y1], y = _xor[y2], z = _xor[0] ^ x ^ y</code>;</li></ul><p>那么当前的问题便被转化为如何判断 <code>y1</code> 和 <code>y2</code> 的从属关系。若是使用并查集或遍历的方法时间复杂度太高，能否用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 时间复杂度来判断呢？答案是可以，使用时间戳来判断。</p><p>由于之前是通过 <code>dfs</code> 来计算各个子树的异或值的，所以可以标记递归到每个节点时的递归进入时间戳和递归结束时间戳，假设 <code>in[i]</code> 表示递归到 <code>i</code> 节点时的时间戳，<code>out[i]</code> 表示 <code>i</code> 节点递归结束时的时间戳，倘若：</p><ul><li><code>in[i] &lt; in[j] &lt; out[j] &lt; out[i]</code>，那么表明对 <code>j</code> 的递归是在对 <code>i</code> 的递归的过程中完成的，也就是说，<code>j</code> 是 <code>i</code> 的子孙节点，由递归的过程可知，当满足 <code>in[i] &lt; in[j] &lt; out[i]</code> 时一定满足 <code>out[j] &lt; out[i]</code> 。</li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; in; <span class="comment">// in[i] 表示第 i 个点递归起始时间戳</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; out; <span class="comment">// out[i] 表示第 i 个点递归结束时间戳</span></span><br><span class="line">    <span class="comment">// 对于节点 i 和节点 j，若 in[i] &lt; in[j] &lt; out[j] &lt; out[i] 则 i 为 j 的祖先节点，可简化为：in[i] &lt; in[j] &lt; out[j]</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; _xor; <span class="comment">// _xor[i] 表示以节点 i 为根节点的子树的异或值</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; g; <span class="comment">// g[i] 表示于 i 直接相连的点集</span></span><br><span class="line">    <span class="type">int</span> clock = <span class="number">0</span>; <span class="comment">// 计时器</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> par, vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        in[root] = ++clock; <span class="comment">// 记录进入时间戳</span></span><br><span class="line">        _xor[root] = nums[root];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : g[root]) <span class="comment">// 对于所有与 root 相连的点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch != par) <span class="comment">// 若该点不是 root 父节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(ch, root, nums);</span><br><span class="line">                _xor[root] ^= _xor[ch];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        out[root] = ++clock; <span class="comment">// 记录结束时间戳</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;edges)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        in.<span class="built_in">resize</span>(n);</span><br><span class="line">        out.<span class="built_in">resize</span>(n);</span><br><span class="line">        _xor.<span class="built_in">resize</span>(n);</span><br><span class="line">        g.<span class="built_in">resize</span>(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : edges)</span><br><span class="line">        &#123;</span><br><span class="line">            g[e[<span class="number">0</span>]].<span class="built_in">push_back</span>(e[<span class="number">1</span>]);</span><br><span class="line">            g[e[<span class="number">1</span>]].<span class="built_in">push_back</span>(e[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以 0 为根节点，计算树中各子树的异或值</span></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>, nums);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i, j; <span class="comment">// 以节点 i 和节点 j 为根的子树独立出来，相当于在原树上删除两条边</span></span><br><span class="line">        <span class="type">int</span> x, y, z, ans = <span class="number">0x7fffffff</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; n; ++i) <span class="comment">// 选定以 i 为根节点子树，删除点 i 和其父节点的边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; i; ++j) <span class="comment">// 选定以 j 为根节点子树，删除点 j 和其父节点的边</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((in[i] &lt; in[j] &amp;&amp; in[j] &lt; out[i])) <span class="comment">// j 是 i 的子树</span></span><br><span class="line">                &#123;</span><br><span class="line">                    x = _xor[j]; <span class="comment">// 子树 j 的异或值</span></span><br><span class="line">                    y = _xor[i] ^ x; <span class="comment">// 子树 i 去除子树 j 的异或值</span></span><br><span class="line">                    z = _xor[<span class="number">0</span>] ^ _xor[i]; <span class="comment">// 树去除子树 i 的异或值</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(in[j] &lt; in[i] &amp;&amp; in[i] &lt; out[j]) <span class="comment">// i 是 j 的子树</span></span><br><span class="line">                &#123;</span><br><span class="line">                    x = _xor[i]; <span class="comment">// 子树 i 的异或值</span></span><br><span class="line">                    y = _xor[j] ^ x; <span class="comment">// 子树 j 去除子树 i 的异或值</span></span><br><span class="line">                    z = _xor[<span class="number">0</span>] ^ _xor[j]; <span class="comment">// 树去除子树 j 的异或值</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123; <span class="comment">// 两棵没有交集的子树</span></span><br><span class="line">                    x = _xor[i]; <span class="comment">// 子树 i 的异或值</span></span><br><span class="line">                    y = _xor[j]; <span class="comment">// 子树 j 的异或值</span></span><br><span class="line">                    z = _xor[<span class="number">0</span>] ^ x ^ y; <span class="comment">// 树去除子树 i 和子树 j 的异或值</span></span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, (<span class="built_in">max</span>(x, <span class="built_in">max</span>(y, z)) - <span class="built_in">min</span>(x, <span class="built_in">min</span>(y, z))));</span><br><span class="line">                <span class="keyword">if</span> (ans == <span class="number">0</span>) <span class="comment">// 不可能有比 0 更小的结果</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m + n ^ 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ；<code>g</code> 的大小和边数正比，其他数组大小同 <code>n</code>，空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。<code>m</code> 为 边，<code>n</code> 为节点数。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode周赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 题解 </tag>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录 LeetCode 第 81 场双周赛</title>
      <link href="/2022/LC-BiweeklyContext-81/"/>
      <url>/2022/LC-BiweeklyContext-81/</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p><a href="https://leetcode.cn/contest/biweekly-contest-81/">本次周赛 </a>依旧只写出前三题，第四题动态规划转移方程想了很久没整出来 <s>(明明很简单！)</s> 。</p></div><h1>战局详情</h1><table><thead><tr><th>排名</th><th>用户名</th><th>得分</th><th>完成时间</th><th>题目1（3）</th><th>题目2（5）</th><th>题目3（5）</th><th>题目4（6）</th></tr></thead><tbody><tr><td>640 / 3847</td><td>Juruoer</td><td>13</td><td>0:39:05</td><td>0:02:51</td><td>0:20:14</td><td>0:39:05</td><td></td></tr></tbody></table><h1>题目及解答</h1><div class="tabs" id="problems"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#problems-1">题目1</button></li><li class="tab"><button type="button" data-href="#problems-2">题目2</button></li><li class="tab"><button type="button" data-href="#problems-3">题目3</button></li><li class="tab"><button type="button" data-href="#problems-4">题目4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="problems-1"><details class="folding-tag" ><summary> 统计星号 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/count-asterisks/">2315. 统计星号</a></p><p>给你一个字符串 <code>s</code> ，每 <strong>两个</strong> 连续竖线 <code>'|'</code> 为 <strong>一对</strong> 。换言之，第一个和第二个 <code>'|'</code> 为一对，第三个和第四个 <code>'|'</code> 为一对，以此类推。</p><p>请你返回 <strong>不在</strong> 竖线对之间，<code>s</code> 中 <code>'*'</code> 的数目。</p><p><strong>注意</strong>，每个竖线 <code>'|'</code> 都会 <strong>恰好</strong> 属于一个对。</p><div class="note info flat"><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 只包含小写英文字母，竖线 <code>'|'</code> 和星号 <code>'*'</code> 。</li><li><code>s</code> 包含 <strong>偶数</strong> 个竖线 <code>'|'</code> 。</li></ul></div><div class="note primary flat"><p>示例一：</p><p>输入：s = “l|*e*et|c**o|*de|”<br>输出：2<br>解释：不在竖线对之间的字符加粗加斜体后，得到字符串：“<em><strong>l</strong></em>|*e*et|<em><strong>c**o</strong></em>|*de|” 。<br>第一和第二条竖线 ‘|’ 之间的字符不计入答案。<br>同时，第三条和第四条竖线 ‘|’ 之间的字符也不计入答案。<br>不在竖线对之间总共有 2 个星号，所以我们返回 2 。</p></div><div class="note primary flat"><p>示例二：</p><p>输入：s = “iamprogrammer”<br>输出：0<br>解释：在这个例子中，s 中没有星号。所以返回 0 。</p></div><div class="note primary flat"><p>示例三：</p><p>输入：s = “yo|uar|e**|b|e***au|tifu|l”<br>输出：5<br>解释：需要考虑的字符加粗加斜体后：“<em><strong>yo</strong></em>|uar|<em><strong>e**</strong></em>|b|<em><strong>e***au</strong></em>|tifu|<em><strong>l</strong></em>” 。不在竖线对之间总共有 5 个星号。所以我们返回 5 。</p></div>              </div>            </details><p>解决方案：</p><p>模拟：</p><p>使用一个标记来判断当前字符是否在一对 <code>'|'</code> 之中。可以发现，每遇到一个 <code>'|'</code> ，标记取反。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countAsterisks</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> rst = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;|&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = !flag;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag &amp;&amp; c == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                ++rst;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ；空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。 <code>n</code> 为 <code>s</code> 长度。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-2"><details class="folding-tag" ><summary> 统计无向图中无法互相到达点对数 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/">2316. 统计无向图中无法互相到达点对数</a></p><p>给你一个整数 <code>n</code> ，表示一张 <strong>无向图</strong> 中有 <code>n</code> 个节点，编号为 <code>0</code> 到 <code>n - 1</code> 。同时给你一个二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ai, bi]</code> 表示节点 <code>ai</code> 和 <code>bi</code> 之间有一条 <strong>无向</strong> 边。</p><p>请你返回 <strong>无法互相到达</strong> 的不同 <strong>点对数目</strong> 。</p><div class="note info flat"><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 1e5</code></li><li><code>0 &lt;= edges.length &lt;= 2 * 1e5</code></li><li><code>edges[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; n</code></li><li><code>ai != bi</code></li><li>不会有重复边。</li></ul></div><div class="note primary flat"><p>示例一：</p><img src = "https://assets.leetcode.com/uploads/2022/05/05/tc-3.png" alt = "示例一图"><p>输入：n = 3, edges = [[0,1],[0,2],[1,2]]<br>输出：0<br>解释：所有点都能互相到达，意味着没有点对无法互相到达，所以我们返回 0 。</p></div><div class="note primary flat"><p>示例二：</p><img src = "https://assets.leetcode.com/uploads/2022/05/05/tc-2.png" alt = "示例二图"><p>输入：n = 7, edges = [[0,2],[0,5],[2,4],[1,6],[5,4]]<br>输出：14<br>解释：总共有 14 个点对互相无法到达：<br>[[0,1],[0,3],[0,6],[1,2],[1,3],[1,4],[1,5],[2,3],[2,6],[3,4],[3,5],[3,6],[4,6],[5,6]]<br>所以我们返回 14 。</p></div>              </div>            </details><p>解决方案：</p><p>并查集：</p><p>利用并查集计算出所有连通图的节点个数，根据数学的排列组合知识即可计算出无法相互到达的点对数。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; root; <span class="comment">// 记录每个节点的根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 查找节点 x 的根节点，利用递归来压缩路径</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root[x] != x)</span><br><span class="line">            root[x] = <span class="built_in">find</span>(root[x]);</span><br><span class="line">        <span class="keyword">return</span> root[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countPairs</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;edges)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> rst = <span class="number">0</span>;</span><br><span class="line">        root.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="type">int</span> have[n]; <span class="comment">// 记录每个根节点的连通图的节点数</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始时假设所有节点都孤立，每个点的根节点是其自己</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            root[i] = i;</span><br><span class="line">            have[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据给定的边将各点连通</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : edges)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r1 = <span class="built_in">find</span>(x[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">int</span> r2 = <span class="built_in">find</span>(x[<span class="number">1</span>]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果 r1 和 r2 之前不属于同一个连通图，但它们之间有边，将 r2 的连通图加入到 r1 的连通图里</span></span><br><span class="line">            <span class="keyword">if</span>(r1 != r2)</span><br><span class="line">            &#123;</span><br><span class="line">                root[r2] = r1;</span><br><span class="line">                have[r1] += have[r2];</span><br><span class="line">                have[r2] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据数学排列组合的知识可知，结果要求无法相互到达的点对，即计算每所有 两两不同的连通图的节点数的乘积 的和，我们可以按照一个顺序遍历所有的连通图，并用 other 来统计未遍历的连通图的节点总数，那么对于每个遍历到的连通图，计算其节点数与当前未遍历到的连通图的节点数的乘积，并求和，即可以无重复的计算出所有无法到达的点对数。</span></span><br><span class="line">        <span class="type">int</span> other = n; <span class="comment">// 当前未遍历到的连通图的节点总数</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(have[i]) <span class="comment">// 如果 i 是一个连通图的根，have[i] 就是该连通图的节点个数</span></span><br><span class="line">            &#123;</span><br><span class="line">                other -= have[i];</span><br><span class="line">                rst += (<span class="number">1LL</span> * have[i] * other);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ；空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。<code>n</code> 为节点个数。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-3"><details class="folding-tag" ><summary> 操作后的最大异或和 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/maximum-xor-after-operations/">2317. 操作后的最大异或和</a></p><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。一次操作中，选择 <strong>任意</strong> 非负整数 <code>x</code> 和一个下标 <code>i</code> ，<strong>更新</strong> <code>nums[i]</code> 为 <code>nums[i] AND (nums[i] XOR x)</code> 。</p><p>注意，<code>AND</code> 是逐位与运算，<code>XOR</code> 是逐位异或运算。</p><p>请你执行 <strong>任意次</strong> 更新操作，并返回 <code>nums</code> 中所有元素 <strong>最大</strong> 逐位异或和。</p><div class="note info flat"><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 1e5</code></li><li><code>0 &lt;= nums[i] &lt;= 1e8</code></li></ul></div><div class="note primary flat"><p>示例一：</p><p>输入：nums = [3,2,4,6]<br>输出：7<br>解释：选择 x = 4 和 i = 3 进行操作，num[3] = 6 AND (6 XOR 4) = 6 AND 2 = 2 。<br>现在，nums = [3, 2, 4, 2] 且所有元素逐位异或得到 3 XOR 2 XOR 4 XOR 2 = 7 。<br>可知 7 是能得到的最大逐位异或和。<br>注意，其他操作可能也能得到逐位异或和 7 。</p></div><div class="note primary flat"><p>示例二：</p><p>输入：nums = [1,2,3,9,2]<br>输出：11<br>解释：执行 0 次操作。<br>所有元素的逐位异或和为 1 XOR 2 XOR 3 XOR 9 XOR 2 = 11 。<br>可知 11 是能得到的最大逐位异或和。</p></div>              </div>            </details><p>解决方案：</p><p>位运算 <s>(脑筋急转弯)</s> ：</p><p>根据位运算的特点，我们可以发现：</p><ul><li>对于一个已有的非负整数 <code>num</code> 和 <strong>任意一个</strong> 期望获得的非负整数 <code>target</code> ，我们都可以选择出一个非负整数 <code>x</code> ，使得 <code>num XOR x = target</code> 。</li><li>对于一个已有的非负整数 <code>num</code> ，对于 <code>num</code> 的二进制中 <strong>任意一个</strong> 为 <code>1</code> 的位 <code>idx</code>，我们都可以选择出一个非负整数 <code>x</code>，进行操作 <code>num = num AND x </code> 后， <code>num</code> 的二进制中第 <code>idx</code> 位的 <code>1</code> 变为 <code>0</code> ，而不改变 <code>num</code> 的二进制中其他位的值。</li></ul><p>所以对于题设给出的操作，相当于选出 <code>nums[i]</code> 中的某个元素 <code>num</code>，将 <code>num</code> 的二进制中的某个为 <code>1</code> 的位变为 <code>0</code>。而要使得 <code>nums</code> 中所有元素的异或和最大，只需要将所有元素的二进制排列出来，若某一位，有至少一个元素的二进制在该位为 <code>1</code>，则需要操作这些元素，使得该位为 <code>1</code> 的元素的个数为奇数，那么所有元素的异或和在该位即是 <code>1</code>，最终异或和最大。</p><p>对于二进制的第 <code>idx</code> 位，若存在某一个元素该位为 <code>1</code>，那么操作后最大的异或和在该位也为 <code>1</code> ，若所有元素的二进制在该位均为 <code>0</code>，那么最大异或和在该位为 <code>0</code>。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumXOR</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> have[<span class="number">27</span>]; <span class="comment">// have[i] 是否有元素的二进制在第 i 位为 1，初始时每一位都没有</span></span><br><span class="line">        <span class="built_in">memset</span>(have, <span class="number">0</span>, <span class="built_in">sizeof</span>(have));</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x) <span class="comment">// 遍历 x 的二进制位</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(x &amp; <span class="number">1</span>) <span class="comment">// 该位为 1</span></span><br><span class="line">                    have[i] = <span class="number">1</span>;</span><br><span class="line">                x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> rst = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算最大异或和</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">26</span>; i &gt; <span class="number">-1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            rst &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            rst += have[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>c</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(c \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ；空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span>，<code>c</code> 为二进制的位数，本题数字范围限定 <code>c</code> 为 <code>28</code> ，<code>n</code> 为 <code>nums</code> 的长度。</p><p>位运算优化：</p><p>更进一步，我们发现遍历所有元素的二进制，并记录出存在 <code>1</code> 的位这件事本身不就是 <strong>按位或</strong> 运算吗？所以我们只需要将所有元素按位或即可得出答案！</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumXOR</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rst = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)</span><br><span class="line">            rst |= num;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ；空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-4"><details class="folding-tag" ><summary> 不同骰子序列的数目 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/number-of-distinct-roll-sequences/">2318. 不同骰子序列的数目</a></p><p>给你一个整数 <code>n</code> 。你需要掷一个 6 面的骰子 <code>n</code> 次。请你在满足以下要求的前提下，求出 <strong>不同</strong> 骰子序列的数目：</p><ol><li>序列中任意 <strong>相邻</strong> 数字的 <strong>最大公约数</strong> 为 <code>1</code> 。</li><li>序列中 <strong>相等</strong> 的值之间，至少有 <code>2</code> 个其他值的数字。正式地，如果第 <code>i</code> 次掷骰子的值 <strong>等于</strong> 第 <code>j</code> 次的值，那么 <code>abs(i - j) &gt; 2</code> 。</li></ol><p>请你返回不同序列的 <strong>总数目</strong> 。由于答案可能很大，请你将答案对 <code>1e9 + 7</code> <strong>取余</strong> 后返回。</p><p>如果两个序列中至少有一个元素不同，那么它们被视为不同的序列。</p><div class="note info flat"><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 1e4</code></li></ul></div><div class="note primary flat"><p>示例一：</p><p>输入：n = 4<br>输出：184<br>解释：一些可行的序列为 (1, 2, 3, 4) ，(6, 1, 2, 3) ，(1, 2, 3, 1) 等等。<br>一些不可行的序列为 (1, 2, 1, 3) ，(1, 2, 3, 6) 。<br>(1, 2, 1, 3) 是不可行的，因为第一个和第三个骰子值相等且 abs(1 - 3) = 2 （下标从 1 开始表示）。<br>(1, 2, 3, 6) i是不可行的，因为 3 和 6 的最大公约数是 3 。<br>总共有 184 个不同的可行序列，所以我们返回 184 。</p></div><div class="note primary flat"><p>示例二：</p><p>输入：n = 2<br>输出：22<br>解释：一些可行的序列为 (1, 2) ，(2, 1) ，(3, 2) 。<br>一些不可行的序列为 (3, 6) ，(2, 4) ，因为最大公约数不为 1 。<br>总共有 22 个不同的可行序列，所以我们返回 22 。</p></div>              </div>            </details><p>解决方案：</p><p>动态规划：</p><p><code>dp[k][i][j]</code> 表示直到第 <code>k</code> 次投骰子，投到的是 <code>i</code>，且前一次投骰子投到的是 <code>j</code> 的序列数，且仅当 <code>i</code> 和 <code>j</code> 互质时才有意义</p><p>按照题意很容易可以得出：</p><ul><li><p>当 <code>k == 2</code> 时，在 <code>k = 1</code> 次投骰子结果确定的情况下，仅有一种可能 <s>(感觉在说废话)</s> 。 <code>dp[2][i][j] = 1</code> （<code>j</code> 与 <code>i</code> 互质）。</p></li><li><p>当 <code>k &gt; 2</code> 时，需要取出第 <code>k - 1</code> 次投骰子结果为 <code>j</code> 且第 <code>k - 2</code> 次投骰子结果与 <code>i</code> 不同是所有结果， <code>dp[k][i][j] = Σ(dp[k - 1][j][r])</code>，<code>r</code> 从 <code>1</code> 到 <code>6</code>，<code>i</code> 与 <code>j</code> 互质，<code>j</code> 与 <code>r</code> 互质，<code>i != r</code> 。</p></li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">distinctSequences</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i, j, k, r, MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="comment">// dp[k][i][j] 表示直到第 k 次投骰子，投到的是 i，且前一次投骰子投到的是 j 的序列数，且仅当 i 和 j 互质时才有意义</span></span><br><span class="line">        <span class="comment">// 当 k &gt; 2 时，dp[k][i][j] = Σ(dp[k - 1][j][r])，r 从 1 到 6，i 与 j 互质，j 与 r 互质，i != r</span></span><br><span class="line">        <span class="comment">// 当 k == 2 时，dp[2][i][j] = 1 （j 与 i 互质）</span></span><br><span class="line">        <span class="type">int</span> dp[n + <span class="number">1</span>][<span class="number">7</span>][<span class="number">7</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// hz[i] 表示和 i 互质的数</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; hz = &#123;</span><br><span class="line">            &#123;&#125;,</span><br><span class="line">            &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// k == 2 时特殊处理</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">7</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j : hz[i]) <span class="comment">// j 必须和 i 互质</span></span><br><span class="line">                dp[<span class="number">2</span>][i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">3</span>; k &lt;= n; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">7</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> j : hz[i]) <span class="comment">// j 必须和 i 互质</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> r : hz[j]) <span class="comment">// r 必须和 j 互质</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(i == r) <span class="comment">// r 不能和 i 相同</span></span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        dp[k][i][j] = (dp[k][i][j] + dp[k - <span class="number">1</span>][j][r]) % MOD;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rst = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">7</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j : hz[i])</span><br><span class="line">                rst = (rst + dp[n][i][j]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><msup><mi>c</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times c^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ； 空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><msup><mi>c</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times c^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。其中 <code>c</code> 表示骰子点数范围，本题为 <code>6</code>。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode周赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 题解 </tag>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录 LeetCode 第 298 场周赛</title>
      <link href="/2022/LC-WeeklyContext-298/"/>
      <url>/2022/LC-WeeklyContext-298/</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p><a href="https://leetcode.cn/contest/weekly-contest-298/">本次周赛</a>依旧只写出前三题，第四题到饭点了。<s>（在家里，不吃饭要被线下gank）</s>。</p></div><h2 id="战局详情-6">战局详情</h2><table><thead><tr><th>排名</th><th>用户名</th><th>得分</th><th>完成时间</th><th>题目1（3）</th><th>题目2（4）</th><th>题目3（5）</th><th>题目4（6）</th></tr></thead><tbody><tr><td>844 / 6228</td><td>Juruoer</td><td>12</td><td>1:07:07</td><td>0:10:16</td><td>0:27:01 <i class="fa-solid fa-bug"></i> 1</td><td>1:02:07</td><td></td></tr></tbody></table><h2 id="题目及解答-7">题目及解答</h2><div class="tabs" id="problems"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#problems-1">题目1</button></li><li class="tab"><button type="button" data-href="#problems-2">题目2</button></li><li class="tab"><button type="button" data-href="#problems-3">题目3</button></li><li class="tab"><button type="button" data-href="#problems-4">题目4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="problems-1"><details class="folding-tag" ><summary> 兼具大小写的最好英文字母 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/greatest-english-letter-in-upper-and-lower-case/">5242. 兼具大小写的最好英文字母</a></p><p>给你一个由英文字母组成的字符串 <code>s</code> ，请你找出并返回 <code>s</code> 中的 <strong>最好</strong> 英文字母。返回的字母必须为大写形式。如果不存在满足条件的字母，则返回一个空字符串。</p><p><strong>最好</strong> 英文字母的大写和小写形式必须 <strong>都</strong> 在 <code>s</code> 中出现。</p><p>英文字母 <code>b</code> 比另一个英文字母 <code>a</code> <strong>更好</strong> 的前提是：英文字母表中，<code>b</code> 在 <code>a</code> 之 <strong>后</strong> 出现。</p><div class="note info flat"><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 由小写和大写英文字母组成</li></ul></div><div class="note primary flat"><p>示例一：</p><p>输入：s = “lEeTcOdE”<br>输出：“E”<br>解释：<br>字母 ‘E’ 是唯一一个大写和小写形式都出现的字母。</p></div><div class="note primary flat"><p>示例二：</p><p>输入：s = “arRAzFif”<br>输出：“R”<br>解释：<br>字母 ‘R’ 是大写和小写形式都出现的最好英文字母。<br>注意 ‘A’ 和 ‘F’ 的大写和小写形式也都出现了，但是 ‘R’ 比 ‘F’ 和 ‘A’ 更好。</p></div><div class="note primary flat"><p>示例三：</p><p>输入：s = “AbCdEfGhIjK”<br>输出：“”<br>解释：<br>不存在大写和小写形式都出现的字母。</p></div>              </div>            </details><p>解决方案：</p><p>模拟：</p><p>按题意模拟即可。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">greatestLetter</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">char</span> rst = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">char</span> t;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; theSet; <span class="comment">// 记录已经出现过的字母</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s)</span><br><span class="line">        &#123;</span><br><span class="line">            t = <span class="built_in">isupper</span>(c) ? (c + <span class="number">32</span>) : (c - <span class="number">32</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(theSet.<span class="built_in">count</span>(t)) <span class="comment">// 大小写都存在</span></span><br><span class="line">                rst = <span class="built_in">max</span>(rst, (<span class="built_in">isupper</span>(c) ? c : t));</span><br><span class="line">            </span><br><span class="line">            theSet.<span class="built_in">emplace</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rst == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        string r;</span><br><span class="line">        r.<span class="built_in">push_back</span>(rst);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ；空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span> 。其中 <code>n</code>  为 <code>s</code> 的长度，<code>c</code> 为字符的种类数，本题字符仅有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>26</mn><mo>×</mo><mn>2</mn><mo>=</mo><mn>52</mn></mrow><annotation encoding="application/x-tex">26 \times 2 = 52</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">26</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">52</span></span></span></span> 种。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-2"><details class="folding-tag" ><summary> 个位数字为 K 的整数之和 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/sum-of-numbers-with-units-digit-k/">5218. 个位数字为 K 的整数之和</a></p><p>给你两个整数 <code>num</code> 和 <code>k</code> ，考虑具有以下属性的正整数多重集：</p><ul><li>每个整数个位数字都是 <code>k</code> 。</li><li>所有整数之和是 <code>num</code> 。</li></ul><p>返回该多重集的最小大小，如果不存在这样的多重集，返回 <code>-1</code> 。</p><p>注意：</p><ul><li>多重集与集合类似，但多重集可以包含多个同一整数，空多重集的和为 0 。</li><li><strong>个位数字</strong> 是数字最右边的数位。</li></ul><div class="note info flat"><p>提示：</p><ul><li><code>0 &lt;= num &lt;= 3000</code></li><li><code>0 &lt;= k &lt;= 9</code></li></ul></div><div class="note primary flat"><p>示例一：</p><p>输入：num = 58, k = 9<br>输出：2<br>解释：<br>多重集 [9,49] 满足题目条件，和为 58 且每个整数的个位数字是 9 。<br>另一个满足条件的多重集是 [19,39] 。<br>可以证明 2 是满足题目条件的多重集的最小长度。</p></div><div class="note primary flat"><p>示例二：</p><p>输入：num = 37, k = 2<br>输出：-1<br>解释：个位数字为 2 的整数无法相加得到 37 。</p></div><div class="note primary flat"><p>示例三：</p><p>输入：num = 0, k = 7<br>输出：0<br>解释：空多重集的和为 0 。</p></div>              </div>            </details><p>解决方案：</p><p>枚举：</p><p>由题意可知，若存在这样的多重集，则 <code>num = (a1 * 10 + k) + (a2 * 10 + k) + ... + (an * 10 + k) = p * 10 + nk</code>，<code>n</code> 即 该多重集的大小。</p><p>那么只需要枚举<code>n</code>，找到第一个满足 <code>(num - n * k) % 10 == 0</code> 的 <code>n</code>，即最小的多重集大小。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumNumbers</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 三个特判</span></span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; num)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (num % <span class="number">10</span> == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 枚举 n</span></span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num -= k;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">10</span> == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">            ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不存在 n</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo>÷</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(num \div k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> ；空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-3"><details class="folding-tag" ><summary> 小于等于 K 的最长二进制子序列 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/longest-binary-subsequence-less-than-or-equal-to-k/">6099. 小于等于 K 的最长二进制子序列</a></p><p>给你一个二进制字符串 <code>s</code> 和一个正整数 <code>k</code> 。</p><p>请你返回 <code>s</code> 的 <strong>最长</strong> 子序列，且该子序列对应的 <strong>二进制</strong> 数字小于等于 <code>k</code> 。</p><p>注意：</p><ul><li>子序列可以有 <strong>前导</strong> <code>0</code> 。</li><li>空字符串视为 <code>0</code> 。</li><li><strong>子序列</strong> 是指从一个字符串中删除零个或者多个字符后，不改变顺序得到的剩余字符序列。</li></ul><div class="note info flat"><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s[i]</code> 要么是 <code>'0'</code> ，要么是 <code>'1'</code> 。</li><li><code>1 &lt;= k &lt;= 1e9</code></li></ul></div><div class="note primary flat"><p>示例一：</p><p>输入：s = “1001010”, k = 5<br>输出：5<br>解释：s 中小于等于 5 的最长子序列是 “00010” ，对应的十进制数字是 2 。<br>注意 “00100” 和 “00101” 也是可行的最长子序列，十进制分别对应 4 和 5 。<br>最长子序列的长度为 5 ，所以返回 5 。</p></div><div class="note primary flat"><p>示例二：</p><p>输入：s = “00101001”, k = 1<br>输出：6<br>解释：“000001” 是 s 中小于等于 1 的最长子序列，对应的十进制数字是 1 。<br>最长子序列的长度为 6 ，所以返回 6 。</p></div>              </div>            </details><p>解决方案：</p><p>一、贪心</p><p>从左到右遍历 <code>s</code> ，对于 <code>s</code> 的每一个字符，我们都将他放入二进制中，如果该二进制大于 <code>k</code>，由于 <code>k &gt;= 1</code> ，故 <code>s</code> 中一定存在 <code>1</code>，我们将第一个 <code>1</code> 从二进制中去除掉。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSubsequence</span><span class="params">(string s, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> rst = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>; <span class="comment">// 当前子字符串的十进制值</span></span><br><span class="line">        <span class="type">int</span> OneIdx = <span class="number">-1</span>; <span class="comment">// num 的二进制中第一个 1 的位置（自右往左）</span></span><br><span class="line">        <span class="type">int</span> _num;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s)</span><br><span class="line">        &#123;</span><br><span class="line">            t = (num &lt;&lt; <span class="number">1</span>) + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(t &gt; k) <span class="comment">// 前面一定有 1，去除第一个 1，子字符串增加一位再去除一位，长度不变</span></span><br><span class="line">            &#123;</span><br><span class="line">                num = ((num - (<span class="number">1</span> &lt;&lt; OneIdx)) &lt;&lt; <span class="number">1</span>) + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="comment">// 重新计算 OneIdx 的值</span></span><br><span class="line">                <span class="keyword">if</span>(num == <span class="number">0</span>)</span><br><span class="line">                    OneIdx = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    _num = num;</span><br><span class="line">                    OneIdx = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">while</span>(_num)</span><br><span class="line">                    &#123;</span><br><span class="line">                        _num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">                        ++OneIdx;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 子字符串长度加 1，第一个 1 的位置加 1</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++rst;</span><br><span class="line">                num = t;</span><br><span class="line">                <span class="keyword">if</span>(num != <span class="number">0</span>)</span><br><span class="line">                    ++OneIdx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> ；空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。其中 <code>m</code> 为 <code>k</code> 的二进制长度（首位为 <code>1</code>），<code>n</code> 为 <code>s</code> 的长度。</p><p>二、贪心 + 分类讨论</p><p>我们仔细观察方法一，发现方法一得出的子字符串一定包含 <code>s</code> 中的所有 <code>0</code>，所以只需要从 <code>s</code> 中找到二进制小于等于 <code>k</code> 的最长后缀，该后缀的长度加上 <code>s</code> 中除去该后缀的部分的所有 <code>0</code> 的个数即所求。</p><p>另外我们发现这个最长后缀若长度大于 <code>k</code> 的二进制的长度，则多出的高位必然为前导 <code>0</code>，所以我们只需要比较 <code>s</code> 的和 <code>k</code> 的二进制长度相同的后缀与 <code>k</code> 的关系即可。</p><p>设 <code>s</code> 的长度为 <code>n</code>，<code>k</code> 的二进制（首位为 <code>1</code>）的长度为 <code>m</code>。</p><ul><li>若 <code>n &lt;= m</code> ，则 <code>s</code> 的所有后缀的二进制均小于等于 <code>k</code>，返回 n。</li><li>若 <code>n &gt; m</code>，且 <code>s</code> 的长为 <code>m</code> 的后缀的二进制小于等于 <code>k</code>，返回 <code>s</code> 中除去长为 <code>m</code> 的后的部分的 <code>0</code> 的个数 + <code>m</code> 。</li><li>若 <code>n &gt; m</code>，且 <code>s</code> 的成为 <code>m</code> 的后缀的二进制大于 <code>k</code>，说明 <code>s</code> 的长为 <code>m</code> 的后缀以 <code>'1'</code> 开头，又 <code>s</code> 的长为 <code>m - 1</code> 的后缀的二进制必小于 <code>k</code>，故返回 <code>s</code> 中除去长为 <code>m</code> 的后的部分的 <code>0</code> 的个数 + <code>m  - 1</code>。</li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSubsequence</span><span class="params">(string s, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> _k = k;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算 k 的二进制长度</span></span><br><span class="line">        <span class="keyword">while</span>(_k)</span><br><span class="line">        &#123;</span><br><span class="line">            _k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            ++m;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n &lt;= m)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// s 的长度为 m 的后缀为 s[n - m] ~ s[n - 1]</span></span><br><span class="line">        <span class="type">int</span> zCont = <span class="built_in">count</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">begin</span>() + (n - m), <span class="string">&#x27;0&#x27;</span>); <span class="comment">// s 除去长度为 m 的后缀的部分的 0 的个数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s[n - m] != <span class="string">&#x27;1&#x27;</span>) <span class="comment">// 该后缀的二进制必然小于 k</span></span><br><span class="line">            <span class="keyword">return</span> zCont + m;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i, num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = n - m; i &lt; n; ++i)</span><br><span class="line">            num = (num &lt;&lt; <span class="number">1</span>) + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num &gt; k ? (zCont + m - <span class="number">1</span>) : (zCont + m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> ；空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。其中 <code>m</code> 为 <code>k</code> 的二进制长度（首位为 <code>1</code>），<code>n</code> 为 <code>s</code> 的长度。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-4"><details class="folding-tag" ><summary> 卖木头块 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/selling-pieces-of-wood/">5254. 卖木头块</a></p><p>给你两个整数 <code>m</code> 和 <code>n</code> ，分别表示一块矩形木块的高和宽。同时给你一个二维整数数组 <code>prices</code> ，其中 <code>prices[i] = [hi, wi, pricei]</code> 表示你可以以 <code>pricei</code> 元的价格卖一块高为 <code>hi</code> 宽为 <code>wi</code> 的矩形木块。</p><p>每一次操作中，你必须按下述方式之一执行切割操作，以得到两块更小的矩形木块：</p><ul><li>沿垂直方向按高度 <strong>完全</strong> 切割木块，或</li><li>沿水平方向按宽度 <strong>完全</strong> 切割木块</li></ul><p>在将一块木块切成若干小木块后，你可以根据 <code>prices</code> 卖木块。你可以卖多块同样尺寸的木块。你不需要将所有小木块都卖出去。你 <strong>不能</strong> 旋转切好后木块的高和宽。</p><p>请你返回切割一块大小为 <code>m x n</code> 的木块后，能得到的 <strong>最多</strong> 钱数。</p><p>注意你可以切割木块任意次。</p><div class="note info flat"><p>提示：</p><ul><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>1 &lt;= prices.length &lt;= 2 * 1e4</code></li><li><code>prices[i].length == 3</code></li><li><code>1 &lt;= hi &lt;= m</code></li><li><code>1 &lt;= wi &lt;= n</code></li><li><code>1 &lt;= pricei &lt;= 1e6</code></li><li>所有 <code>(hi, wi)</code> 互不相同 。</li></ul></div><div class="note primary flat"><p>示例一：</p><img src = "https://assets.leetcode.com/uploads/2022/04/27/ex1.png" alt = "示例一图" ><p>输入：m = 3, n = 5, prices = [[1,4,2],[2,2,7],[2,1,3]]<br>输出：19<br>解释：上图展示了一个可行的方案。包括：</p><ul><li>2 块 2 x 2 的小木块，售出 2 * 7 = 14 元。</li><li>1 块 2 x 1 的小木块，售出 1 * 3 = 3 元。</li><li>1 块 1 x 4 的小木块，售出 1 * 2 = 2 元。</li></ul><p>总共售出 14 + 3 + 2 = 19 元。<br>19 元是最多能得到的钱数。</p></div><div class="note primary flat"><p>示例二：</p><img src = "https://assets.leetcode.com/uploads/2022/04/27/ex2new.png" alt = "示例二图" ><p>输入：m = 4, n = 6, prices = [[3,2,10],[1,4,2],[4,1,3]]<br>输出：32<br>解释：上图展示了一个可行的方案。包括：</p><ul><li>3 块 3 x 2 的小木块，售出 3 * 10 = 30 元。</li><li>1 块 1 x 4 的小木块，售出 1 * 2 = 2 元。</li></ul><p>总共售出 30 + 2 = 32 元。<br>32 元是最多能得到的钱数。<br>注意我们不能旋转 1 x 4 的木块来得到 4 x 1 的木块。</p></div>              </div>            </details><p>解决方案：</p><p>动态规划：</p><p>对于高度为 <code>i</code> 宽度为 <code>j</code> 的木块，假设其最多能卖出的价格为 <code>dp[i][j]</code>，我们可以将其分割为</p><ul><li>高度为 <code>i</code>  ，宽度分别为 <code>k</code> 和 <code>j - k</code> 的两块，其中 <code>k</code> 大于 <code>0</code> 且 小于 <code>j</code>，或是</li><li>宽度为 <code>j</code> ， 高度分别为 <code>k</code> 和 <code>i - k</code> 的两块，其中 <code>k</code> 大于 <code>0</code> 且 小于 <code>i</code>。</li></ul><p>故 <code>dp[i][j] = max(max(dp[i][k] + dp[i][j - k]), max(dp[k][j] + dp[i - k][j]))</code>。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">sellingWood</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;prices)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> dp[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基础状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : prices)</span><br><span class="line">            dp[x[<span class="number">0</span>]][x[<span class="number">1</span>]] = x[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i, j, k;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 计算 高度为 i 宽度为 j 的木块发最佳分割方法</span></span><br><span class="line">                <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt; j; ++k) <span class="comment">// 分割成 高度为 i 宽度分别为 k 和 j - k 的两块</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i][k] + dp[i][j - k]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt; i; ++k) <span class="comment">// 分割成 宽度为 j 高度分别为 k 和 i - k 的两块</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[k][j] + dp[i - k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>c</mi><mo>+</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></msubsup><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>j</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>c</mi><mo>+</mo><mfrac><mrow><mi>m</mi><mo>×</mo><mi>n</mi><mo>×</mo><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>c</mi><mo>+</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo>×</mo><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(c + \sum_{i = 1} ^ m(i + \sum_{j = 1} ^ n j)) = O(c + \frac{m \times n \times (2 + m + n)} {2}) = O(c + m \times n \times(m + n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.104em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2401em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">×</span><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">m</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">n</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span> ；空间复杂度： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。其中 <code>c</code> 为 <code>prices</code> 的长度。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode周赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 题解 </tag>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录 LeetCode 第 297 场周赛</title>
      <link href="/2022/LC-WeeklyContext-297/"/>
      <url>/2022/LC-WeeklyContext-297/</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>非常遗憾，<a href="https://leetcode.cn/contest/weekly-contest-297/">本次周赛</a>仅写出前两题。</p></div><h2 id="战局详情-5">战局详情</h2><table><thead><tr><th>排名</th><th>用户名</th><th>得分</th><th>完成时间</th><th>题目1（3）</th><th>题目2（5）</th><th>题目3（5）</th><th>题目4（6）</th></tr></thead><tbody><tr><td>1553 / 5915</td><td>Juruoer</td><td>8</td><td>0:32:12</td><td>0:12:35</td><td>0:32:12</td><td></td><td></td></tr></tbody></table><h2 id="题目及解答-6">题目及解答</h2><div class="tabs" id="problems"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#problems-1">题目1</button></li><li class="tab"><button type="button" data-href="#problems-2">题目2</button></li><li class="tab"><button type="button" data-href="#problems-3">题目3</button></li><li class="tab"><button type="button" data-href="#problems-4">题目4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="problems-1"><details class="folding-tag" ><summary> 计算应缴税款总额 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/calculate-amount-paid-in-taxes/">5259. 计算应缴税款总额</a></p><p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>brackets</code> ，其中 <code>brackets[i] = [upperi, percenti]</code> ，表示第 <code>i</code> 个税级的上限是 <code>upperi</code> ，征收的税率为 <code>percenti</code> 。税级按上限 <strong>从低到高排序</strong>（在满足 <code>0 &lt; i &lt; brackets.length</code> 的前提下，<code>upperi-1 &lt; upperi</code> ）。</p><p>税款计算方式如下：</p><ul><li>不超过 <code>upper0</code> 的收入按税率 <code>percent0</code> 缴纳</li><li>接着 <code>upper1 - upper0</code> 的部分按税率 <code>percent1</code> 缴纳</li><li>然后 <code>upper2 - upper1</code> 的部分按税率 <code>percent2</code> 缴纳</li><li>以此类推</li></ul><p>给你一个整数 <code>income</code> 表示你的总收入。返回你需要缴纳的税款总额。与标准答案误差不超 <code>1e-5</code> 的结果将被视作正确答案。</p><div class="note info flat"><p>提示：</p><ul><li><code>1 &lt;= brackets.length &lt;= 100</code></li><li><code>1 &lt;= upperi &lt;= 1000</code></li><li><code>0 &lt;= percenti &lt;= 100</code></li><li><code>0 &lt;= income &lt;= 1000</code></li><li><code>upperi</code> 按递增顺序排列</li><li><code>upperi</code> 中的所有值 <strong>互不相同</strong></li><li>最后一个税级的上限大于等于 <code>income</code></li></ul></div><div class="note primary flat"><p>示例一：</p><p>输入：brackets = [[3,50],[7,10],[12,25]], income = 10<br>输出：2.65000<br>解释：<br>前 $3 的税率为 50% 。需要支付税款 $3 * 50% = $1.50 。<br>接下来 $7 - $3 = $4 的税率为 10% 。需要支付税款 $4 * 10% = $0.40 。<br>最后 $10 - $7 = $3 的税率为 25% 。需要支付税款 $3 * 25% = $0.75 。<br>需要支付的税款总计 $1.50 + $0.40 + $0.75 = $2.65 。</p></div><div class="note primary flat"><p>示例二：</p><p>输入：brackets = [[1,0],[4,25],[5,50]], income = 2<br>输出：0.25000<br>解释：<br>前 $1 的税率为 0% 。需要支付税款 $1 * 0% = $0 。<br>剩下 $1 的税率为 25% 。需要支付税款 $1 * 25% = $0.25 。<br>需要支付的税款总计 $0 + $0.25 = $0.25 。</p></div><div class="note primary flat"><p>示例三：</p><p>输入：brackets = [[2,50]], income = 0<br>输出：0.00000<br>解释：<br>没有收入，无需纳税，需要支付的税款总计 $0 。</p></div>              </div>            </details><p>解决方案：</p><p>模拟：</p><p>将 <code>income</code> 按照 <code>brackets</code> 分为若干份，并根据每份的税率计算相应的税收。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calculateTax</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;brackets, <span class="type">int</span> income)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">double</span> rst = <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> pre = <span class="number">0</span>; <span class="comment">// 之前的税率所覆盖的收入范围：[0, pre]。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; brackets.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 税率为 brackets[i][1] / 100 的收入范围为：[pre, min(brackets[i][0], income)]</span></span><br><span class="line">            rst += (<span class="built_in">min</span>(brackets[i][<span class="number">0</span>], income) - pre) * brackets[i][<span class="number">1</span>] / <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// 收入太少了，之后的税雨你无瓜(扎心)</span></span><br><span class="line">            <span class="keyword">if</span>(income &lt;= brackets[i][<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            pre = brackets[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ；空间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。其中 <code>n</code> 表示 <code>brackets</code> 的长度。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-2"><details class="folding-tag" ><summary> 网格中的最小路径代价 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/minimum-path-cost-in-a-grid/">5270. 网格中的最小路径代价</a></p><p>给你一个下标从 <strong>0</strong> 开始的整数矩阵 <code>grid</code> ，矩阵大小为 <code>m x n</code> ，由从 <code>0</code> 到 <code>m * n - 1</code> 的不同整数组成。你可以在此矩阵中，从一个单元格移动到 <strong>下一行</strong> 的任何其他单元格。如果你位于单元格 <code>(x, y)</code> ，且满足 <code>x &lt; m - 1</code> ，你可以移动到 <code>(x + 1, 0), (x + 1, 1), ..., (x + 1, n - 1)</code> 中的任何一个单元格。注意： 在最后一行中的单元格不能触发移动。</p><p>每次可能的移动都需要付出对应的代价，代价用一个下标从 <strong>0</strong> 开始的二维数组 <code>moveCost</code> 表示，该数组大小为 <code>(m * n) x n</code> ，其中 <code>moveCost[i][j]</code> 是从值为 <code>i</code> 的单元格移动到下一行第 <code>j</code> 列单元格的代价。从 <code>grid</code> 最后一行的单元格移动的代价可以忽略。</p><p><code>grid</code> 一条路径的代价是：所有路径经过的单元格的 <strong>值之和</strong> 加上所有移动的 <strong>代价之和</strong> 。从 <strong>第一行</strong> 任意单元格出发，返回到达 <strong>最后一行</strong> 任意单元格的最小路径代价。</p><div class="note info flat"><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>2 &lt;= m, n &lt;= 50</code></li><li><code>grid</code> 由从 <code>0</code> 到 <code>m * n - 1</code> 的不同整数组成</li><li><code>moveCost.length == m * n</code></li><li><code>moveCost[i].length == n</code></li><li><code>1 &lt;= moveCost[i][j] &lt;= 100</code></li></ul></div><div class="note primary flat"><p>示例一：</p><img src = "https://assets.leetcode.com/uploads/2022/04/28/griddrawio-2.png" alt = "示例一图"><p>输入：grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]<br>输出：17<br>解释：最小代价的路径是 5 -&gt; 0 -&gt; 1 。</p><ul><li>路径途经单元格值之和 5 + 0 + 1 = 6 。</li><li>从 5 移动到 0 的代价为 3 。</li><li>从 0 移动到 1 的代价为 8 。</li></ul><p>路径总代价为 6 + 3 + 8 = 17 。</p></div><div class="note primary flat"><p>示例二：</p><p>输入：grid = [[5,1,2],[4,0,3]], moveCost = [[12,10,15],[20,23,8],[21,7,1],[8,1,13],[9,10,25],[5,3,2]]<br>输出：6<br>解释：<br>最小代价的路径是 2 -&gt; 3 。</p><ul><li>路径途经单元格值之和 2 + 3 = 5 。</li><li>从 2 移动到 3 的代价为 1 。</li></ul><p>路径总代价为 5 + 1 = 6 。</p></div>              </div>            </details><p>解决方案：</p><p>动态规划：</p><p>若 <code>grid</code> 有 <code>m</code> 行 <code>n</code> 列。</p><p>设 <code>dp[i][j]</code> 表示第 <code>i</code> 行第 <code>j</code> 列的元素到达最后一行的最小路径代价，则：</p><p><code>dp[i][j] = grid[i][j] + min(dp[i + 1][k] + moveCost[grid[i][j]][k])</code> ，其中 <code>k</code> 由 <code>0</code> 到 <code>n - 1</code> ；</p><p><code>dp[m - 1][j] = grid[m - 1][j]</code> 。</p><p>我们可以直接使用 <code>grid</code> 来代替 <code>dp</code>。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathCost</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;moveCost)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i, j, k;</span><br><span class="line">        <span class="type">int</span> cost;</span><br><span class="line">        <span class="comment">// 由倒数第二行计算到第一行，最后一行已经保存在 grid 中了</span></span><br><span class="line">        <span class="keyword">for</span> (i = m - <span class="number">2</span>; i &gt; <span class="number">-1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 计算第 i 行第 j 列的元素到达最后一行的最小路径代价</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                cost = <span class="number">0x7fffffff</span>;</span><br><span class="line">                <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 由 grid[i][j] 移动到 grid[i + 1][k]</span></span><br><span class="line">                    cost = <span class="built_in">min</span>(cost, grid[i + <span class="number">1</span>][k] + moveCost[grid[i][j]][k]);</span><br><span class="line">                &#125;</span><br><span class="line">                grid[i][j] += cost;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最小代价</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">min_element</span>(grid.<span class="built_in">at</span>(<span class="number">0</span>).<span class="built_in">begin</span>(), grid.<span class="built_in">at</span>(<span class="number">0</span>).<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m \times n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ；空间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。其中 <code>m</code> 、<code>n</code> 分别为 <code>grid</code> 的行数和列数。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-3"><details class="folding-tag" ><summary> 公平分发饼干 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/fair-distribution-of-cookies/">5289. 公平分发饼干</a></p><p>给你一个整数数组 <code>cookies</code> ，其中 <code>cookies[i]</code> 表示在第 <code>i</code> 个零食包中的饼干数量。另给你一个整数 <code>k</code> 表示等待分发零食包的孩子数量，<strong>所有</strong> 零食包都需要分发。在同一个零食包中的所有饼干都必须分发给同一个孩子，不能分开。</p><p>分发的 <strong>不公平程度</strong> 定义为单个孩子在分发过程中能够获得饼干的最大总数。</p><p>返回所有分发的最小不公平程度。</p><div class="note info flat"><p>提示：</p><ul><li><code>2 &lt;= cookies.length &lt;= 8</code></li><li><code>1 &lt;= cookies[i] &lt;= 1e5</code></li><li><code>2 &lt;= k &lt;= cookies.length</code></li></ul></div><div class="note primary flat"><p>示例一：</p><p>输入：cookies = [8,15,10,20,8], k = 2<br>输出：31<br>解释：一种最优方案是 [8,15,8] 和 [10,20] 。</p><ul><li>第 1 个孩子分到 [8,15,8] ，总计 8 + 15 + 8 = 31 块饼干。</li><li>第 2 个孩子分到 [10,20] ，总计 10 + 20 = 30 块饼干。</li></ul><p>分发的不公平程度为 max(31,30) = 31 。<br>可以证明不存在不公平程度小于 31 的分发方案。</p></div><div class="note primary flat"><p>示例二：</p><p>输入：cookies = [6,1,3,2,2,4,1,2], k = 3<br>输出：7<br>解释：一种最优方案是 [6,1]、[3,2,2] 和 [4,1,2] 。</p><ul><li>第 1 个孩子分到 [6,1] ，总计 6 + 1 = 7 块饼干。</li><li>第 2 个孩子分到 [3,2,2] ，总计 3 + 2 + 2 = 7 块饼干。</li><li>第 3 个孩子分到 [4,1,2] ，总计 4 + 1 + 2 = 7 块饼干。</li></ul><p>分发的不公平程度为 max(7,7,7) = 7 。<br>可以证明不存在不公平程度小于 7 的分发方案。</p></div>              </div>            </details><p>解决方案：</p><p>一、回溯 + 枝剪：</p><p>利用递归计算所有的零食分发方式，并计算出最小的不公平程度。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// have[i] 表示第 i 个小朋友获得的零食数</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cooks, have;</span><br><span class="line">    <span class="type">int</span> n, c, rst, idx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// idx 表示分发到第 idx 包零食</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx == n) <span class="comment">// 零食分发完了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 计算所有小朋友获得的零食数的最大值（即此情况下的不公平程度），与 rst 比较</span></span><br><span class="line">            rst = <span class="built_in">min</span>(rst, *<span class="built_in">max_element</span>(have.<span class="built_in">begin</span>(), have.<span class="built_in">end</span>()));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; c; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将第 idx 包零食分给第 i 个小朋友</span></span><br><span class="line">            have[i] += cooks[idx];</span><br><span class="line">            <span class="keyword">if</span>(have[i] &lt; rst) <span class="comment">// 枝剪，若这个小朋友的零食已经比之前的分配方法得出的不公平程度大，则不需要继续计算了</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++idx;</span><br><span class="line">                <span class="built_in">dfs</span>();</span><br><span class="line">                --idx;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再给他拿回来(have 是所有递归共用的)</span></span><br><span class="line">            have[i] -= cooks[idx];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">distributeCookies</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;cookies, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cooks = cookies;</span><br><span class="line">        n = cookies.<span class="built_in">size</span>();</span><br><span class="line">        c = k;</span><br><span class="line">        rst = <span class="number">0x7fffffff</span>;</span><br><span class="line">        have.<span class="built_in">resize</span>(k, <span class="number">0</span>);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>();</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所有零食的分发方法共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>k</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">k ^ n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 种，递归总次数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>k</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">k ^ n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>。故时间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>k</mi><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ； 空间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><msup><mi>k</mi><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + k ^ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。其中 <code>n</code> 表示零食的包数，<code>k</code> 表示小朋友的数量。其实枝剪后时间复杂度和空间复杂度远远低于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>k</mi><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k ^ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><p>二、动态规划 + 状态压缩：</p><p>因为最多有 <code>8</code> 包零食，故可以将零食的组合状态压缩为：零食集合 <code>k</code> ，其含义为： <code>k</code> 的二进制中若第 <code>idx</code> 位（自右向左，自 <code>0</code> 开始）为 <code>1</code>，则表示第 <code>idx</code> 包零食属于该零食集合。易知一共有 <code>1 &lt;&lt; n</code> 种零食集合。</p><p>设 <code>dp[i][j]</code> 表示前 <code>i</code> 个小朋友分得的零食集合为 <code>j</code> 时的最小不公平程度。</p><p>则 <code>dp[i][j] = min(max(dp[i - 1][j \ s], sum[s]))</code>，其中，<code>s</code> 表示第 <code>i</code> 位小朋友获得的零食集合，且 <code>s</code> 必须为 <code>j</code> 的子集，<code>j \ s</code> 表示集合 <code>j</code> 去除集合 <code>s</code> 的集合，<code>sum[s]</code> 表示集合 <code>s</code> 的零食数量之和。</p><p>因为 <code>s</code> 为 <code>j</code> 的子集，故 <code>j \ s</code> = <code>j ^ s</code> ， 另外，可以发现 <code>sum[s] = dp[0][s]</code>。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">distributeCookies</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;cookies, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = cookies.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> N = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">        <span class="comment">// 对于零食集合 k，k 的二进制中若第 idx 位（自右向左，自 0 开始）为 1，则表示第 idx 包零食属于该零食集合。</span></span><br><span class="line">        <span class="comment">// dp[i][j] 表示前 i 个小朋友分得的零食集合为 j 时的最小不公平程度。</span></span><br><span class="line">        <span class="comment">// dp[i][j] = min(max(dp[i - 1][j \ s], sum[s]))，s 表示第 i 位小朋友获得的零食集合，且 s 必须为 j 的子集，j \ s 表示集合 j 去除集合 s 的集合，sum[s] 表示集合 s 的零食数量之和。</span></span><br><span class="line">        <span class="comment">// 因为 s 为 j 的子集，故 j \ s = j ^ s, 另外，可以发现 sum[s] = dp[0][s]。</span></span><br><span class="line">        <span class="comment">// 可知一共有 1 &lt;&lt; n 种零食集合</span></span><br><span class="line">        <span class="type">int</span> dp[k][N];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0x7f</span>, <span class="built_in">sizeof</span>(dp)); <span class="comment">// 初始化 dp 每个元素为 0x7f7f7f7f &gt; 8 * 10^5</span></span><br><span class="line">        <span class="type">int</span> i, j, s;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 只有一位小朋友时的情况 dp[0][j]，也即 sum[j]</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 遍历所有零食</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 若该零食属于集合 j</span></span><br><span class="line">                <span class="keyword">if</span>(j &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">                    dp[<span class="number">0</span>][j] += cookies[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算有 i + 1 位小朋友时的情况</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 对于集合 j</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; N; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 若 s 为 j 的子集，则 s &lt;= j</span></span><br><span class="line">                <span class="keyword">for</span> (s = <span class="number">0</span>; s &lt;= j; ++s)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 当 s 为 j 的子集时，尝试更新 dp[i][j]</span></span><br><span class="line">                    <span class="keyword">if</span>(s | j &lt;= j)</span><br><span class="line">                        dp[i][j] = <span class="built_in">min</span>(dp[i][j], <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j ^ s], dp[<span class="number">0</span>][s]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k - <span class="number">1</span>][N - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><msup><mn>2</mn><mi>n</mi></msup><mo>+</mo><mi>k</mi><mo>×</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><msup><mn>2</mn><mi>n</mi></msup></msubsup><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><msup><mn>2</mn><mi>n</mi></msup><mo>+</mo><msup><mn>4</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times 2 ^ n + k \times \sum_{i = 1} ^{2 ^ n} i) = O(n \times 2 ^ n + 4 ^ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.3196em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0199em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7385em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ；空间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo>×</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k \times 2 ^ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。其中 <code>n</code> 表示零食的包数，<code>k</code> 表示小朋友的个数。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-4"><details class="folding-tag" ><summary> 公司命名 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/naming-a-company/">6094. 公司命名</a></p><p>给你一个字符串数组 <code>ideas</code> 表示在公司命名过程中使用的名字列表。公司命名流程如下：</p><ul><li>从 <code>ideas</code> 中选择 <code>2</code> 个 <strong>不同</strong> 名字，称为 <code>ideaA</code> 和 <code>ideaB</code> 。</li><li>交换 <code>ideaA</code> 和 <code>ideaB</code> 的首字母。</li><li>如果得到的两个新名字 <strong>都</strong> 不在 <code>ideas</code> 中，那么 <code>ideaA ideaB</code>（串联 <code>ideaA</code> 和 <code>ideaB</code> ，中间用一个空格分隔）是一个有效的公司名字。</li><li>否则，不是一个有效的名字。</li></ul><p>返回 <strong>不同</strong> 且有效的公司名字的数目。</p><div class="note info flat"><p>提示：</p><ul><li><code>2 &lt;= ideas.length &lt;= 5 * 1e4</code></li><li><code>1 &lt;= ideas[i].length &lt;= 10</code></li><li><code>ideas[i]</code> 由小写英文字母组成</li><li><code>ideas</code> 中的所有字符串 <strong>互不相同</strong></li></ul></div><div class="note primary flat"><p>示例一：</p><p>输入：ideas = [“coffee”,“donuts”,“time”,“toffee”]<br>输出：6<br>解释：下面列出一些有效的选择方案：</p><ul><li>(“coffee”, “donuts”)：对应的公司名字是 “doffee conuts” 。</li><li>(“donuts”, “coffee”)：对应的公司名字是 “conuts doffee” 。</li><li>(“donuts”, “time”)：对应的公司名字是 “tonuts dime” 。</li><li>(“donuts”, “toffee”)：对应的公司名字是 “tonuts doffee” 。</li><li>(“time”, “donuts”)：对应的公司名字是 “dime tonuts” 。</li><li>(“toffee”, “donuts”)：对应的公司名字是 “doffee tonuts” 。<br>因此，总共有 6 个不同的公司名字。</li></ul><p>下面列出一些无效的选择方案：</p><ul><li>(“coffee”, “time”)：在原数组中存在交换后形成的名字 “toffee” 。</li><li>(“time”, “toffee”)：在原数组中存在交换后形成的两个名字。</li><li>(“coffee”, “toffee”)：在原数组中存在交换后形成的两个名字。</li></ul></div><div class="note primary flat"><p>示例二：</p><p>输入：ideas = [“lack”,“back”]<br>输出：0<br>解释：不存在有效的选择方案。因此，返回 0 。</p></div>              </div>            </details><p>解决方案：</p><p>哈希 + 枚举 + 分组：</p><p>对于每个被选出作为 <code>ideaA</code> 的字符串，若将其首字母（假设为 <code>c1</code>）变为 <code>c2</code> 后不存在于 <code>ideas</code> 中，则 <code>ideas</code> 中所有首字母为 <code>c2</code> 且将首字母变为 <code>c1</code> 后不存在于 <code>ideas</code> 中的所有字符串均是有效的 <code>ideaB</code>。</p><p>事实上，我们可以先计算出 <code>ideas</code> 中的所有字符串其改变首字母后是否存在于 <code>ideas</code> 中，且将首字母由相同字符转化为另一相同字符后不存在于 <code>ideas</code> 中的字符串作为一组，并统计各组的字符串个数，保存至 <code>cnts</code> 中，即：</p><p>设 <code>cnts[i][j]</code> 表示 <code>ideas</code> 中首字母为 <code>i + 'a'</code> 且将首字母变为 <code>j + 'a'</code> 时产生的新字符串不在 <code>ideas</code> 中的字符串个数。</p><p>那么对于所有的 <code>ideaA</code>，如果他的首字母（假设为 <code>to + 'a'</code>）变为 <code>j + 'a'</code>，那么合理的 <code>ideaB</code> 的个数为 <code>cnts[j][to]</code> 。</p><p>对于某个因为改变了首字母而得到的字符串，可以使用哈希表来更快的判断其是否存在于 <code>ideas</code> 中。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">distinctNames</span><span class="params">(vector&lt;string&gt; &amp;ideas)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 使用哈希表可以更快的比较出某个新字符串是否存在于 ideas 中</span></span><br><span class="line">        unordered_set&lt;string&gt; theSet;</span><br><span class="line">        <span class="type">int</span> i, j, n = ideas.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cnts[i][j] 表示 ideas 中首字母为 i + &#x27;a&#x27; 且 将首字母变为 j + &#x27;a&#x27; 时产生的新字符串不在 ideas 中的字符串个数</span></span><br><span class="line">        <span class="type">int</span> cnts[<span class="number">26</span>][<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// flag[i][j] == true 表示 ideas[i] 的首字母变为 j + &#x27;a&#x27; 时产生的新字符串不在 ideas 中</span></span><br><span class="line">        <span class="type">bool</span> flags[n][<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(cnts, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnts));</span><br><span class="line">        <span class="built_in">memset</span>(flags, <span class="literal">false</span>, <span class="built_in">sizeof</span>(flags));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(string &amp;idea : ideas)</span><br><span class="line">            theSet.<span class="built_in">emplace</span>(idea);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ori;</span><br><span class="line">        string temp;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = ideas[i];</span><br><span class="line">            ori = temp[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>; <span class="comment">// ideas[i] 原来的首字母</span></span><br><span class="line">            <span class="comment">// 遍历新的首字母</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 构建新字符串</span></span><br><span class="line">                temp[<span class="number">0</span>] = j + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="comment">// 若新字符串不存在于 ideas 中</span></span><br><span class="line">                <span class="keyword">if</span>(theSet.<span class="built_in">count</span>(temp) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    flags[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    ++cnts[ori][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> rst = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> to;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 ideaA</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            to = ideas[i][<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 若 ideaA 的首字母由 to + &#x27;a&#x27; 变为 j + &#x27;a&#x27; 后不存在于 ideas 中，则 ideas 中所有将首字母由 j + &#x27;a&#x27;变为 to + &#x27;a&#x27; 后不存在于 ideas 中的字符串即为有效的 ideaB，其个数为 cnts[j][to]</span></span><br><span class="line">                <span class="keyword">if</span>(flags[i][j])</span><br><span class="line">                    rst += cnts[j][to];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>c</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(c \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ；空间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>c</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(c \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。其中 <code>c</code> 表示字母的种类数，为 <code>26</code>，<code>n</code> 表示 <code>ideas</code> 的长度。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode周赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 题解 </tag>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录 LeetCode 第 80 场双周赛</title>
      <link href="/2022/LC-BiweeklyContext-80/"/>
      <url>/2022/LC-BiweeklyContext-80/</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p><a href="https://leetcode.cn/contest/biweekly-contest-80/">本次周赛</a>是参加 Leetcode 周赛以来第一次AK！心情非常激动！</p></div><h2 id="战局详情">战局详情</h2><table><thead><tr><th>排名</th><th>用户名</th><th>得分</th><th>完成时间</th><th>题目1（3）</th><th>题目2（4）</th><th>题目3（6）</th><th>题目4（6）</th></tr></thead><tbody><tr><td>734 / 3949</td><td>Juruoer</td><td>19</td><td>1:25:10</td><td>0:08:34 <i class="fa-solid fa-bug"></i> 1</td><td>0:21:50</td><td>1:20:10</td><td>0:57:41</td></tr></tbody></table><h2 id="题目及解答">题目及解答</h2><div class="tabs" id="problems"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#problems-1">题目1</button></li><li class="tab"><button type="button" data-href="#problems-2">题目2</button></li><li class="tab"><button type="button" data-href="#problems-3">题目3</button></li><li class="tab"><button type="button" data-href="#problems-4">题目4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="problems-1"><details class="folding-tag" ><summary> 强密码检验器 II </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/strong-password-checker-ii/">6095. 强密码检验器 II</a></p><p>如果一个密码满足以下所有条件，我们称它是一个 <strong>强</strong> 密码：</p><ul><li>它有至少 <code>8</code> 个字符。</li><li>至少包含 <strong>一个小写英文</strong> 字母。</li><li>至少包含 <strong>一个大写英文</strong> 字母。</li><li>至少包含 <strong>一个数字</strong> 。</li><li>至少包含 <strong>一个特殊字符</strong> 。特殊字符为：<code>&quot;!@#$%^&amp;*()-+&quot;</code> 中的一个。</li><li>它 <strong>不</strong> 包含 <code>2</code> 个连续相同的字符（比方说 <code>&quot;aab&quot;</code> 不符合该条件，但是 <code>&quot;aba&quot;</code> 符合该条件）。</li><li>给你一个字符串 <code>password</code> ，如果它是一个 <strong>强</strong> 密码，返回 <code>true</code>，否则返回 <code>false</code> 。</li></ul><div class="note info flat"><p>提示：</p><ul><li><code>1 &lt;= password.length &lt;= 100</code></li><li><code>password</code> 包含字母，数字和 <code>&quot;!@#$%^&amp;*()-+&quot;</code> 这些特殊字符。</li></ul></div><div class="note primary flat"><p>示例一：</p><p>输入：password = “IloveLe3tcode!”<br>输出：true<br>解释：密码满足所有的要求，所以我们返回 true 。</p></div><div class="note primary flat"><p>示例二：</p><p>输入：password = “Me+You–IsMyDream”<br>输出：false<br>解释：密码不包含数字，且包含 2 个连续相同的字符。所以我们返回 false 。</p></div><div class="note primary flat"><p>示例三：</p><p>输入：password = “1aB!”<br>输出：false<br>解释：密码不符合长度要求。所以我们返回 false 。</p></div>              </div>            </details><p>解决方案：</p><p>模拟：</p><p>按题意模拟即可。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">strongPasswordCheckerII</span><span class="params">(string password)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (password.<span class="built_in">size</span>() &lt; <span class="number">8</span>) <span class="comment">// 密码太短</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> haveNum, haveTes, haveBig, haveLow;</span><br><span class="line">        <span class="type">char</span> c = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        haveBig = haveLow = haveNum = haveTes = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; password.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == password[i]) <span class="comment">// 连续两个字符相同</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            c = password[i];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c)) <span class="comment">// 存在数字</span></span><br><span class="line">                haveNum = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">islower</span>(c)) <span class="comment">// 存在小写字母</span></span><br><span class="line">                haveLow = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isupper</span>(c)) <span class="comment">// 存在大写字母</span></span><br><span class="line">                haveBig = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 存在特殊字符</span></span><br><span class="line">                haveTes = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> haveBig &amp;&amp; haveLow &amp;&amp; haveNum &amp;&amp; haveTes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ；空间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。其中 <code>n</code> 为 <code>password</code> 的长度。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-2"><details class="folding-tag" ><summary> 咒语和药水的成功对数 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/">6096. 咒语和药水的成功对数</a></p><p>给你两个正整数数组 <code>spells</code> 和 <code>potions</code> ，长度分别为 <code>n</code> 和 <code>m</code> ，其中 <code>spells[i]</code> 表示第 <code>i</code> 个咒语的能量强度，<code>potions[j]</code> 表示第 <code>j</code> 瓶药水的能量强度。</p><p>同时给你一个整数 <code>success</code> 。一个咒语和药水的能量强度 <strong>相乘</strong> 如果 <strong>大于等于</strong> <code>success</code> ，那么它们视为一对 <strong>成功</strong> 的组合。</p><p>请你返回一个长度为 <code>n</code> 的整数数组 <code>pairs</code>，其中 <code>pairs[i]</code> 是能跟第 <code>i</code> 个咒语成功组合的 <strong>药水</strong> 数目。</p><div class="note info flat"><p>提示：</p><ul><li><code>n == spells.length</code></li><li><code>m == potions.length</code></li><li><code>1 &lt;= n, m &lt;= 1e5</code></li><li><code>1 &lt;= spells[i], potions[i] &lt;= 1e5</code></li><li><code>1 &lt;= success &lt;= 1e10</code></li></ul></div><div class="note primary flat"><p>示例一：</p><p>输入：spells = [5,1,3], potions = [1,2,3,4,5], success = 7<br>输出：[4,0,3]<br>解释：</p><ul><li>第 0 个咒语：5 * [1,2,3,4,5] = [5,10,15,20,25] 。总共 4 个成功组合。</li><li>第 1 个咒语：1 * [1,2,3,4,5] = [1,2,3,4,5] 。总共 0 个成功组合。</li><li>第 2 个咒语：3 * [1,2,3,4,5] = [3,6,9,12,15] 。总共 3 个成功组合。<br>所以返回 [4,0,3] 。</li></ul></div><div class="note primary flat"><p>示例二：</p><p>输入：spells = [3,1,2], potions = [8,5,8], success = 16<br>输出：[2,0,2]<br>解释：</p><ul><li>第 0 个咒语：3 * [8,5,8] = [24,15,24] 。总共 2 个成功组合。</li><li>第 1 个咒语：1 * [8,5,8] = [8,5,8] 。总共 0 个成功组合。</li><li>第 2 个咒语：2 * [8,5,8] = [16,10,16] 。总共 2 个成功组合。<br>所以返回 [2,0,2] 。</li></ul></div>              </div>            </details><p>解决方案：</p><p>二分查找：</p><p>对于 <code>spells</code> 中的每个咒语，在 <code>potions</code> 中找到能与其组合成功的药水的数量。</p><p>我们可以将药水按照能量强度从小到大排序，然后使用二分查找找到能与当前咒语组合成功的能量强度最小的药水，设其排序后的下标为 <code>idx</code>，<code>idx</code> 的值也即不能与当前咒语组合的药水数量，则能与当前咒语组合成功的药水数量为 <code>n - idx</code> 。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">successfulPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;spells, vector&lt;<span class="type">int</span>&gt; &amp;potions, <span class="type">long</span> <span class="type">long</span> success)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(potions.<span class="built_in">begin</span>(), potions.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> l, r, mid, n = potions.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> t;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; rst;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> spell : spells)</span><br><span class="line">        &#123;</span><br><span class="line">            l = <span class="number">0</span>;</span><br><span class="line">            r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// t 即能与 spell 组合成功的最小能量强度</span></span><br><span class="line">            t = success / spell + (success % spell != <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 找到 potions 中大于等于 t 的值的个数</span></span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">            &#123;</span><br><span class="line">                mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (potions[mid] &gt;= t)</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时 l 即能与当前咒语组合成功的能量强度最小的药水的下标 idx</span></span><br><span class="line">            rst.<span class="built_in">push_back</span>(n - l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> ；空间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。其中 <code>n</code> 表示 <code>spells</code> 的长度，<code>m</code> 表示 <code>potions</code> 的长度。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-3"><details class="folding-tag" ><summary> 替换字符后匹配 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/match-substring-after-replacement/">6097. 替换字符后匹配</a></p><p>给你两个字符串 <code>s</code> 和 <code>sub</code> 。同时给你一个二维字符数组 <code>mappings</code> ，其中 <code>mappings[i] = [oldi, newi]</code> 表示你可以替换 <code>sub</code> 中任意数目的 <code>oldi</code> 字符，替换成 <code>newi</code> 。<code>sub</code> 中每个字符 <strong>不能</strong> 被替换超过一次。</p><p>如果使用 <code>mappings</code> 替换 0 个或者若干个字符，可以将 <code>sub</code> 变成 <code>s</code> 的一个子字符串，请你返回 <code>true</code>，否则返回 <code>false</code> 。</p><p>一个 <strong>子字符串</strong> 是字符串中连续非空的字符序列。</p><div class="note info flat"><p>提示：</p><ul><li><code>1 &lt;= sub.length &lt;= s.length &lt;= 5000</code></li><li><code>0 &lt;= mappings.length &lt;= 1000</code></li><li><code>mappings[i].length == 2</code></li><li><code>oldi != newi</code></li><li><code>s</code> 和 <code>sub</code> 只包含大写和小写英文字母和数字。</li><li><code>oldi</code> 和 <code>newi</code> 是大写、小写字母或者是个数字。</li></ul></div><div class="note primary flat"><p>示例一：</p><p>输入：s = “fool3e7bar”, sub = “leet”, mappings = [[“e”,“3”],[“t”,“7”],[“t”,“8”]]<br>输出：true<br>解释：将 sub 中第一个 ‘e’ 用 ‘3’ 替换，将 ‘t’ 用 ‘7’ 替换。<br>现在 sub = “l3e7” ，它是 s 的子字符串，所以我们返回 true 。</p></div><div class="note primary flat"><p>示例二：</p><p>输入：s = “fooleetbar”, sub = “f00l”, mappings = [[“o”,“0”]]<br>输出：false<br>解释：字符串 “f00l” 不是 s 的子串且没有可以进行的修改。<br>注意我们不能用 ‘o’ 替换 ‘0’ 。</p></div><div class="note primary flat"><p>示例三：</p><p>输入：s = “Fool33tbaR”, sub = “leetd”, mappings = [[“e”,“3”],[“t”,“7”],[“t”,“8”],[“d”,“b”],[“p”,“b”]]<br>输出：true<br>解释：将 sub 里第一个和第二个 ‘e’ 用 ‘3’ 替换，用 ‘b’ 替换 sub 里的 ‘d’ 。<br>得到 sub = “l33tb” ，它是 s 的子字符串，所以我们返回 true 。</p></div>              </div>            </details><p>解决方案：</p><p>暴力穷举：</p><p>遍历 <code>s</code> 中的所有与 <code>sub</code> 长度相等的子字符串，并判断是否可以由 <code>sub</code> 变换而来。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">matchReplacement</span><span class="params">(string s, string sub, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; &amp;mappings)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> m = sub.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="comment">// canTo[i][j] 表示 (char)i 能否转变为 (char)j</span></span><br><span class="line">        <span class="type">bool</span> canTo[<span class="number">128</span>][<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(canTo, <span class="literal">false</span>, <span class="built_in">sizeof</span>(canTo));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录下 mappings 中所有的转变</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> map : mappings)</span><br><span class="line">            canTo[map[<span class="number">0</span>]][map[<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每个字符都可以转变为它自己</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">128</span>; ++i)</span><br><span class="line">            canTo[i][i] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        string temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 s 的所有长度为 m 的子字符串</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n - m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = s.<span class="built_in">substr</span>(i, m);</span><br><span class="line">            <span class="comment">// 判断子字符串 temp 能否由 sub 转变而来</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!canTo[sub[j]][temp[j]])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == m) <span class="comment">// sub 成功转变为 temp</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>c</mi><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>m</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(c + (n - m) * m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>；额外空间为 128 * 128 的 bool 型数组，空间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。其中 <code>n</code> 表示 <code>s</code> 的长度，<code>m</code> 表示 <code>sub</code> 的长度，<code>c</code> 表示 <code>mapping</code> 的长度。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-4"><details class="folding-tag" ><summary> 统计得分小于 K 的子数组数目 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/count-subarrays-with-score-less-than-k/">6098. 统计得分小于 K 的子数组数目</a></p><p>一个数组的 <strong>分数</strong> 定义为数组之和 <strong>乘以</strong> 数组的长度。</p><ul><li>比方说，<code>[1, 2, 3, 4, 5]</code> 的分数为 <code>(1 + 2 + 3 + 4 + 5) * 5 = 75</code> 。</li></ul><p>给你一个正整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回 <code>nums</code> 中分数 <strong>严格小于</strong> <code>k</code> 的 <strong>非空整数子数组数目</strong> 。</p><p><strong>子数组</strong> 是数组中的一个连续元素序列。</p><div class="note info flat"><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 1e5</code></li><li><code>1 &lt;= nums[i] &lt;= 1e5</code></li><li><code>1 &lt;= k &lt;= 1e15</code></li></ul></div><div class="note primary flat"><p>示例一：</p><p>输入：nums = [2,1,4,3,5], k = 10<br>输出：6<br>解释：<br>有 6 个子数组的分数小于 10 ：</p><ul><li>[2] 分数为 2 * 1 = 2 。</li><li>[1] 分数为 1 * 1 = 1 。</li><li>[4] 分数为 4 * 1 = 4 。</li><li>[3] 分数为 3 * 1 = 3 。</li><li>[5] 分数为 5 * 1 = 5 。</li><li>[2,1] 分数为 (2 + 1) * 2 = 6 。<br>注意，子数组 [1,4] 和 [4,3,5] 不符合要求，因为它们的分数分别为 10 和 36，但我们要求子数组的分数严格小于 10 。</li></ul></div><div class="note primary flat"><p>示例二：</p><p>输入：nums = [1,1,1], k = 5<br>输出：5<br>解释：<br>除了 [1,1,1] 以外每个子数组分数都小于 5 。<br>[1,1,1] 分数为 (1 + 1 + 1) * 3 = 9 ，大于 5 。<br>所以总共有 5 个子数组得分小于 5 。</p></div>              </div>            </details><p>解决方案：</p><p>前缀和 + 二分查找：</p><p>对于以 <code>nums[i]</code> 开始的子数组，由于 <code>nums</code> 中的元素均大于0，故可以找出一个长度 <code>maxlen</code>，对于 <code>nums[i]</code> 开始的，长度不超过 <code>maxlen</code> 的子数组的分数小于 <code>k</code> 。</p><p>可以使用二分查找找到这个长度 <code>k</code> ，并使用前缀和计算以 <code>nums[i]</code> 开始，长度为 <code>len</code> 的子数组的和。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">long</span> <span class="type">long</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i, n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 前缀和，preSum[i] 表示 nums[0] ~ nums[i - 1] 的和。</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">preSum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        preSum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            preSum[i + <span class="number">1</span>] = preSum[i] + nums[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> l, r, mid;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> t, sum, rst = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 计算以nums[i]开始的子数组满足要求的最长长度 maxlen</span></span><br><span class="line">            l = <span class="number">1</span>;</span><br><span class="line">            r = n - i;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">            &#123;</span><br><span class="line">                mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                sum = preSum[i + mid] - preSum[i];</span><br><span class="line">                t = sum * mid;</span><br><span class="line">                <span class="keyword">if</span>(t &gt;= k)</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时maxLen = l</span></span><br><span class="line">            rst += r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ；空间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。其中 <code>n</code> 表示 <code>nums</code> 的长度。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode周赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 题解 </tag>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录 LeetCode 第 296 场周赛</title>
      <link href="/2022/LC-WeeklyContext-296/"/>
      <url>/2022/LC-WeeklyContext-296/</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p><a href="https://leetcode.cn/contest/weekly-contest-296/">本次周赛</a>虽然非常简单，但是依旧仅写出第三题。第一题和第三题花了太长时间，导致第四题没在规定时间内写出来。</p></div><h2 id="战局详情-3">战局详情</h2><table><thead><tr><th>排名</th><th>用户名</th><th>得分</th><th>完成时间</th><th>题目1（3）</th><th>题目2（4）</th><th>题目3（5）</th><th>题目4（6）</th></tr></thead><tbody><tr><td>2761 / 5721</td><td>Juruoer</td><td>12</td><td>1:06:10</td><td>0:20:26</td><td>0:28:22</td><td>1:06:10</td><td></td></tr></tbody></table><h2 id="题目及解答-4">题目及解答</h2><div class="tabs" id="problems"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#problems-1">题目1</button></li><li class="tab"><button type="button" data-href="#problems-2">题目2</button></li><li class="tab"><button type="button" data-href="#problems-3">题目3</button></li><li class="tab"><button type="button" data-href="#problems-4">题目4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="problems-1"><details class="folding-tag" ><summary> 极大极小游戏 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/min-max-game/">6090. 极大极小游戏</a></p><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，其长度是 <code>2</code> 的幂。</p><p>对 <code>nums</code> 执行下述算法：</p><ol><li>设 <code>n</code> 等于 <code>nums</code> 的长度，如果 <code>n == 1</code> ，<strong>终止</strong> 算法过程。否则，<strong>创建</strong> 一个新的整数数组 <code>newNums</code> ，新数组长度为 <code>n / 2</code> ，下标从 <strong>0</strong> 开始。</li><li>对于满足 <code>0 &lt;= i &lt; n / 2</code> 的每个 <strong>偶数</strong> 下标 <code>i</code> ，将 <code>newNums[i]</code> <strong>赋值</strong> 为 <code>min(nums[2 * i], nums[2 * i + 1])</code> 。</li><li>对于满足 <code>0 &lt;= i &lt; n / 2</code> 的每个 <strong>奇数</strong> 下标 <code>i</code> ，将 <code>newNums[i]</code> <strong>赋值</strong> 为 <code>max(nums[2 * i], nums[2 * i + 1])</code> 。</li><li>用 <code>newNums</code> 替换 <code>nums</code> 。</li><li>从步骤 1 开始 <strong>重复</strong> 整个过程。</li></ol><p>执行算法后，返回 <code>nums</code> 中剩下的那个数字。</p><div class="note info flat"><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 1024</code></li><li><code>1 &lt;= nums[i] &lt;= 1e9</code></li><li><code>nums.length</code> 是 <code>2</code> 的幂</li></ul></div><div class="note primary flat"><p>示例一：</p><img alt  = "示例一图" src = "https://assets.leetcode.com/uploads/2022/04/13/example1drawio-1.png"><p>输入：nums = [1,3,5,2,4,8,2,2]<br>输出：1<br>解释：重复执行算法会得到下述数组。<br>第一轮：nums = [1,5,4,2]<br>第二轮：nums = [1,4]<br>第三轮：nums = [1]<br>1 是最后剩下的那个数字，返回 1 。</p></div><div class="note primary flat"><p>示例二：</p><p>输入：nums = [3]<br>输出：3<br>解释：3 就是最后剩下的数字，返回 3 。</p></div>              </div>            </details><p>解决方案：</p><p>很显然这是一个递归，每轮将数组分为等长度的两份，且观察可知，左边这份计算出的值一定位于新数组的偶数下标位，右边这份计算出的值一定位于新数组的奇数下标位。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 待计算的数组范围，isMin 表示要获得的是否为最小值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bin</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">bool</span> isMin)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r)</span><br><span class="line">            <span class="keyword">return</span> nums[l];</span><br><span class="line">        <span class="type">int</span> _r = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 分为两份，左边的 [l, _r] 求最小值，右边的 [_r + 1, r] 求最大值</span></span><br><span class="line">        <span class="keyword">return</span> isMin ? <span class="built_in">min</span>(<span class="built_in">bin</span>(nums, l, _r, <span class="literal">true</span>), <span class="built_in">bin</span>(nums, _r + <span class="number">1</span>, r, <span class="literal">false</span>)) : <span class="built_in">max</span>(<span class="built_in">bin</span>(nums, l, _r, <span class="literal">true</span>), <span class="built_in">bin</span>(nums, _r + <span class="number">1</span>, r, <span class="literal">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMaxGame</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bin</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>设 <code>nums</code> 长度为 <code>n</code>，遍历了一遍 <code>nums</code>，递归了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow></msubsup><msup><mn>2</mn><mi>i</mi></msup><mo>=</mo><mn>2</mn><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum _{i = 0} ^{log_2 n} 2 ^ i = 2n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2887em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.989em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">o</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>  次，故时间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ；空间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-2"><details class="folding-tag" ><summary> 划分数组使最大差为 K </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/partition-array-such-that-maximum-difference-is-k/">6091. 划分数组使最大差为 K</a></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。你可以将 <code>nums</code> 划分成一个或多个 <strong>子序列</strong> ，使 <code>nums</code> 中的每个元素都 <strong>恰好</strong> 出现在一个子序列中。</p><p>在满足每个子序列中最大值和最小值之间的差值最多为 <code>k</code> 的前提下，返回需要划分的 <strong>最少</strong> 子序列数目。</p><p><strong>子序列</strong> 本质是一个序列，可以通过删除另一个序列中的某些元素（或者不删除）但不改变剩下元素的顺序得到。</p><div class="note info flat"><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 1e5</code></li><li><code>0 &lt;= nums[i] &lt;= 1e5</code></li><li><code>0 &lt;= k &lt;= 1e5</code></li></ul></div><div class="note primary flat"><p>示例一：</p><p>输入：nums = [3,6,1,2,5], k = 2<br>输出：2<br>解释：<br>可以将 nums 划分为两个子序列 [3,1,2] 和 [6,5] 。<br>第一个子序列中最大值和最小值的差值是 3 - 1 = 2 。<br>第二个子序列中最大值和最小值的差值是 6 - 5 = 1 。<br>由于创建了两个子序列，返回 2 。可以证明需要划分的最少子序列数目就是 2 。</p></div><div class="note primary flat"><p>示例二：</p><p>输入：nums = [1,2,3], k = 1<br>输出：2<br>解释：<br>可以将 nums 划分为两个子序列 [1,2] 和 [3] 。<br>第一个子序列中最大值和最小值的差值是 2 - 1 = 1 。<br>第二个子序列中最大值和最小值的差值是 3 - 3 = 0 。<br>由于创建了两个子序列，返回 2 。注意，另一种最优解法是将 nums 划分成子序列 [1] 和 [2,3] 。</p></div><div class="note primary flat"><p>示例三：</p><p>输入：nums = [2,2,4,5], k = 0<br>输出：3<br>解释：<br>可以将 nums 划分为三个子序列 [2,2]、[4] 和 [5] 。<br>第一个子序列中最大值和最小值的差值是 2 - 2 = 0 。<br>第二个子序列中最大值和最小值的差值是 4 - 4 = 0 。<br>第三个子序列中最大值和最小值的差值是 5 - 5 = 0 。<br>由于创建了三个子序列，返回 3 。可以证明需要划分的最少子序列数目就是 3 。</p></div>              </div>            </details><p>解决方案：</p><p>贪心算法，将 <code>nums</code> 排序，然后让尽可能多的数字在一个子序列中。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partitionArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> t = nums[<span class="number">0</span>] + k;</span><br><span class="line">        <span class="type">int</span> rst = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; t)</span><br><span class="line">            &#123;</span><br><span class="line">                rst++;</span><br><span class="line">                t = num + k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ；空间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。<code>n</code> 为 <code>nums</code> 的长度</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-3"><details class="folding-tag" ><summary> 替换数组中的元素 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/replace-elements-in-an-array/">6092. 替换数组中的元素</a></p><p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，它包含 <code>n</code> 个 <strong>互不相同</strong> 的正整数。请你对这个数组执行 <code>m</code> 个操作，在第 <code>i</code> 个操作中，你需要将数字 <code>operations[i][0]</code> 替换成 <code>operations[i][1]</code> 。</p><p>题目保证在第 <code>i</code> 个操作中：</p><ul><li><code>operations[i][0]</code> 在 <code>nums</code> 中存在。</li><li><code>operations[i][1]</code> 在 <code>nums</code> 中不存在。</li></ul><p>请你返回执行完所有操作后的数组。</p><div class="note info flat"><p>提示：</p><ul><li><code>n == nums.length</code></li><li><code>m == operations.length</code></li><li><code>1 &lt;= n, m &lt;= 1e5</code></li><li><code>nums</code> 中所有数字 <strong>互不相同</strong> 。</li><li><code>operations[i].length == 2</code></li><li><code>1 &lt;= nums[i], operations[i][0], operations[i][1] &lt;= 1e6</code></li><li>在执行第 <code>i</code> 个操作时，<code>operations[i][0]</code> 在 <code>nums</code> 中存在。</li><li>在执行第 <code>i</code> 个操作时，<code>operations[i][1]</code> 在 <code>nums</code> 中不存在。</li></ul></div><div class="note primary flat"><p>示例一：</p><p>输入：nums = [1,2,4,6], operations = [[1,3],[4,7],[6,1]]<br>输出：[3,2,7,1]<br>解释：我们对 nums 执行以下操作：</p><ul><li>将数字 1 替换为 3 。nums 变为 [3,2,4,6] 。</li><li>将数字 4 替换为 7 。nums 变为 [3,2,7,6] 。</li><li>将数字 6 替换为 1 。nums 变为 [3,2,7,1] 。</li></ul><p>返回最终数组 [3,2,7,1] 。</p></div><div class="note primary flat"><p>示例二：</p><p>输入：nums = [1,2], operations = [[1,3],[2,1],[3,2]]<br>输出：[2,1]<br>解释：我们对 nums 执行以下操作：</p><ul><li>将数字 1 替换为 3 。nums 变为 [3,2] 。</li><li>将数字 2 替换为 1 。nums 变为 [3,1] 。</li><li>将数字 3 替换为 2 。nums 变为 [2,1] 。</li></ul><p>返回最终数组 [2,1] 。</p></div>              </div>            </details><p>解决方案：</p><p>按提议模拟即可</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arrayChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;operations)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; idxs; <span class="comment">// 记录每个数字的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            idxs[nums[i]] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> op : operations)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将 op[0] 替换为 op[1]，且 idxs 中一定存在op[0]，一定不存在op[1]（其实存在op[1]，但是可以假装不存在）</span></span><br><span class="line">            <span class="type">int</span> idx = idxs[op[<span class="number">0</span>]];</span><br><span class="line">            <span class="comment">// 此时可以把 op[0] 从 idxs 中删去，但是不删也没关系</span></span><br><span class="line">            idxs[op[<span class="number">1</span>]] = idx;</span><br><span class="line">            nums[idx] = op[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ；空间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，若每次都将 <code>op[0]</code> 从 <code>idxs</code> 中删去，则空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。<code>m</code> 为 操作次数，<code>n</code> 为 <code>nums</code> 长度。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-4"><details class="folding-tag" ><summary> 设计一个文本编辑器 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/design-a-text-editor/">6093. 设计一个文本编辑器</a></p><p>请你设计一个带光标的文本编辑器，它可以实现以下功能：</p><ul><li><strong>添加</strong>：在光标所在处添加文本。</li><li><strong>删除</strong>：在光标所在处删除文本（模拟键盘的删除键）。</li><li><strong>移动</strong>：将光标往左或者往右移动。</li></ul><p>当删除文本时，只有光标左边的字符会被删除。光标会留在文本内，也就是说任意时候 <code>0 &lt;= cursor.position &lt;= currentText.length</code> 都成立。</p><p>请你实现 <code>TextEditor</code> 类：</p><ul><li><code>TextEditor()</code> 用空文本初始化对象。</li><li><code>void addText(string text)</code> 将 <code>text</code> 添加到光标所在位置。添加完后光标在 <code>text</code> 的右边。</li><li><code>int deleteText(int k)</code> 删除光标左边 <code>k</code> 个字符。返回实际删除的字符数目。</li><li><code>string cursorLeft(int k)</code> 将光标向左移动 <code>k</code> 次。返回移动后光标左边 <code>min(10, len)</code> 个字符，其中 <code>len</code> 是光标左边的字符数目。</li><li><code>string cursorRight(int k)</code> 将光标向右移动 <code>k</code> 次。返回移动后光标左边 <code>min(10, len)</code> 个字符，其中 <code>len</code> 是光标左边的字符数目。</li></ul><div class="note info flat"><p>提示：</p><p><code>1 &lt;= text.length, k &lt;= 40</code><br><code>text</code> 只含有小写英文字母。<br>调用 <code>addText</code> ，<code>deleteText</code> ，<code>cursorLeft</code> 和 <code>cursorRight</code> 的 <strong>总</strong> 次数不超过 <code>2 * 1e4</code> 次。</p></div><div class="note primary flat"><p>示例一：</p><p>输入：<br>[“TextEditor”, “addText”, “deleteText”, “addText”, “cursorRight”, “cursorLeft”, “deleteText”, “cursorLeft”, “cursorRight”]<br>[[], [“leetcode”], [4], [“practice”], [3], [8], [10], [2], [6]]<br>输出：<br>[null, null, 4, null, “etpractice”, “leet”, 4, “”, “practi”]</p><p>解释：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">TextEditor textEditor = <span class="keyword">new</span> <span class="built_in">TextEditor</span>(); <span class="comment">// 当前 text 为 &quot;|&quot; 。（&#x27;|&#x27; 字符表示光标）</span></span><br><span class="line">textEditor.<span class="built_in">addText</span>(<span class="string">&quot;leetcode&quot;</span>); <span class="comment">// 当前文本为 &quot;leetcode|&quot; 。</span></span><br><span class="line">textEditor.<span class="built_in">deleteText</span>(<span class="number">4</span>); <span class="comment">// 返回 4</span></span><br><span class="line">                          <span class="comment">// 当前文本为 &quot;leet|&quot; 。</span></span><br><span class="line">                          <span class="comment">// 删除了 4 个字符。</span></span><br><span class="line">textEditor.<span class="built_in">addText</span>(<span class="string">&quot;practice&quot;</span>); <span class="comment">// 当前文本为 &quot;leetpractice|&quot; 。</span></span><br><span class="line">textEditor.<span class="built_in">cursorRight</span>(<span class="number">3</span>); <span class="comment">// 返回 &quot;etpractice&quot;</span></span><br><span class="line">                           <span class="comment">// 当前文本为 &quot;leetpractice|&quot;. </span></span><br><span class="line">                           <span class="comment">// 光标无法移动到文本以外，所以无法移动。</span></span><br><span class="line">                           <span class="comment">// &quot;etpractice&quot; 是光标左边的 10 个字符。</span></span><br><span class="line">textEditor.<span class="built_in">cursorLeft</span>(<span class="number">8</span>); <span class="comment">// 返回 &quot;leet&quot;</span></span><br><span class="line">                          <span class="comment">// 当前文本为 &quot;leet|practice&quot; 。</span></span><br><span class="line">                          <span class="comment">// &quot;leet&quot; 是光标左边的 min(10, 4) = 4 个字符。</span></span><br><span class="line">textEditor.<span class="built_in">deleteText</span>(<span class="number">10</span>); <span class="comment">// 返回 4</span></span><br><span class="line">                           <span class="comment">// 当前文本为 &quot;|practice&quot; 。</span></span><br><span class="line">                           <span class="comment">// 只有 4 个字符被删除了。</span></span><br><span class="line">textEditor.<span class="built_in">cursorLeft</span>(<span class="number">2</span>); <span class="comment">// 返回 &quot;&quot;</span></span><br><span class="line">                          <span class="comment">// 当前文本为 &quot;|practice&quot; 。</span></span><br><span class="line">                          <span class="comment">// 光标无法移动到文本以外，所以无法移动。</span></span><br><span class="line">                          <span class="comment">// &quot;&quot; 是光标左边的 min(10, 0) = 0 个字符。</span></span><br><span class="line">textEditor.<span class="built_in">cursorRight</span>(<span class="number">6</span>); <span class="comment">// 返回 &quot;practi&quot;</span></span><br><span class="line">                           <span class="comment">// 当前文本为 &quot;practi|ce&quot; 。</span></span><br><span class="line">                           <span class="comment">// &quot;practi&quot; 是光标左边的 min(10, 6) = 6 个字符。</span></span><br></pre></td></tr></table></figure></div>              </div>            </details><p>解决方案：</p><p>因为不需要实时返回文本内容，且多为 <strong>添加</strong> 和 <strong>删除</strong> 操作，<strong>移动</strong> 操作移动距离较短，故使用 <strong>链式存储结构</strong> 合适。</p><p>所以可以使用一个链表来维护文本，然后模拟即可。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextEditor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">    &#123;</span><br><span class="line">        node *next; <span class="comment">// 后继</span></span><br><span class="line">        node *pre; <span class="comment">// 前驱</span></span><br><span class="line">        <span class="type">char</span> c; <span class="comment">// 字符</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">node</span>(<span class="type">char</span> _c = <span class="number">0</span>, node *_pre = <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            c = _c;</span><br><span class="line">            next = <span class="literal">nullptr</span>;</span><br><span class="line">            pre = _pre;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;node;</span><br><span class="line">    node t; <span class="comment">// 头节点，指向整个文本</span></span><br><span class="line">    node *p; <span class="comment">// 当前光标指向所在位置的最后一个字符，例如 &quot;abc|d&quot;，&#x27;|&#x27; 表示光标，则 p 指向 &#x27;c&#x27;</span></span><br><span class="line">    <span class="type">int</span> left; <span class="comment">// 当前光标前的字符个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TextEditor</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        p = &amp;t;</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addText</span><span class="params">(string text)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node *q = p-&gt;next; <span class="comment">// q 指向原插入位置后的文本，可能为空</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : text) <span class="comment">// 将待插入的字符插入</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> <span class="built_in">node</span>(c, p);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = q; <span class="comment">// 接上原插入位置后的文本</span></span><br><span class="line">        <span class="keyword">if</span>(q) <span class="comment">// 如果原插入位置后存在文本，则重定向其前驱</span></span><br><span class="line">            q-&gt;pre = p;</span><br><span class="line">        left += text.<span class="built_in">length</span>(); <span class="comment">// 当前光标位置改变，其左边字符数增加</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteText</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node *q = p;</span><br><span class="line">        k = <span class="built_in">min</span>(k, left); <span class="comment">// 此时 k 为实际删除的字符数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) <span class="comment">// 寻找要删除的字符串的前驱</span></span><br><span class="line">            q = q-&gt;pre;</span><br><span class="line"></span><br><span class="line">        q-&gt;next = p-&gt;next; <span class="comment">// 删除 q-&gt;next 到 p 的所有字符（注意：实际开发时应当释放这些节点的空间）</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next) <span class="comment">// 如果后面还有文本，则重定向其前驱</span></span><br><span class="line">            p-&gt;next-&gt;pre = q;</span><br><span class="line">        p = q; <span class="comment">// 改变光标位置</span></span><br><span class="line">        left -= k; <span class="comment">// 光标前的字符数减少</span></span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">cursorLeft</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string rst = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        k = <span class="built_in">min</span>(left, k); <span class="comment">// 实际左移个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) <span class="comment">// 光标左移</span></span><br><span class="line">            p = p-&gt;pre;</span><br><span class="line">        </span><br><span class="line">        left -= k; <span class="comment">// 光标前字符数减少</span></span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">min</span>(left, <span class="number">10</span>); <span class="comment">// 按要求返回的字符串的长度</span></span><br><span class="line">        node *q = p;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) <span class="comment">// 构建返回的字符串</span></span><br><span class="line">        &#123;</span><br><span class="line">            rst.<span class="built_in">insert</span>(<span class="number">0</span>, <span class="number">1</span>, q-&gt;c);</span><br><span class="line">            q = q-&gt;pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">cursorRight</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string rst = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) <span class="comment">// 光标右移到指定位置或文本末尾</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            left++; <span class="comment">// 光标前字符串增加</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">min</span>(left, <span class="number">10</span>); <span class="comment">// 按要求返回的字符串的长度</span></span><br><span class="line">        node *q = p;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) <span class="comment">// 构建返回的字符串</span></span><br><span class="line">        &#123;</span><br><span class="line">            rst.<span class="built_in">insert</span>(<span class="number">0</span>, <span class="number">1</span>, q-&gt;c); </span><br><span class="line">            q = q-&gt;pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TextEditor object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TextEditor* obj = new TextEditor();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addText(text);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;deleteText(k);</span></span><br><span class="line"><span class="comment"> * string param_3 = obj-&gt;cursorLeft(k);</span></span><br><span class="line"><span class="comment"> * string param_4 = obj-&gt;cursorRight(k);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><code>TextEditor()</code>：时间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> ；空间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。</p><p><code>addText(string text)</code>：时间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> ；空间复杂度为：<code>O(k)</code> 。<code>k</code> 为 <code>text</code> 长度。</p><p><code>deleteText(int k)</code>：时间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> ；空间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。<code>k</code> 为删除字符数</p><p><code>cursorLeft(int k)</code>：时间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> ；空间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。<code>k</code> 为移动次数</p><p><code>cursorRight(int k)</code>：时间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> ；空间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。<code>k</code> 为移动次数</p><p>总时间复杂度为： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo>×</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k \times c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span> ；空间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo>×</mo><mi>a</mi><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k \times ac)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span>，若删除时将空间释放，则空间复杂度可以更小。<code>k</code> 表示每次增加或删除或移动的字符个数，<code>c</code> 表示 总操作次数，<code>ac</code> 表示添加操作的次数。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode周赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 题解 </tag>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录 LeetCode 第 295 场周赛</title>
      <link href="/2022/LC-WeeklyContext-295/"/>
      <url>/2022/LC-WeeklyContext-295/</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p><a href="https://leetcode.cn/contest/weekly-contest-295/">本次周赛</a>惨遭滑铁卢，仅仅写出第一题。前一天睡的太晚了，比赛的时候浑浑噩噩。第二题由于 <code>double</code> 强转 <code>int</code> 的精度问题，一直 WA，第三题又没有什么思路，第四题压根没看 <s>（可惜第四题直接 Dijkstra 就可以 AC）</s> 。</p></div><h2 id="战局详情-4">战局详情</h2><table><thead><tr><th>排名</th><th>用户名</th><th>得分</th><th>完成时间</th><th>题目1（3）</th><th>题目2（4）</th><th>题目3（5）</th><th>题目4（6）</th></tr></thead><tbody><tr><td>3944 / 6640</td><td>Juruoer</td><td>3</td><td>0:08:13</td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="题目及解答-5">题目及解答</h2><div class="tabs" id="problems"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#problems-1">题目1</button></li><li class="tab"><button type="button" data-href="#problems-2">题目2</button></li><li class="tab"><button type="button" data-href="#problems-3">题目3</button></li><li class="tab"><button type="button" data-href="#problems-4">题目4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="problems-1"><details class="folding-tag" ><summary> 重排字符形成目标字符串 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/rearrange-characters-to-make-target-string/">2287. 重排字符形成目标字符串</a></p><p>给你两个下标从 <strong>0</strong> 开始的字符串 <code>s</code> 和 <code>target</code> 。你可以从 <code>s</code> 取出一些字符并将其重排，得到若干新的字符串。</p><p>从 <code>s</code> 中取出字符并重新排列，返回可以形成 <code>target</code> 的 <strong>最大</strong> 副本数。</p><div class="note info flat"><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>1 &lt;= target.length &lt;= 10</code></li><li><code>s</code> 和 <code>target</code> 由小写英文字母组成</li></ul></div><div class="note primary flat"><p>示例一：</p><p>输入：s = “ilovecodingonleetcode”, target = “code”<br>输出：2<br>解释：<br>对于 “code” 的第 1 个副本，选取下标为 4 、5 、6 和 7 的字符。<br>对于 “code” 的第 2 个副本，选取下标为 17 、18 、19 和 20 的字符。<br>形成的字符串分别是 “ecod” 和 “code” ，都可以重排为 “code” 。<br>可以形成最多 2 个 “code” 的副本，所以返回 2 。</p></div><div class="note primary flat"><p>示例二：</p><p>输入：s = “abcba”, target = “abc”<br>输出：1<br>解释：<br>选取下标为 0 、1 和 2 的字符，可以形成 “abc” 的 1 个副本。<br>可以形成最多 1 个 “abc” 的副本，所以返回 1 。<br>注意，尽管下标 3 和 4 分别有额外的 ‘a’ 和 ‘b’ ，但不能重用下标 2 处的 ‘c’ ，所以无法形成 “abc” 的第 2 个副本。</p></div><div class="note primary flat"><p>示例三：</p><p>输入：s = “abbaccaddaeea”, target = “aaaaa”<br>输出：1<br>解释：<br>选取下标为 0 、3 、6 、9 和 12 的字符，可以形成 “aaaaa” 的 1 个副本。<br>可以形成最多 1 个 “aaaaa” 的副本，所以返回 1 。</p></div>              </div>            </details><p>解决方案：</p><p>计算 <code>s</code> 中每个字符的个数分别为 <code>target</code> 中每个字符的个数的多少倍，取最小倍数即为答案。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rearrangeCharacters</span><span class="params">(string s, string target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnts</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">have</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> rst = <span class="number">0x7fffffff</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : target)</span><br><span class="line">        &#123;</span><br><span class="line">            ++cnts[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s)</span><br><span class="line">        &#123;</span><br><span class="line">            ++have[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnts[i] &gt; <span class="number">0</span>)</span><br><span class="line">                rst = <span class="built_in">min</span>(rst, have[i] / cnts[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，空间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，<code>m</code> 和 <code>n</code> 分别为 <code>s</code> 和 <code>target</code> 的长度。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-2"><details class="folding-tag" ><summary> 价格减免 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/apply-discount-to-prices/">2288. 价格减免</a></p><p><strong>句子</strong> 是由若干个单词组成的字符串，单词之间用单个空格分隔，其中每个单词可以包含数字、小写字母、和美元符号 <code>'$'</code> 。如果单词的形式为美元符号后跟着一个非负实数，那么这个单词就表示一个价格。</p><ul><li>例如 <code>&quot;$100&quot;</code>、<code>&quot;$23&quot;</code> 和 <code>&quot;$6.75&quot;</code> 表示价格，而 <code>&quot;100&quot;</code>、<code>&quot;$&quot;</code> 和 <code>&quot;2$3&quot;</code> 不是。</li></ul><p>注意：本题输入中的价格均为整数。</p><p>给你一个字符串 <code>sentence</code>  和一个整数 <code>discount</code> 。对于每个表示价格的单词，都在价格的基础上减免 <code>discount%</code> ，并 <strong>更新</strong> 该单词到句子中。所有更新后的价格应该表示为一个 <strong>恰好保留小数点后两位</strong> 的数字。</p><p>返回表示修改后句子的字符串。</p><div class="note info flat"><p>提示：</p><ul><li><code>1 &lt;= sentence.length &lt;= 1e5</code></li><li><code>sentence</code> 由小写英文字母、数字、<code>' '</code> 和 <code>'$'</code> 组成</li><li><code>sentence</code> 不含前导和尾随空格</li><li><code>sentence</code> 的所有单词都用单个空格分隔</li><li>所有价格都是 <strong>正</strong> 整数且不含前导零</li><li>所有价格 <strong>最多</strong> 为  <code>10</code> 位数字</li><li><code>0 &lt;= discount &lt;= 100</code></li></ul></div><div class="note primary flat"><p>示例一：</p><p>输入：sentence = “there are $1 $2 and 5$ candies in the shop”, discount = 50<br>输出：“there are $0.50 $1.00 and 5$ candies in the shop”<br>解释：<br>表示价格的单词是 “$1” 和 “$2” 。</p><ul><li>“$1” 减免 50% 为 “$0.50” ，所以 “$1” 替换为 “$0.50” 。</li><li>“$2” 减免 50% 为 “$1” ，所以 “$1” 替换为 “$1.00” 。</li></ul></div><div class="note primary flat"><p>示例二：</p><p>输入：sentence = “1 2 $3 4 $5 $6 7 8$ $9 $10$”, discount = 100<br>输出：“1 2 $0.00 4 $0.00 $0.00 7 8$ $0.00 $10$”<br>解释：<br>任何价格减免 100% 都会得到 0 。<br>表示价格的单词分别是 “$3”、“$5”、“$6” 和 “$9”。<br>每个单词都替换为 “$0.00”。</p></div>              </div>            </details><p>解决方案：</p><p>字符串模拟题，遍历字符串 <code>sentence</code> （也可以使用正则表达式），对于所有的价格计算出新的价格，构造新的字符串即可。</p><p>需要注意的是，此题要求保留两位小数，但若使用 <code>float</code> 类型或 <code>double</code> 类型强转成 <code>int</code> 类型会有精度错误，当然也可以不强转，而使用字符流 <code>ostringstream</code> 来格式化地将浮点型 <strong>保留指定小数位</strong> 并转为 <code>ostringstream</code> 型，再获取相应 <code>string</code> 型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于浮点型价格 price 保留两位小数转为字符流</span></span><br><span class="line">ostringstream oss;</span><br><span class="line">oss &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; price;</span><br><span class="line"></span><br><span class="line">oss.<span class="built_in">str</span>();</span><br></pre></td></tr></table></figure><p>也可以不使用浮点型，由于本题 <code>discount</code> 属于 <code>0</code> 到 <code>100</code>，故对于价格 <code>price</code>，<code>price * (100 - discount)</code> 即为打折后的价格的 <code>100</code> 倍，其最后两位数即为小数点后的值，且没有精度问题。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">discountPrices</span><span class="params">(string sentence, <span class="type">int</span> discount)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k, n = sentence.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> r = <span class="number">100</span> - discount;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> num;</span><br><span class="line">        <span class="type">bool</span> isDig;</span><br><span class="line">        string rst = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        string temp;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == n || sentence[i] == <span class="string">&#x27; &#x27;</span>) <span class="comment">// 每有一个新的单词</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp = sentence.<span class="built_in">substr</span>(j, i - j); <span class="comment">// 取出该单词</span></span><br><span class="line">                <span class="keyword">if</span> (temp[<span class="number">0</span>] != <span class="string">&#x27;$&#x27;</span> || temp.<span class="built_in">size</span>() &gt; <span class="number">11</span> || temp.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="comment">// 该单词明显不是价格</span></span><br><span class="line">                    rst.<span class="built_in">append</span>(temp);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    isDig = <span class="literal">true</span>;</span><br><span class="line">                    num = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt; temp.<span class="built_in">size</span>(); ++k)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(temp[k])) <span class="comment">// 该单词依旧不是价格</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            isDig = <span class="literal">false</span>;</span><br><span class="line">                            rst.<span class="built_in">append</span>(temp);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        num = num * <span class="number">10</span> + temp[k] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(isDig)</span><br><span class="line">                    &#123;</span><br><span class="line">                        num *= r; <span class="comment">// 计算出打折后的价格的100倍</span></span><br><span class="line">                        rst.<span class="built_in">push_back</span>(<span class="string">&#x27;$&#x27;</span>);</span><br><span class="line">                        rst.<span class="built_in">append</span>(<span class="built_in">to_string</span>(num / <span class="number">100</span>)); <span class="comment">// 小数点前的数</span></span><br><span class="line">                        num = num % <span class="number">100</span>; <span class="comment">// 小数点后的数</span></span><br><span class="line">                        rst.<span class="built_in">push_back</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                        <span class="keyword">if</span>(num &lt; <span class="number">10</span>) <span class="comment">// 若后两位为 0x，则补充第一个0</span></span><br><span class="line">                            rst.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                        rst.<span class="built_in">append</span>(<span class="built_in">to_string</span>(num));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i != n)</span><br><span class="line">                    rst.<span class="built_in">push_back</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，<code>n</code> 为 <code>sentence</code> 的长度。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-3"><details class="folding-tag" ><summary> 使数组按非递减顺序排列 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/steps-to-make-array-non-decreasing/">2289. 使数组按非递减顺序排列</a></p><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。在一步操作中，移除所有满足 <code>nums[i - 1] &gt; nums[i]</code> 的 <code>nums[i]</code> ，其中 <code>0 &lt; i &lt; nums.length</code> 。</p><p>重复执行步骤，直到 <code>nums</code> 变为 <strong>非递减</strong> 数组，返回所需执行的操作数。</p><div class="note info flat"><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 1e5</code></li><li><code>1 &lt;= nums[i] &lt;= 1e9</code></li></ul></div><div class="note primary flat"><p>示例一：</p><p>输入：nums = [5,3,4,4,7,3,6,11,8,5,11]<br>输出：3<br>解释：执行下述几个步骤：</p><ul><li>步骤 1 ：[5,3,4,4,7,3,6,11,8,5,11] 变为 [5,4,4,7,6,11,11]</li><li>步骤 2 ：[5,4,4,7,6,11,11] 变为 [5,4,7,11,11]</li><li>步骤 3 ：[5,4,7,11,11] 变为 [5,7,11,11]<br>[5,7,11,11] 是一个非递减数组，因此，返回 3 。</li></ul></div><div class="note primary flat"><p>示例二：</p><p>输入：nums = [4,5,7,7,13]<br>输出：0<br>解释：nums 已经是一个非递减数组，因此，返回 0 。</p></div>              </div>            </details><p>解决方案：</p><p>若直接模拟，则时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 显然 TLE。</p><p>可以使用 单调栈 + 动态规划 计算。</p><p>以下的 <code>x</code> 被 <code>y</code> 删除的意思是，经过一系列删除操作后 <code>y</code> 为 <code>x</code> 的前一个元素，且 <code>y &gt; x</code>。</p><blockquote><p>此段来自 <a href="https://leetcode.cn/u/endlesscheng/">灵茶山艾府</a> 的 <a href="https://leetcode.cn/problems/steps-to-make-array-non-decreasing/solution/by-endlesscheng-s2yc/">题解</a> 的提示2：</p><p><code>nums[i]</code> 若被删除，则一定是被 <code>nums[i]</code> 左边的某个值删除，可以证明， <code>nums[i]</code> 若被删除，则其被删除所需的步数可以等价于被其左边第一个大于 <code>nums[i]</code> 的值（设为 <code>nums[j]</code>）删除所需的步数。</p><p>以 <code>[20,1,9,1,2,3]</code> 为例。</p><p>时刻一 <code>20</code> 删掉 <code>1</code>，<code>9</code> 删掉 <code>1</code>；<br>时刻二 <code>20</code> 删掉 <code>9</code>，<code>9</code> 删掉 <code>2</code>;<br>时刻三 <code>20</code> 接替了 <code>9</code> 的任务，来删除数字 <code>3</code>。<br>虽然说数字 <code>3</code> 是被 <code>20</code> 删除的，但是由于 <code>20</code> 立马接替了 <code>9</code>，我们可以等价转换成 <code>3</code> 是被 <code>9</code> 删除的，也就是它左边离它最近且比它大的那个数。这一等价转换不会影响数字被删除的时刻。</p></blockquote><p>可以使用单调递减栈来计算每个元素左边第一个大于其的元素。</p><p>设删除 <code>nums[i]</code> 所需的步数为 <code>dp[i]</code> (若 <code>nums[i]</code> 不需要删除，则 <code>dp[i]</code> 等于 <code>0</code>)，且假设 <code>nums[i]</code> 被 <code>nums[j]</code> 删除（或根据上述所说的等价于被nums[j]删除），则 <code>nums[j + 1]</code> 到 <code>nums[i - 1]</code> 均已被删除，则：</p><ul><li><code>dp[i] = max(dp[j + 1], dp[j + 2], ... , dp[i - 1]) + 1</code>。</li></ul><p>单调递减栈出栈时刚好会将 <code>nums[i]</code> 左边小于其的值取出直至遇到 <code>nums[j]</code> 或栈空(即 <code>nums[i]</code> 无需删除)。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalSteps</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st; <span class="comment">// 单调递减栈</span></span><br><span class="line">        <span class="type">int</span> rst = <span class="number">0</span>, i, n = nums.<span class="built_in">size</span>(), step;</span><br><span class="line">        <span class="type">int</span> dp[n];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            step = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 找到左边第一个大于 nums[i] 的元素 nums[j]，并计算出 step = max(dp[j + 1], dp[j + 2], ... , dp[i - 1])</span></span><br><span class="line">            <span class="keyword">while</span>(st.<span class="built_in">size</span>() &amp;&amp; nums[i] &gt;= nums[st.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                step = <span class="built_in">max</span>(step, dp[st.<span class="built_in">top</span>()]);</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(st.<span class="built_in">size</span>()) <span class="comment">// 若栈中还有元素，说明 nums[i] 需要被删除，且删除步数为 step + 1</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = step + <span class="number">1</span>;</span><br><span class="line">                rst = <span class="built_in">max</span>(rst, dp[i]); <span class="comment">// 更新最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，<code>n</code> 为 <code>nums</code> 的长度。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-4"><details class="folding-tag" ><summary> 到达角落需要移除障碍物的最小数目 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/">6081. 到达角落需要移除障碍物的最小数目</a></p><p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>grid</code> ，数组大小为 <code>m x n</code> 。每个单元格都是两个值之一：</p><ul><li><code>0</code> 表示一个 <strong>空</strong> 单元格，</li><li><code>1</code> 表示一个可以移除的 <strong>障碍物</strong> 。</li></ul><p>你可以向上、下、左、右移动，从一个空单元格移动到另一个空单元格。</p><p>现在你需要从左上角 <code>(0, 0)</code> 移动到右下角 <code>(m - 1, n - 1)</code> ，返回需要移除的障碍物的 <strong>最小</strong> 数目。</p><div class="note info flat"><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 1e5</code></li><li><code>2 &lt;= m * n &lt;= 1e5</code></li><li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li><li><code>grid[0][0] == grid[m - 1][n - 1] == 0</code></li></ul></div><div class="note primary flat"><p>示例一：</p><img src = "https://assets.leetcode.com/uploads/2022/04/06/example1drawio-1.png" alt = "示例一图"><p>输入：grid = [[0,1,1],[1,1,0],[1,1,0]]<br>输出：2<br>解释：可以移除位于 (0, 1) 和 (0, 2) 的障碍物来创建从 (0, 0) 到 (2, 2) 的路径。<br>可以证明我们至少需要移除两个障碍物，所以返回 2 。<br>注意，可能存在其他方式来移除 2 个障碍物，创建出可行的路径。</p></div><div class="note primary flat"><p>示例二：</p><img src = "https://assets.leetcode.com/uploads/2022/04/06/example1drawio.png" alt = "示例二图"><p>输入：grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]<br>输出：0<br>解释：不移除任何障碍物就能从 (0, 0) 到 (2, 4) ，所以返回 0 。</p></div>              </div>            </details><p>解决方案：</p><p>单源最短路径问题，空格子表示路径花销为 <code>0</code>，障碍物表示路径花销为 <code>1</code>。</p><p>方法一、Dijkstra 算法</p><p>Dijkstra 算法是很有名的算法了，不作过多解释，这里使用一个小根堆来维护待计算的点。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; tiii;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cmp</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> tiii &amp;a, <span class="type">const</span> tiii &amp;b)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(a) &gt; <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cx, cy, nx, ny;</span><br><span class="line">        <span class="type">int</span> cdis;</span><br><span class="line">        <span class="type">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 小根堆，将 “未访问过” 的点按距离从小到大排列（因为有环，故该点也可能访问过，但是后续会判断，且队列中不一定包含所有未访问点，但队头元素一定是未访问的点中距离(0, 0)点最近的点）</span></span><br><span class="line">        <span class="comment">// 对于所有 已访问过 的点，其最近距离已经计算完成了。</span></span><br><span class="line">        priority_queue&lt;tiii, vector&lt;tiii&gt;, cmp&gt; qu;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dis[m][n]; <span class="comment">// 距离数组</span></span><br><span class="line">        <span class="type">bool</span> vis[m][n]; <span class="comment">// 访问标记</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">0x7f</span>, <span class="built_in">sizeof</span>(dis)); <span class="comment">// 初始化所有距离为 0x7f7f7f7f，虽然不是 int 最大值，但大于 m + n</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis)); <span class="comment">// 开始时未访问任何点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一个点</span></span><br><span class="line">        dis[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]; </span><br><span class="line">        qu.<span class="built_in">emplace</span>(<span class="number">0</span>, <span class="number">0</span>, dis[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(qu.<span class="built_in">size</span>()) <span class="comment">// 还有 “未访问过” 的点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tie</span>(cx, cy, cdis) = qu.<span class="built_in">top</span>();</span><br><span class="line">            qu.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(vis[cx][cy]) <span class="comment">// 若已经访问过，跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            vis[cx][cy] = <span class="literal">true</span>; <span class="comment">// 标记为已访问过</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;dir : dirs) <span class="comment">// 遍历该点可以直接到达的点</span></span><br><span class="line">            &#123;</span><br><span class="line">                nx = cx + dir[<span class="number">0</span>];</span><br><span class="line">                ny = cy + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || ny &lt; <span class="number">0</span> || nx &gt;= m || ny &gt;= n || vis[nx][ny]) <span class="comment">// 点坐标不合法或已经访问过</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(cdis + grid[nx][ny] &lt; dis[nx][ny]) <span class="comment">// 更新距离</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dis[nx][ny] = cdis + grid[nx][ny];</span><br><span class="line">                    <span class="comment">// 若未更新距离，说明有一条跟近的路线到达 点(nx, ny)，则点 (nx, ny) 要么已经访问过了，要么已经存在于 qu 中了</span></span><br><span class="line">                    qu.<span class="built_in">emplace</span>(nx, ny, dis[nx][ny]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mnlog(mn))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">mn</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">mn</span><span class="mclose">))</span></span></span></span>，空间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">mn</span><span class="mclose">)</span></span></span></span>，<code>m</code>，<code>n</code> 分别表示 <code>grid</code> 的行数和列数。</p><p>方法二、0-1 BFS</p><p><code>bfs</code> 可以解决所有路径花销为 <code>1</code> 的图的最短理解问题，而 <code>0-1bfs</code> 则可以解决所有路径花销为 <code>0</code> 或 <code>1</code> 的图的最短路径问题。</p><p>只要稍微修改 <code>bfs</code> 算法，使得每次计算时优先计算路径花销为 <code>0</code> 的节点，相当于花销为 <code>0</code> 的节点被 “无视掉”，即其前驱节点视为可以 “直接” 连到其后继节点，亦相当于减少花销为 <code>0</code> 的节点的后继结点 <code>bfs</code> 的的层数。</p><p>由于只有成功更新距离才会将点入队，但每个点第一次跟新距离后其实就已经计算出最短路径了（因为是层序遍历，虽然可能还有其他的路径可以到达该点，但是距离一定不会小于第一次计算出的距离），所以不需要访问标记 <code>vis</code>，也不会出现环。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line">    <span class="type">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dis[m][n];</span><br><span class="line">        <span class="type">int</span> nx, ny, d;</span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">0x7f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">        dis[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        deque&lt;pii&gt; dq; <span class="comment">// 双端队列</span></span><br><span class="line">        dq.<span class="built_in">emplace_front</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(dq.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> [cx, cy] = dq.<span class="built_in">front</span>();</span><br><span class="line">            dq.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;dir : dirs)</span><br><span class="line">            &#123;</span><br><span class="line">                nx = cx + dir[<span class="number">0</span>];</span><br><span class="line">                ny = cy + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || ny &lt; <span class="number">0</span> || nx &gt;= m || ny &gt;= n)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                d = grid[nx][ny];</span><br><span class="line">                <span class="keyword">if</span>(dis[cx][cy] + d &lt; dis[nx][ny]) <span class="comment">// 更新距离</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dis[nx][ny] = dis[cx][cy] + d;</span><br><span class="line">                    <span class="comment">// 若花销为 0，则将其插入队头，否则插入队尾</span></span><br><span class="line">                    d == <span class="number">0</span> ? dq.<span class="built_in">emplace_front</span>(nx, ny) : dq.<span class="built_in">emplace_back</span>(nx, ny);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">mn</span><span class="mclose">)</span></span></span></span>，空间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">mn</span><span class="mclose">)</span></span></span></span>，<code>m</code>，<code>n</code> 分别表示 <code>grid</code> 的行数和列数。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode周赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 题解 </tag>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录 LeetCode 第 294 场周赛</title>
      <link href="/2022/LC-WeeklyContext-294/"/>
      <url>/2022/LC-WeeklyContext-294/</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p><a href="https://leetcode.cn/contest/weekly-contest-294/">本次周赛</a>依旧只写出前三题，第四题只想到时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的方法。最可惜的是第三题，很简单的题目却花了很长时间。</p></div><h2 id="战局详情-2">战局详情</h2><table><thead><tr><th>排名</th><th>用户名</th><th>得分</th><th>完成时间</th><th>题目1（3）</th><th>题目2（4）</th><th>题目3（5）</th><th>题目4（6）</th></tr></thead><tbody><tr><td>1895 / 6640</td><td>Juruoer</td><td>12</td><td>1:04:41</td><td>0:02:34</td><td>0:10:05</td><td>0:54:41 <i class="fa-solid fa-bug"></i> 2</td><td></td></tr></tbody></table><h2 id="题目及解答-3">题目及解答</h2><div class="tabs" id="problems"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#problems-1">题目1</button></li><li class="tab"><button type="button" data-href="#problems-2">题目2</button></li><li class="tab"><button type="button" data-href="#problems-3">题目3</button></li><li class="tab"><button type="button" data-href="#problems-4">题目4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="problems-1"><details class="folding-tag" ><summary> 字母在字符串中的百分比 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/percentage-of-letter-in-string/">6074. 字母在字符串中的百分比</a></p><p>给你一个字符串 <code>s</code> 和一个字符 <code>letter</code> ，返回在 <code>s</code> 中等于 <code>letter</code> 字符所占的 <strong>百分比</strong> ，向下取整到最接近的百分比。</p><div class="note info flat"><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 由小写英文字母组成</li><li><code>letter</code> 是一个小写英文字母</li></ul></div><div class="note primary flat"><p>示例一：</p><p>输入：s = “foobar”, letter = “o”<br>输出：33<br>解释：<br>等于字母 ‘o’ 的字符在 s 中占到的百分比是 2 / 6 * 100% = 33% ，向下取整，所以返回 33 。</p></div><div class="note primary flat"><p>示例二：</p><p>输入：s = “jjjj”, letter = “k”<br>输出：0<br>解释：<br>等于字母 ‘k’ 的字符在 s 中占到的百分比是 0% ，所以返回 0 。</p></div>              </div>            </details><p>解决方案：</p><p>统计出字符 <code>letter</code> 的个数即可。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">percentageLetter</span><span class="params">(string s, <span class="type">char</span> letter)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s)</span><br><span class="line">            <span class="keyword">if</span>(c == letter)</span><br><span class="line">                ++cnt;</span><br><span class="line">        <span class="keyword">return</span> cnt * <span class="number">100</span> / s.<span class="built_in">length</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，其中 <code>n</code> 表示 <code>s</code> 的字符数。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-2"><details class="folding-tag" ><summary> 装满石头的背包的最大数量 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/maximum-bags-with-full-capacity-of-rocks/">6075. 装满石头的背包的最大数量</a></p><p>现有编号从 <code>0</code> 到 <code>n - 1</code> 的 <code>n</code> 个背包。给你两个下标从 <strong>0</strong> 开始的整数数组 <code>capacity</code> 和 <code>rocks</code> 。第 <code>i</code> 个背包最大可以装 <code>capacity[i]</code> 块石头，当前已经装了 <code>rocks[i]</code> 块石头。另给你一个整数 <code>additionalRocks</code> ，表示你可以放置的额外石头数量，石头可以往 <strong>任意</strong> 背包中放置。</p><p>请你将额外的石头放入一些背包中，并返回放置后装满石头的背包的 <strong>最大</strong> 数量。</p><div class="note info flat"><p>提示：</p><ul><li><code>n == capacity.length == rocks.length</code></li><li><code>1 &lt;= n &lt;= 5 * 1e4</code></li><li><code>1 &lt;= capacity[i] &lt;= 1e9</code></li><li><code>0 &lt;= rocks[i] &lt;= capacity[i]</code></li><li><code>1 &lt;= additionalRocks &lt;= 1e9</code></li></ul></div><div class="note primary flat"><p>示例一：</p><p>输入：capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2<br>输出：3<br>解释：<br>1 块石头放入背包 0 ，1 块石头放入背包 1 。<br>每个背包中的石头总数是 [2,3,4,4] 。<br>背包 0 、背包 1 和 背包 2 都装满石头。<br>总计 3 个背包装满石头，所以返回 3 。<br>可以证明不存在超过 3 个背包装满石头的情况。<br>注意，可能存在其他放置石头的方案同样能够得到 3 这个结果。</p></div><div class="note primary flat"><p>示例二：</p><p>输入：capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100<br>输出：3<br>解释：<br>8 块石头放入背包 0 ，2 块石头放入背包 2 。<br>每个背包中的石头总数是 [10,2,2] 。<br>背包 0 、背包 1 和背包 2 都装满石头。<br>总计 3 个背包装满石头，所以返回 3 。<br>可以证明不存在超过 3 个背包装满石头的情况。<br>注意，不必用完所有的额外石头。</p></div>              </div>            </details><p>解决方案：</p><p>先统计出每个背包还需要多少块石头才能将背包装满，当额外的石头还足够时，优先装满需要石头数少的背包。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumBags</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;capacity, vector&lt;<span class="type">int</span>&gt; &amp;rocks, <span class="type">int</span> additionalRocks)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i, n = capacity.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">needs</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            needs[i] = capacity[i] - rocks[i];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sort</span>(needs.<span class="built_in">begin</span>(), needs.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> rst = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(additionalRocks &gt;= needs[i])</span><br><span class="line">            &#123;</span><br><span class="line">                ++rst;</span><br><span class="line">                additionalRocks -= needs[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> rst;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span>，空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中 <code>n</code> 表示数组 <code>capacity</code> 的长度。也可以不需要 <code>need</code> 数组，重复利用 <code>capacity</code> 数组或 <code>rocks</code> 数组来代替 <code>need</code>，此时空间复杂度降为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-3"><details class="folding-tag" ><summary> 表示一个折线图的最少线段数 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/minimum-lines-to-represent-a-line-chart/">6076. 表示一个折线图的最少线段数</a></p><p>给你一个二维整数数组 <code>stockPrices</code> ，其中 <code>stockPrices[i] = [dayi, pricei]</code> 表示股票在 <code>dayi</code> 的价格为 <code>pricei</code> 。折线图 是一个二维平面上的若干个点组成的图，横坐标表示日期，纵坐标表示价格，折线图由相邻的点连接而成。比方说下图是一个例子：</p><img src = "https://assets.leetcode.com/uploads/2022/03/30/1920px-pushkin_population_historysvg.png" alt = "折线图示例"><p>请你返回要表示一个折线图所需要的 <strong>最少线段数</strong> 。</p><div class="note info flat"><p>提示：</p><ul><li><code>1 &lt;= stockPrices.length &lt;= 1e5</code></li><li><code>stockPrices[i].length == 2</code></li><li><code>1 &lt;= dayi, pricei &lt;= 1e9</code></li><li>所有 <code>dayi</code> 互不相同 。</li></ul></div><div class="note primary flat"><p>示例一：</p><img src = "https://assets.leetcode.com/uploads/2022/03/30/ex0.png" alt = "示例 1 图"><p>输入：stockPrices = [[1,7],[2,6],[3,5],[4,4],[5,4],[6,3],[7,2],[8,1]]<br>输出：3<br>解释：<br>上图为输入对应的图，横坐标表示日期，纵坐标表示价格。<br>以下 3 个线段可以表示折线图：</p><ul><li>线段 1 （红色）从 (1,7) 到 (4,4) ，经过 (1,7) ，(2,6) ，(3,5) 和 (4,4) 。</li><li>线段 2 （蓝色）从 (4,4) 到 (5,4) 。</li><li>线段 3 （绿色）从 (5,4) 到 (8,1) ，经过 (5,4) ，(6,3) ，(7,2) 和 (8,1) 。</li></ul><p>可以证明，无法用少于 3 条线段表示这个折线图。</p></div><div class="note primary flat"><p>示例二：</p><img src = "https://assets.leetcode.com/uploads/2022/03/30/ex1.png" alt = "示例 2 图"><p>输入：stockPrices = [[3,4],[1,2],[7,8],[2,3]]<br>输出：1<br>解释：<br>如上图所示，折线图可以用一条线段表示。</p></div>              </div>            </details><p>解决方案：</p><p>先将所有点按 x 轴从左到右排序（即按照日期从小到大排序），然后从第三个点开始计算该点与该点左边的两个点是否共线，若共线则该点与前两点在同一线段上，否则该点与左边的一个点形成一条新的线段。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumLines</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;stockPrices)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = stockPrices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="comment">// 自有一个点，无法形成线段</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将所有点按 x 轴从左到右排序（即按照日期从小到大排序）</span></span><br><span class="line">        <span class="built_in">sort</span>(stockPrices.<span class="built_in">begin</span>(), stockPrices.<span class="built_in">end</span>(), [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;b)</span><br><span class="line">             &#123; <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>; <span class="comment">// 第一个点与第二个点形成的线段</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从第三个点开始计算是否有新的线段</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 设 stockPrices[i - 2] 为点 p(px, py)，stockPrices[i - 1] 为点 q(qx, qy)，stockPrices[i] 为点 r(rx, ry)</span></span><br><span class="line">            <span class="comment">// p、q、r 共线即 pq、qr 斜率相等，即：</span></span><br><span class="line">            <span class="comment">// (Δy / Δx == Δ_y / Δ_x) ==&gt; (Δy * Δ_x == Δ_y * Δx)</span></span><br><span class="line">            <span class="comment">// 其中 Δx = rx - qx, Δy = ry - qy, Δ_x = qx - px, Δ_y = qy - py</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">1LL</span> * (stockPrices[i][<span class="number">1</span>] - stockPrices[i - <span class="number">1</span>][<span class="number">1</span>]) * (stockPrices[i - <span class="number">1</span>][<span class="number">0</span>] - stockPrices[i - <span class="number">2</span>][<span class="number">0</span>]) != <span class="number">1LL</span> * (stockPrices[i - <span class="number">1</span>][<span class="number">1</span>] - stockPrices[i - <span class="number">2</span>][<span class="number">1</span>]) * (stockPrices[i][<span class="number">0</span>] - stockPrices[i - <span class="number">1</span>][<span class="number">0</span>]))</span><br><span class="line">                ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span>，空间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，其中 <code>n</code> 表示数组 <code>stockPrices</code> 的长度。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-4"><details class="folding-tag" ><summary> 巫师的总力量和 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/sum-of-total-strength-of-wizards/">6077. 巫师的总力量和</a></p><p>作为国王的统治者，你有一支巫师军队听你指挥。</p><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>strength</code> ，其中 <code>strength[i]</code> 表示第 <code>i</code> 位巫师的力量值。对于连续的一组巫师（也就是这些巫师的力量值是 <code>strength</code> 的 <strong>子数组</strong>），<strong>总力量</strong> 定义为以下两个值的 <strong>乘积</strong> ：</p><ul><li>巫师中 <strong>最弱</strong> 的能力值。</li><li>组中所有巫师的个人力量值 <strong>之和</strong> 。</li></ul><p>请你返回 <strong>所有</strong> 巫师组的 <strong>总</strong> 力量之和。由于答案可能很大，请将答案对 <code>1e9 + 7</code> <strong>取余</strong> 后返回。</p><p><strong>子数组</strong> 是一个数组里 <strong>非空</strong> 连续子序列。</p><div class="note info flat"><p>提示：</p><ul><li><code>1 &lt;= strength.length &lt;= 1e5</code></li><li><code>1 &lt;= strength[i] &lt;= 1e9</code></li></ul></div><div class="note primary flat"><p>示例一：</p><p>输入：strength = [1,3,1,2]<br>输出：44<br>解释：以下是所有连续巫师组：</p><ul><li>[1,3,1,2] 中 [1] ，总力量值为 min([1]) * sum([1]) = 1 * 1 = 1</li><li>[1,3,1,2] 中 [3] ，总力量值为 min([3]) * sum([3]) = 3 * 3 = 9</li><li>[1,3,1,2] 中 [1] ，总力量值为 min([1]) * sum([1]) = 1 * 1 = 1</li><li>[1,3,1,2] 中 [2] ，总力量值为 min([2]) * sum([2]) = 2 * 2 = 4</li><li>[1,3,1,2] 中 [1,3] ，总力量值为 min([1,3]) * sum([1,3]) = 1 * 4 = 4</li><li>[1,3,1,2] 中 [3,1] ，总力量值为 min([3,1]) * sum([3,1]) = 1 * 4 = 4</li><li>[1,3,1,2] 中 [1,2] ，总力量值为 min([1,2]) * sum([1,2]) = 1 * 3 = 3</li><li>[1,3,1,2] 中 [1,3,1] ，总力量值为 min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5</li><li>[1,3,1,2] 中 [3,1,2] ，总力量值为 min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6</li><li>[1,3,1,2] 中 [1,3,1,2] ，总力量值为 min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7</li></ul><p>所有力量值之和为 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44 。</p></div><div class="note primary flat"><p>示例二：</p><p>输入：strength = [5,4,6]<br>输出：213<br>解释：以下是所有连续巫师组：</p><ul><li>[5,4,6] 中 [5] ，总力量值为 min([5]) * sum([5]) = 5 * 5 = 25</li><li>[5,4,6] 中 [4] ，总力量值为 min([4]) * sum([4]) = 4 * 4 = 16</li><li>[5,4,6] 中 [6] ，总力量值为 min([6]) * sum([6]) = 6 * 6 = 36</li><li>[5,4,6] 中 [5,4] ，总力量值为 min([5,4]) * sum([5,4]) = 4 * 9 = 36</li><li>[5,4,6] 中 [4,6] ，总力量值为 min([4,6]) * sum([4,6]) = 4 * 10 = 40</li><li>[5,4,6] 中 [5,4,6] ，总力量值为 min([5,4,6]) * sum([5,4,6]) = 4 * 15 = 60</li></ul><p>所有力量值之和为 25 + 16 + 36 + 36 + 40 + 60 = 213 。</p></div>              </div>            </details><p>解决方案：</p><p>一、暴力穷举</p><p>设数组 <code>strength</code> 的长度为 <code>n</code>，则该数组共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>n</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>=</mo><mfrac><mrow><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mi>n</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\sum_{i=1}^n n - i + 1 = \frac{n^2 + n}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3629em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0179em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 个子序列（长度为 <code>i</code> 的子序列有 <code>n - i + 1</code> 个），对每个子序列求和及最小值需要遍历该子序列，则时间复杂度为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo fence="false" stretchy="true" minsize="2.4em" maxsize="2.4em">(</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><mi>i</mi><mo>⋅</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo><mo fence="false" stretchy="true" minsize="2.4em" maxsize="2.4em">)</mo><mo>=</mo><mi>O</mi><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><mfrac><mrow><msup><mi>n</mi><mn>3</mn></msup><mo>+</mo><mn>3</mn><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>n</mi></mrow><mn>6</mn></mfrac><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O \bigg ( \sum_{i=1}^n \big (i \cdot (n - i + 1) \big ) \bigg ) = O \big ( \frac{n^3 + 3n^2 + 2n}6 \big ) = O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord"><span class="delimsizing size3">(</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord"><span class="delimsizing size1">)</span></span><span class="mord"><span class="delimsizing size3">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1771em;vertical-align:-0.686em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4911em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="delimsizing size1">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>显然时间复杂度过高，必然 TLE。</p><p>优化方法：假设我们已经计算出了长度为 <code>s</code> 的所有子序列的和及最小值，则计算长度为 <code>s + 1</code> 的子数组的和及最小值时不需要重新遍历这些子序列，可以由之前的结果来推导。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalStrength</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;strength)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i, n = strength.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> rst = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n); <span class="comment">// 由于存储各子序列的长度和最小值</span></span><br><span class="line">        <span class="comment">// 计算长度为 1 的所有子序列的和及最小值并存储在 dp 中</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; strength.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = <span class="built_in">make_pair</span>(strength[i], strength[i]);</span><br><span class="line">            rst = (rst + dp[i].first * dp[i].second) % p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 利用 dp 计算长度为 s 的所有子序列的和及最小值并存储在 dp[s - 1] ~ dp[n - 1] 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">2</span>; s &lt;= n; ++s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 长度为 s 的子序列 sub 的和即 以相同的下标（设为 i）结束的 长度为 s - 1 的子序列 _sub 的和 加上 strength[i - s + 1]，而最小值即 _sub 的最小值和 streng[i - s + 1] 的最小值。</span></span><br><span class="line">            <span class="keyword">for</span> (i = s - <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i].first += strength[i + <span class="number">1</span> - s];</span><br><span class="line">                dp[i].second = <span class="built_in">min</span>(dp[i].second, strength[i + <span class="number">1</span> - s]);</span><br><span class="line">                rst = (rst + dp[i].first * dp[i].second) % p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度降低为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n ^ 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，但仍然 TLE。</p><p>二、单调栈 + 前缀和</p><p>参照 <a href="https://leetcode.cn/u/endlesscheng/">灵茶山艾府</a> 大佬的 <a href="https://leetcode.cn/problems/sum-of-total-strength-of-wizards/solution/dan-diao-zhan-qian-zhui-he-de-qian-zhui-d9nki/">题解</a>。</p><p>本题与 <a href="https://leetcode.cn/">LeetCode</a> 上的 <a href="https://leetcode.cn/problems/sum-of-subarray-minimums/">907. 子数组的最小值之和</a> 类似，可以先求出以数组中某个元素 <code>strength[i]</code> 为 <strong>最小值</strong> 的所有子序列的下标范围 <code>[left, right]</code>，即在 <code>strength[left ~ right]</code> 范围内所有含有 <code>strength[i]</code>（值相同不行，必须是下标为 i）的子序列的最小值均为 <code>strength[i]</code>。为了避免 <code>strength[i] = strength[j]</code> 而导致的范围的重叠，定义当 <code>i &gt; left</code> 时，<code>strength[left ~ i - 1]</code> 的所有值 <strong>严格小于</strong> <code>strength[i]</code>；当 <code>i &lt; right</code> 时，<code>strength[i + 1 ~ right]</code> 的所有值 <strong>小于等于</strong> <code>strength[i]</code>。</p><p>该范围的简单的计算方法是：对于 <code>strength[i]</code>，找到其左边最后一个大于等于它的值的下标 <code>l</code>，则 <code>left = l + 1</code>；再找到其右边第一个大于它的值的下标 <code>r</code>，则 <code>right = r - 1</code>，但此时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n ^ 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>可以使用一个单调递增栈 st 优化计算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算以 strength[i] 为最小值的子序列的区间 [left, right]</span></span><br><span class="line"><span class="type">int</span> i, n = strength.<span class="built_in">size</span>();</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n)</span></span>; <span class="comment">// 以 strength[i] 为最小值的子序列的最左边界</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(n, n - <span class="number">1</span>)</span></span>; <span class="comment">// 以 strength[i] 为最小值的子序列的最右边界</span></span><br><span class="line">st.<span class="built_in">push</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (st.<span class="built_in">top</span>() != <span class="number">-1</span> &amp;&amp; strength[i] &lt; strength[st.<span class="built_in">top</span>()])</span><br><span class="line">    &#123;</span><br><span class="line">        right[st.<span class="built_in">top</span>()] = i - <span class="number">1</span>;</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    left[i] = st.<span class="built_in">top</span>() + <span class="number">1</span>;</span><br><span class="line">    st.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为每一个元素只入栈和出栈一次，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><div class="note info flat"><p>对于 <code>strength[i]</code> ，其对最终结果产生的贡献为：<code>strength[i]</code> 乘以 <code>strength[left[i] ~ right[i]]</code> 范围内所有含有 <code>strength[i]</code>（必须是该下标值） 的子序列的和的和。</p></div><p>设 <code>strength</code> 的前缀和为 <code>sum</code>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">sum[i] = \sum_{j=0}^{i-1} strength[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4004em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9646em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">re</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>，故子数组 <code>[l, r]</code> 的元素和为 <code>sum[r + 1] - sum[l]</code>。</p><p>设 <code>sum</code> 的前缀和为 <code>ssum</code>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">ssum[i] = \sum_{j=0}^{i-1}sum[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ss</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4004em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9646em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>，故 <code>sum[L ~ R]</code> 的和为 <code>ssum[R + 1] - ssum[L]</code>。</p><p>则 <code>strength[left[i] ~ right[i]]</code> （方便期间，令 L = left[i]，R = right[i]）范围内所有含有 <code>strength[i]</code>（必须是该下标值） 的子序列的和的和可以表示为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><munderover><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mi>L</mi></mrow><mi>i</mi></munderover><munderover><mo>∑</mo><mrow><mi>r</mi><mo>=</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>R</mi><mo>+</mo><mn>1</mn></mrow></munderover><mo stretchy="false">(</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>r</mi><mo stretchy="false">]</mo><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>l</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mi>L</mi></mrow><mi>i</mi></munderover><mo fence="false" stretchy="true" minsize="2.4em" maxsize="2.4em">(</mo><munderover><mo>∑</mo><mrow><mi>r</mi><mo>=</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>R</mi><mo>+</mo><mn>1</mn></mrow></munderover><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>r</mi><mo stretchy="false">]</mo><mo>−</mo><mo stretchy="false">(</mo><mi>R</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>⋅</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>l</mi><mo stretchy="false">]</mo><mo fence="false" stretchy="true" minsize="2.4em" maxsize="2.4em">)</mo></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mi>L</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>⋅</mo><munderover><mo>∑</mo><mrow><mi>r</mi><mo>=</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>R</mi><mo>+</mo><mn>1</mn></mrow></munderover><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>r</mi><mo stretchy="false">]</mo><mo>−</mo><mo stretchy="false">(</mo><mi>R</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>⋅</mo><munderover><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><mi>i</mi></munderover><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>l</mi><mo stretchy="false">]</mo></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mi>L</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mi>s</mi><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>R</mi><mo>+</mo><mn>2</mn><mo stretchy="false">]</mo><mo>−</mo><mi>s</mi><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">(</mo><mi>R</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mi>s</mi><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo>−</mo><mi>s</mi><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>L</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align}\sum_{l=L}^{i} \sum_{r=i+1}^{R+1}(sum[r]-sum[l]) &amp;= \sum_{l=L}^{i} \bigg ( \sum_{r=i+1}^{R+1}sum[r] - (R - i + 1) \cdot sum[l] \bigg )\\&amp;= (i - L + 1) \cdot \sum_{r=i+1}^{R+1}sum[r] - (R - i + 1) \cdot \sum_{l=left[i]}^{i}sum[l]\\&amp;= (i - L + 1) \cdot (ssum[R+2] - ssum[i+1]) - (R - i + 1) \cdot (ssum[i+1] - ssum[L])\end{align}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:8.6087em;vertical-align:-4.0543em;"></span><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.5543em;"><span style="top:-6.5543em;"><span class="pstrut" style="height:3.8283em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8117em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight">L</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.336em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">])</span></span></span><span style="top:-3.09em;"><span class="pstrut" style="height:3.8283em;"></span><span class="mord"></span></span><span style="top:-0.434em;"><span class="pstrut" style="height:3.8283em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:4.0543em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.5543em;"><span style="top:-6.5543em;"><span class="pstrut" style="height:3.8283em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8117em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight">L</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="delimsizing size3">(</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.336em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mord"><span class="delimsizing size3">)</span></span></span></span><span style="top:-3.09em;"><span class="pstrut" style="height:3.8283em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.336em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8117em;"><span style="top:-1.809em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">t</span><span class="mopen mtight">[</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">]</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">]</span></span></span><span style="top:-0.434em;"><span class="pstrut" style="height:3.8283em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal">ss</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">ss</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">])</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal">ss</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">ss</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal">L</span><span class="mclose">])</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:4.0543em;"><span></span></span></span></span></span></span></span><span class="tag"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.5543em;"><span style="top:-6.5543em;"><span class="pstrut" style="height:3.8283em;"></span><span class="eqn-num"></span></span><span style="top:-3.09em;"><span class="pstrut" style="height:3.8283em;"></span><span class="eqn-num"></span></span><span style="top:-0.434em;"><span class="pstrut" style="height:3.8283em;"></span><span class="eqn-num"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:4.0543em;"><span></span></span></span></span></span></span></span></span></p><p>计算出所有元素的贡献并累加即为答案。</p><p>最终代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalStrength</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;strength)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i, n = strength.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> rst = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0L</span>; <span class="comment">// strength的前缀和</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ssum</span><span class="params">(n + <span class="number">2</span>)</span></span>; <span class="comment">// strength 的前缀和的前缀和</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += strength[i - <span class="number">1</span>];</span><br><span class="line">            ssum[i + <span class="number">1</span>] = (ssum[i] + sum) % p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算以 strength[i] 为最小值的子序列的区间 [left, right]</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n)</span></span>; <span class="comment">// 以 strength[i] 为最小值的子序列的最左边界</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(n, n - <span class="number">1</span>)</span></span>; <span class="comment">// 以 strength[i] 为最小值的子序列的最右边界</span></span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (st.<span class="built_in">top</span>() != <span class="number">-1</span> &amp;&amp; strength[i] &lt; strength[st.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                right[st.<span class="built_in">top</span>()] = i - <span class="number">1</span>;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            left[i] = st.<span class="built_in">top</span>() + <span class="number">1</span>;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算 streng[i] 对结果的贡献，并求和</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> t = (<span class="number">1LL</span> * (i - left[i] + <span class="number">1</span>) * (ssum[right[i] + <span class="number">2</span>] - ssum[i + <span class="number">1</span>]) - <span class="number">1LL</span> * (right[i] - i + <span class="number">1</span>) * (ssum[i + <span class="number">1</span>] - ssum[left[i]])) % p;</span><br><span class="line">            rst = (rst + strength[i] * t) % p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 防止 rst 为负数（t 的计算含有减号）</span></span><br><span class="line">        <span class="keyword">return</span> (rst + p) % p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode周赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 题解 </tag>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录 LeetCode 第 293 场周赛</title>
      <link href="/2022/LC-WeeklyContext-293/"/>
      <url>/2022/LC-WeeklyContext-293/</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p><a href="https://leetcode.cn/contest/weekly-contest-293/">本次周赛</a>不负众望<s>的菜</s>，写出三题（应该能上分），第四题在最后十几分钟想到一点思路了，但是对于合并区间还没有很明确的想法，码了一会感觉有点麻烦就没继续写了<s>没吃早饭，当时肚子好饿</s>。</p></div><h2 id="战局详情：">战局详情：</h2><table><thead><tr><th>排名</th><th>用户名</th><th>得分</th><th>完成时间</th><th>题目1（3）</th><th>题目2（4）</th><th>题目3（5）</th><th>题目4（7）</th></tr></thead><tbody><tr><td>1930/7356</td><td>Juruoer</td><td>12</td><td>0:54:04</td><td>0:14:17</td><td>0:20:47</td><td>0:54:04</td><td></td></tr></tbody></table><h2 id="题目及解答-2">题目及解答</h2><div class="tabs" id="problems"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#problems-1">题目1</button></li><li class="tab"><button type="button" data-href="#problems-2">题目2</button></li><li class="tab"><button type="button" data-href="#problems-3">题目3</button></li><li class="tab"><button type="button" data-href="#problems-4">题目4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="problems-1"><details class="folding-tag" ><summary> 移除字母异位词后的结果数组 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/find-resultant-array-after-removing-anagrams/">5234. 移除字母异位词后的结果数组</a></p><p>给你一个下标从 0 开始的字符串 <code>words</code> ，其中 <code>words[i]</code> 由小写英文字符组成。</p><p>在一步操作中，需要选出任一下标 <code>i</code> ，从 <code>words</code> 中 删除 <code>words[i]</code> 。其中下标 <code>i</code> 需要同时满足下述两个条件：</p><ol><li><code>0 &lt; i &lt; words.length</code></li><li><code>words[i - 1]</code> 和 <code>words[i]</code> 是 <strong>字母异位词</strong> 。</li></ol><p>只要可以选出满足条件的下标，就一直执行这个操作。</p><p>在执行所有操作后，返回 <code>words</code> 。可以证明，按任意顺序为每步操作选择下标都会得到相同的结果。</p><p><strong>字母异位词</strong> 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。例如，<code>&quot;dacb&quot;</code> 是 <code>&quot;abdc&quot;</code> 的一个字母异位词。</p><div class="note info flat"><p>提示：</p><ol><li><code>1 &lt;= words.length &lt;= 100</code></li><li><code>1 &lt;= words[i].length &lt;= 10</code></li><li><code>words[i]</code> 由小写英文字母组成</li></ol></div><div class="note primary flat"><p>示例一：<br>输入：words = [“abba”,“baba”,“bbaa”,“cd”,“cd”]<br>输出：[“abba”,“cd”]<br>解释：<br>获取结果数组的方法之一是执行下述步骤：</p><ul><li>由于 words[2] = “bbaa” 和 words[1] = “baba” 是字母异位词，选择下标 2 并删除 words[2] 。<br>现在 words = [“abba”,“baba”,“cd”,“cd”] 。</li><li>由于 words[1] = “baba” 和 words[0] = “abba” 是字母异位词，选择下标 1 并删除 words[1] 。<br>现在 words = [“abba”,“cd”,“cd”] 。</li><li>由于 words[2] = “cd” 和 words[1] = “cd” 是字母异位词，选择下标 2 并删除 words[2] 。<br>现在 words = [“abba”,“cd”] 。</li></ul><p>无法再执行任何操作，所以 [“abba”,“cd”] 是最终答案。</p></div><div class="note primary flat"><p>示例二：<br>输入：words = [“a”,“b”,“c”,“d”,“e”]<br>输出：[“a”,“b”,“c”,“d”,“e”]<br>解释：<br>words 中不存在互为字母异位词的两个相邻字符串，所以无需执行任何操作。</p></div>              </div>            </details><p>解决方案：</p><p>既然已经证明：按任意顺序为每步操作选择下标都会得到相同的结果，那么只需要自左向右遍历一遍数组，对于一个新的元素，比较其和结果集中的当前最后一个元素是否是字母异位词，若是，则跳过该元素，否则加入结果集。</p><p>如何判断两字符串是否为字母异位词？</p><ul><li>方法一：统计字符串的每个字符个数，若两字符串每个字符的个数都相等，则为字母异位词，即我下面最终代码使用的方法</li><li>方法二：将每个字符串的字符按字母序排序，形成一个新的字符串数组，新的字符串数组中相同的两个字符串，其原字符串即为字母异位词：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; _words = words;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; _words.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    <span class="built_in">sort</span>(_words[i].<span class="built_in">begin</span>(), _words[i].<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">// 此时若 _words[i] == _words[j], 则 words[i] 和 words[j] 互为字母异位词</span></span><br></pre></td></tr></table></figure></li></ul><p>最终代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">removeAnagrams</span><span class="params">(vector&lt;string&gt; &amp;words)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;string&gt; rst; <span class="comment">// 结果集</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">cnts</span>(words.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); ++i) <span class="comment">// 统计字符串的每个字符个数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; words[i].<span class="built_in">length</span>(); ++j)</span><br><span class="line">                ++cnts[i][words[i][j] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        rst.<span class="built_in">emplace_back</span>(words[<span class="number">0</span>]);</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; words.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123; <span class="comment">// i 为当前遍历到的元素在words中的下标，j为结果集的当前最后一个元素在words中的下标</span></span><br><span class="line">            <span class="keyword">if</span>(cnts[i] == cnts[j]) <span class="comment">// 两字符串的每个字符个数相等，为字母异位词，跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            rst.<span class="built_in">emplace_back</span>(words[i]); <span class="comment">// 否则加入结果集</span></span><br><span class="line">            j = i; <span class="comment">// 更新结果集的当前最后一个元素在words中的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-2"><details class="folding-tag" ><summary> 不含特殊楼层的最大连续楼层数 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/maximum-consecutive-floors-without-special-floors/">6064. 不含特殊楼层的最大连续楼层数</a></p><p>Alice 管理着一家公司，并租用大楼的部分楼层作为办公空间。Alice 决定将一些楼层作为 <strong>特殊楼层</strong> ，仅用于放松。</p><p>给你两个整数 <code>bottom</code> 和 <code>top</code> ，表示 Alice 租用了从 <code>bottom</code> 到 <code>top</code>（含 <code>bottom</code> 和 <code>top</code> 在内）的所有楼层。另给你一个整数数组 <code>special</code> ，其中 <code>special[i]</code> 表示  Alice 指定用于放松的特殊楼层。</p><p>返回不含特殊楼层的 <strong>最大</strong> 连续楼层数。</p><div class="note info flat"><p>提示：</p><ol><li><code>1 &lt;= special.length &lt;= 1e5</code></li><li><code>1 &lt;= bottom &lt;= special[i] &lt;= top &lt;= 1e9</code></li><li><code>special[i]</code> 中的所有值 <strong>互不相同</strong></li></ol></div><div class="note primary flat"><p>示例一：<br>输入：bottom = 2, top = 9, special = [4,6]<br>输出：3<br>解释：下面列出的是不含特殊楼层的连续楼层范围：</p><ul><li>(2, 3) ，楼层数为 2 。</li><li>(5, 5) ，楼层数为 1 。</li><li>(7, 9) ，楼层数为 3 。</li></ul><p>因此，返回最大连续楼层数 3 。</p></div><div class="note primary flat"><p>示例二：<br>输入：bottom = 6, top = 8, special = [7,6,8]<br>输出：0<br>解释：每层楼都被规划为特殊楼层，所以返回 0 。</p></div>              </div>            </details><p>解决方案：</p><p>先对 <code>special</code> 排序，然后求出 <code>special</code> 中相邻两个元素的差值最大值即可。</p><p>对 <code>bottom</code> 和 <code>top</code> 进行特殊处理，以计算出 第一个连续不含特殊楼层和最后一个连续不含特殊楼层楼的层数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxConsecutive</span><span class="params">(<span class="type">int</span> bottom, <span class="type">int</span> top, vector&lt;<span class="type">int</span>&gt; &amp;special)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = special.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(special.<span class="built_in">begin</span>(), special.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> rst = <span class="built_in">max</span>(special[<span class="number">0</span>] - bottom, top - special[n - <span class="number">1</span>]); <span class="comment">// 第一个连续不含特殊楼层和最后一个连续不含特殊楼层楼层数的最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="comment">// 计算其他连续不含特殊楼层层数，求出最大值</span></span><br><span class="line">            rst = <span class="built_in">max</span>(rst, special[i] - special[i - <span class="number">1</span>] - <span class="number">1</span>); <span class="comment">// 两特殊楼层之间的楼层数</span></span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者假设存在 <code>bottom - 1</code> 层和 <code>top + 1</code> 层，并且都是特殊楼层，则无需对 <code>bottom</code> 和 <code>top</code> 特殊处理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxConsecutive</span><span class="params">(<span class="type">int</span> bottom, <span class="type">int</span> top, vector&lt;<span class="type">int</span>&gt; &amp;special)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        special.<span class="built_in">emplace_back</span>(bottom - <span class="number">1</span>); <span class="comment">// 假设bottom - 1 层和 top + 1 层为特殊楼层</span></span><br><span class="line">        special.<span class="built_in">emplace_back</span>(top + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> n = special.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(special.<span class="built_in">begin</span>(), special.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> rst = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            rst = <span class="built_in">max</span>(rst, special[i] - special[i - <span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-3"><details class="folding-tag" ><summary> 按位与结果大于零的最长组合 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/largest-combination-with-bitwise-and-greater-than-zero//">6065. 按位与结果大于零的最长组合</a></p><p>对数组 <code>nums</code> 执行 <strong>按位与</strong> 相当于对数组 <code>nums</code> 中的所有整数执行 <strong>按位与</strong> 。</p><ul><li>例如，对 <code>nums = [1, 5, 3]</code> 来说，按位与等于 <code>1 &amp; 5 &amp; 3 = 1</code> 。</li><li>同样，对 <code>nums = [7]</code> 而言，按位与等于 <code>7</code> 。</li></ul><p>给你一个正整数数组 <code>candidates</code> 。计算 <code>candidates</code> 中的数字每种组合下 <strong>按位与</strong> 的结果。 <code>candidates</code> 中的每个数字在每种组合中只能使用 <strong>一次</strong> 。</p><p>返回按位与结果大于 <code>0</code> 的 <strong>最长</strong> 组合的长度。</p><div class="note info flat"><p>提示：</p><ol><li><code>1 &lt;= candidates.length &lt;= 1e5</code></li><li><code>1 &lt;= candidates[i] &lt;= 1e7</code></li></ol></div><div class="note primary flat"><p>示例一：<br>输入：candidates = [16,17,71,62,12,24,14]<br>输出：4<br>解释：组合 [16,17,62,24] 的按位与结果是 16 &amp; 17 &amp; 62 &amp; 24 = 16 &gt; 0 。<br>组合长度是 4 。<br>可以证明不存在按位与结果大于 0 且长度大于 4 的组合。<br>注意，符合长度最大的组合可能不止一种。<br>例如，组合 [62,12,24,14] 的按位与结果是 62 &amp; 12 &amp; 24 &amp; 14 = 8 &gt; 0 。</p></div><div class="note primary flat"><p>示例二：<br>输入：candidates = [8,8]<br>输出：2<br>解释：最长组合是 [8,8] ，按位与结果 8 &amp; 8 = 8 &gt; 0 。<br>组合长度是 2 ，所以返回 2 。</p></div>              </div>            </details><p>解决方案：</p><p>由按位与的特性，可以知道，若 数集{x} 所有数按位与的结果大于 <code>0</code> ，则至少存在一个下标 <code>i</code> ，该 数集{x} 的所有数字的二进制在此下标处均为 <code>1</code> 。则只需要找出数组 <code>candidates</code> 中所有数的二进制为 <code>1</code> 的位，并找出含 <code>1</code> 的数字最多的位（表达能力不太好，写的有点绕，看下面表格即可明白）。</p><p>例如对示例一所有数有：</p><table><thead><tr><th>十进制</th><th>二进制（此处仅展示后8位）</th></tr></thead><tbody><tr><td>16</td><td>0001 0000</td></tr><tr><td>17</td><td>0001 0001</td></tr><tr><td>71</td><td>0100 0111</td></tr><tr><td>62</td><td>0011 1110</td></tr><tr><td>12</td><td>0000 1100</td></tr><tr><td>24</td><td>0001 1000</td></tr><tr><td>14</td><td>0000 1110</td></tr><tr><td>总计各位为1的数字个数</td><td>0114 4432</td></tr></tbody></table><p>可知 <code>1</code> 的个数最多的位（自右向左，自0开始）有第2位、第3位、第4位，均含有4个此位为1的数字，分别为：</p><ul><li>第2为为1的数：71、62、12、14</li><li>第3为为1的数：62、12、24、14</li><li>第4为为1的数：16、17、62、24</li></ul><p>故只需要定义一个数组 <code>cnts</code> ，<code>cnts[i]</code> 表示 <code>candidates</code> 中二进制第 <code>i</code> 位为 <code>1</code> 的数字个数，则 <code>cnts</code> 的最大值即为所求答案。</p><p>定义一个整数数组 <code>t</code> ，且 <code>t[i]</code> 的二进制仅在第 <code>i</code> 位为 <code>1</code> ，其他位为 <code>0</code>，随后遍历数组 <code>candidates</code>，若 <code>candidates[i] &amp; t[j] == 1</code> ，则说明 <code>candidates[i]</code> 的二进制在第 <code>j</code> 位为 <code>1</code>，需要 <code>++cnts[j];</code> 。</p><p>可以写出代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestCombination</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;candidates)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnts</span><span class="params">(<span class="number">24</span>)</span></span>; <span class="comment">// 1 &lt;= candidates[i] &lt;= 1e7，此范围内所有数的二进制只可能后 24 个位为 1。</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">t</span><span class="params">(<span class="number">24</span>)</span></span>; <span class="comment">// 上述整数数组 t</span></span><br><span class="line">        <span class="type">int</span> i, j, n = candidates.<span class="built_in">size</span>();</span><br><span class="line">        t[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; <span class="number">24</span>; ++i)</span><br><span class="line">            t[i] = t[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">24</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(candidates[i] &amp; t[j])</span><br><span class="line">                    ++cnts[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(cnts.<span class="built_in">begin</span>(), cnts.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="problems-4"><details class="folding-tag" ><summary> 统计区间中的整数数目 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/count-integers-in-intervals/">6066. 统计区间中的整数数目</a></p><p>给你区间的 <strong>空</strong> 集，请你设计并实现满足要求的数据结构：</p><ul><li><strong>新增</strong>：添加一个区间到这个区间集合中。</li><li><strong>统计</strong>：计算出现在 <strong>至少一个</strong> 区间中的整数个数。</li></ul><p>实现 <code>CountIntervals</code> 类：</p><ul><li><code>CountIntervals()</code> 使用区间的空集初始化对象</li><li><code>void add(int left, int right)</code> 添加区间 <code>[left, right]</code> 到区间集合之中。</li><li><code>int count()</code> 返回出现在 <strong>至少一个</strong> 区间中的整数个数。<br><strong>注意</strong>：区间 <code>[left, right]</code> 表示满足 <code>left &lt;= x &lt;= right</code> 的所有整数 <code>x</code> 。</li></ul><div class="note info flat"><p>提示：</p><ol><li><code>1 &lt;= left &lt;= right &lt;= 1e9</code></li><li>最多调用 <code>add</code> 和 <code>count</code> 方法 <strong>总计</strong> <code>1e5</code> 次</li><li>调用 <code>count</code> 方法至少一次</li></ol></div><div class="note primary flat"><p>示例一：<br>输入<br>[“CountIntervals”, “add”, “add”, “count”, “add”, “count”]<br>[[], [2, 3], [7, 10], [], [5, 8], []]<br>输出<br>[null, null, null, 6, null, 8]<br>解释：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CountIntervals countIntervals = <span class="keyword">new</span> <span class="built_in">CountIntervals</span>(); <span class="comment">// 用一个区间空集初始化对象</span></span><br><span class="line">countIntervals.<span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 将 [2, 3] 添加到区间集合中</span></span><br><span class="line">countIntervals.<span class="built_in">add</span>(<span class="number">7</span>, <span class="number">10</span>); <span class="comment">// 将 [7, 10] 添加到区间集合中</span></span><br><span class="line">countIntervals.<span class="built_in">count</span>();    <span class="comment">// 返回 6</span></span><br><span class="line">                           <span class="comment">// 整数 2 和 3 出现在区间 [2, 3] 中</span></span><br><span class="line">                           <span class="comment">// 整数 7、8、9、10 出现在区间 [7, 10] 中</span></span><br><span class="line">countIntervals.<span class="built_in">add</span>(<span class="number">5</span>, <span class="number">8</span>);  <span class="comment">// 将 [5, 8] 添加到区间集合中</span></span><br><span class="line">countIntervals.<span class="built_in">count</span>();    <span class="comment">// 返回 8</span></span><br><span class="line">                           <span class="comment">// 整数 2 和 3 出现在区间 [2, 3] 中</span></span><br><span class="line">                           <span class="comment">// 整数 5 和 6 出现在区间 [5, 8] 中</span></span><br><span class="line">                           <span class="comment">// 整数 7 和 8 出现在区间 [5, 8] 和区间 [7, 10] 中</span></span><br><span class="line">                           <span class="comment">// 整数 9 和 10 出现在区间 [7, 10] 中</span></span><br></pre></td></tr></table></figure></div>              </div>            </details><p>解决方案：</p><p>使用 <code>pair&lt;int, int&gt;</code> 来表示一个区间，<code>first</code> 为区间的右边界，<code>second</code> 为左边界。</p><p>使用一个集合 <code>set</code> 存储所有合并后的区间集。</p><p>使用 <code>cnt</code> 表示区间集 <code>s</code> 包含的所有整数个数。</p><p>对于一个新的区间 <code>[left, right]</code> ，作如下操作：</p><ul><li>在 <code>s</code> 中找到所有右边界大于等于 <code>left - 1</code> ， 左边界小于等于 <code>right + 1</code> 的区间集 <code>to_sease</code> 。</li><li>设区间集合 <code>to_sease</code> 的第一个区间为 <code>a = [a1, a2]</code>，最后一个区间为 <code>b = [b1, b2]</code> 。</li><li>将 <code>to_sease</code> 中所有区间从 <code>s</code> 中删除，且 <code>cnt</code> 减去这些区间包含的整数个数。</li><li>插入 <code>to_sease</code>  和 <code>[left, right]</code> 合并后的区间 <code>[L, R]</code> ，其中 <code>L = min(left, a1); R = max(right, b2)</code> ，形成新的区间集 <code>s</code> ，且 <code>cnt</code> 加上这个区间包含的整数个数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CountIntervals</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii; <span class="comment">// pii 表示一个区间，first为区间的右边界，second为左边界</span></span><br><span class="line"></span><br><span class="line">    set&lt;pii&gt; s; <span class="comment">// 存储所有合并后的区间</span></span><br><span class="line">    <span class="type">int</span> cnt; <span class="comment">// 区间集 s 包含的所有整数个数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CountIntervals</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于一个新的区间[left, right]</span></span><br><span class="line">    <span class="comment">// 在 s 中找到 所有 右边界 大于等于 left - 1 ， 左边界 小于等于 right + 1 的区间集 to_sease</span></span><br><span class="line">    <span class="comment">// 设该区间集合的第一个区间为 a = [a1, a2]，最后一个区间为 b = [b1, b2]</span></span><br><span class="line">   <span class="comment">// 将 to_sease 中所有区间从 s 中删除，并插入一个合并后的区间 [L, R]</span></span><br><span class="line">    <span class="comment">// 其中 L = min(left, a1), R = max(right, b2)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> L = left, R = right;</span><br><span class="line">        <span class="keyword">auto</span> it = s.<span class="built_in">lower_bound</span>(<span class="built_in">pii</span>(left - <span class="number">1</span>, <span class="number">0</span>)); <span class="comment">// 找到 第一个 右边界 大于等于 left - 1 的区间 it</span></span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; to_erase; <span class="comment">// 需要删除的区间，即与区间[left, right]相连或有交集的区间</span></span><br><span class="line">        <span class="keyword">while</span>(it != s.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;second &gt; right + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 左边界 小于等于 right + 1 ，右边界大于等于left - 1 的所有区间，即与区间[left, right]相连或有交集，需要删除</span></span><br><span class="line">            to_erase.<span class="built_in">emplace_back</span>(*it);</span><br><span class="line">            ++it;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(to_erase.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            L = <span class="built_in">min</span>(L, to_erase.<span class="built_in">front</span>().second);</span><br><span class="line">            R = <span class="built_in">max</span>(R, to_erase.<span class="built_in">back</span>().first);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : to_erase) <span class="comment">// 删除区间，除去这些区间所包含的整数个数</span></span><br><span class="line">            &#123;</span><br><span class="line">                cnt -= x.first - x.second + <span class="number">1</span>;</span><br><span class="line">                s.<span class="built_in">erase</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">insert</span>(<span class="built_in">pii</span>(R, L)); <span class="comment">// 插入合并后的区间</span></span><br><span class="line">        cnt += (R - L + <span class="number">1</span>); <span class="comment">// 加上这个区间所包含的整数个数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CountIntervals object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CountIntervals* obj = new CountIntervals();</span></span><br><span class="line"><span class="comment"> * obj-&gt;add(left,right);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;count();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode周赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 题解 </tag>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客的搭建和美化日志</title>
      <link href="/2022/Blog-BuildAndBeautifly-Log/"/>
      <url>/2022/Blog-BuildAndBeautifly-Log/</url>
      
        <content type="html"><![CDATA[<div class="tip info"><p>本文仅简单记录博客搭建和美化日志，并不对各操作作详细介绍 <s>(什么时候有空了再写详细操作)</s> ，许多教程来自于 <a href="https://butterfly.js.org/">Butterfly</a> 主题配置文档 、 <a href="https://akilar.top/">Akilarの糖果屋</a> 、 <a href="https://blog.eurkon.com/">Eurkon</a> 等大佬，许多灵感来自于 <a href="https://blog.zhheo.com/">张洪HEO</a> 、<a href="https://sianx.com/">丨浅笑安然丨</a> 、<a href="https://noionion.top/">二猹の小窝</a> 等大佬。</p></div><details class="folding-tag" blue><summary> 点击查看简略时间线 </summary>              <div class='content'>              <div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>博客搭建及美化时间线</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-02-05</p></div></div><div class='timeline-item-content'><ol><li>博客 Aplayer 暂时出了些问题，博客音乐暂时取消</li><li>添加了自定义右键菜单</li><li>美化页脚</li><li>美化导航栏</li><li>增加了即刻短文</li><li>增加了网页加载进度</li><li>关闭了和风天气</li><li>完善了弹窗系统</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-12-16</p></div></div><div class='timeline-item-content'><ol><li>更新了 Twikoo 的版本</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-12-12</p></div></div><div class='timeline-item-content'><ol><li>取消了网站加载动画</li><li>取消了仿 github 的提交日历</li><li>修复了评论系统</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-06-23 至 2022-06-26</p></div></div><div class='timeline-item-content'><ol><li>修改了网站背景颜色为渐变色</li><li>大部分元素美化为磨砂质感</li><li>部分元素鼠标覆盖后显示边框</li><li>加强了部分元素鼠标覆盖后的阴影</li><li>修改了部分元素的配色</li><li>修改了文章页内标题位置</li><li>修改了页脚版权信息内容和颜色</li><li>美化了标签页</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-06-18</p></div></div><div class='timeline-item-content'><ol><li>修改了文章内标题前的图标</li><li>修改了水平分割线的图标和颜色</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-06-05</p></div></div><div class='timeline-item-content'><ol><li>增加复制成功弹窗</li><li>修改了网站图标</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-06-04</p></div></div><div class='timeline-item-content'><ol><li>安装 sweetalert2，增加欢迎弹窗</li><li>设置网页字体</li><li>修改手机端侧边卡片位置</li><li>安装 gulp js、css、字体压缩</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-06-01</p></div></div><div class='timeline-item-content'><ol><li>安装 Tag Plugins Plus，美化外挂标签</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-05-31</p></div></div><div class='timeline-item-content'><ol><li>美化 Twikoo 评论样式</li><li>美化文章版权信息</li><li>修改首页为每页显示七篇文章</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-05-25</p></div></div><div class='timeline-item-content'><ol><li>导航栏添加和风天气</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-05-24</p></div></div><div class='timeline-item-content'><ol><li>将部分 js 和 css 配置为国内 cdn</li><li>引入阿里云图标库</li><li>修改菜单栏图标和社交卡片样式</li><li>取消 jsDelivr 徽标</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-05-22</p></div></div><div class='timeline-item-content'><ol><li>更新 Butterfly 主题为 4.2.2 版本</li><li>将主题内部的 js 和第三方 js 的cdn 均配置为 local （国内 jsDelivr 节点挂了）</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-05-08</p></div></div><div class='timeline-item-content'><ol><li>添加仿 github 的提交日历</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-05-07</p></div></div><div class='timeline-item-content'><ol><li>修改导航栏 分类 为列表</li><li>添加全局吸底 Aplayer ，配置背景音乐系统</li><li>开启 Pjax 以支持切换页面背景音乐不停</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-04-28</p></div></div><div class='timeline-item-content'><ol><li>美化博客背景（背景图片一图流、各板块透明度修改）</li><li>美化 footer</li><li>设置站点公祭日灰色显示</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-04-27</p></div></div><div class='timeline-item-content'><ol><li>配置 KaTex ，引入数学公式渲染</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-04-25</p></div></div><div class='timeline-item-content'><ol><li>优化文章链接层次</li><li>配置必应、百度、谷歌 SEO</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-04-24</p></div></div><div class='timeline-item-content'><ol><li>新建关于页面</li><li>新建留言版页面，配置评论系统</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-04-23</p></div></div><div class='timeline-item-content'><ol><li>配置搜索功能</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-04-22</p></div></div><div class='timeline-item-content'><ol><li>安装 hexo</li><li>安装 Butterfly 主题</li><li>修改主要配置（博客名称、描述等）</li><li>简单美化（背景图片、鼠标点击效果等）</li></ol></div></div></div>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> 记事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> Beautify </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>凸包问题-Andrew算法</title>
      <link href="/2022/Andrew_Algorithm/"/>
      <url>/2022/Andrew_Algorithm/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言">一、前言</h2><p>在做前两天LeetCode上的每日一题<a href="https://leetcode-cn.com/problems/erect-the-fence/">587.安装栅栏</a>时发现这是一道之前都没有见过的题型（我平常也很少主动刷一些几何类的题），看了评论后发现这就是之前略有耳闻的凸包问题，但是一直没有去研究，既然现在遇到了就解决它吧！</p><p>在一个<strong>实数向量空间</strong>V中，对于给定集合X，所有包含X的<strong>凸集</strong>的交集S被称为X的<strong>凸包</strong>。X的凸包可以用X内所有点(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">X_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，…<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">X_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)的凸组合来构造（听的不是很懂）。其实就好比在一块木板上钉了若干钉子，现在用一根橡皮筋将所有钉子包起（钉子必须在橡皮筋内），这个橡皮筋所经过的所有钉子就是这若干钉子的凸包。看下面的题目描述也许更容易理解。</p><p>解决凸包问题常见的有三种算法，分别是Jarvis算法（时间复杂度O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)）、Graham算法（时间复杂度O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n\log(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>)）和Andrew算法（时间复杂度O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n\log(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>），这里只介绍Andrew算法（Ps：建议也了解一下前两种算法）。</p><h2 id="二、题目描述">二、题目描述</h2><p>我们直接以<a href="https://leetcode-cn.com/problems/erect-the-fence/">安装栅栏</a>这道题为例：</p><blockquote><p>在一个二维的花园中，有一些用 (x, y) 坐标表示的树。由于安装费用十分昂贵，你的任务是先用最短的绳子围起所有的树。只有当所有的树都被绳子包围时，花园才能围好栅栏。你需要找到正好位于栅栏边界上的树的坐标。</p><p>输入: [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]<br>输出: [[1,1],[2,0],[4,2],[3,3],[2,4]]<br>解释:</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/erect_the_fence_1.png" alt="安装栅栏-示例"></p><p>注意:</p><ul><li>所有的树应当被围在一起。你不能剪断绳子来包围树或者把树分成一组以上。</li><li>输入的整数在 0 到 100 之间。</li><li>花园至少有一棵树。</li><li>所有树的坐标都是不同的。</li><li>输入的点没有顺序。输出顺序也没有要求。</li></ul></blockquote><h2 id="三、解决方案">三、解决方案</h2><h3 id="1、基本原理">1、基本原理</h3><p>我们仔细观察X的凸包S（假设S中各个点按照逆时针进行排序，例如上述示例中的输出序列的顺序），可以发现，对于S上的任意相邻的两点 p、q 有，X上的所有点均位于向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>p</mi><mi>q</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{pq}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9084em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">pq</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span></span> （假设最后一个点的下一个点是第一个点）的左侧（或在这个向量所在的直线上），也就是说我们要找到这样一个点序列S，X中的所有点均在S中相邻的两个点形成的向量（由前一个点指向后一个点）的左侧（或在这个向量所在的直线上）。</p><h3 id="2、前置知识">2、前置知识</h3><p>如何判断一个点 r 在向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>p</mi><mi>q</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{pq}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9084em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">pq</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span></span> 的左边还是右边呢？答案是计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>p</mi><mi>q</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{pq}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9084em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">pq</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>q</mi><mi>r</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{qr}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9084em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span></span> 的<a href="https://baike.baidu.com/item/%E5%90%91%E9%87%8F%E7%A7%AF/4601007?fromtitle=%E5%8F%89%E4%B9%98&amp;fromid=8251892&amp;fr=aladdin">叉积</a>。</p><p>若向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>p</mi><mi>q</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{pq}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9084em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">pq</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span></span> 和向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>q</mi><mi>r</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{qr}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9084em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span></span> 的叉积为正，则 r 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>p</mi><mi>q</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{pq}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9084em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">pq</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span></span> 的左边，为负则 r 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>p</mi><mi>q</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{pq}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9084em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">pq</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span></span> 的右边，为0则说明 p、q、r 共线.</p><p>叉积计算公式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>c</mi><mi>r</mi><mi>o</mi><mi>s</mi><mi>s</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mover accent="true"><mrow><mi>p</mi><mi>q</mi></mrow><mo>⃗</mo></mover><mo>×</mo><mover accent="true"><mrow><mi>q</mi><mi>r</mi></mrow><mo>⃗</mo></mover></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mrow><mo fence="true">∣</mo><mtable rowspacing="0.16em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><msub><mi>q</mi><mi>x</mi></msub><mo>−</mo><msub><mi>p</mi><mi>x</mi></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><msub><mi>q</mi><mi>y</mi></msub><mo>−</mo><msub><mi>p</mi><mi>y</mi></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><msub><mi>r</mi><mi>x</mi></msub><mo>−</mo><msub><mi>q</mi><mi>x</mi></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><msub><mi>r</mi><mi>y</mi></msub><mo>−</mo><msub><mi>q</mi><mi>y</mi></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><mo fence="true">∣</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><msub><mi>q</mi><mi>x</mi></msub><mo>−</mo><msub><mi>p</mi><mi>x</mi></msub><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><msub><mi>r</mi><mi>y</mi></msub><mo>−</mo><msub><mi>q</mi><mi>y</mi></msub><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">(</mo><msub><mi>q</mi><mi>y</mi></msub><mo>−</mo><msub><mi>p</mi><mi>y</mi></msub><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><msub><mi>r</mi><mi>x</mi></msub><mo>−</mo><msub><mi>q</mi><mi>x</mi></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}    cross(p, q, r)&amp;=  \vec{pq}  ×  \vec{qr} \\                      &amp;=  \begin{vmatrix}                        (q_{x} - p_{x} ) &amp; (q_{y} - p_{y}) \\                        (r_{x} - q_{x}) &amp; (r_{y} - q_{y})                         \end{vmatrix} \\                    &amp;=(q_{x} - p_{x} ) \times (r_{y} - q_{y}) - (q_{y} - p_{y}) \times  (r_{x} - q_{x})\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.712em;vertical-align:-2.606em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.106em;"><span style="top:-5.728em;"><span class="pstrut" style="height:3.462em;"></span><span class="mord"><span class="mord mathnormal">cross</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span><span style="top:-3.606em;"><span class="pstrut" style="height:3.462em;"></span><span class="mord"></span></span><span style="top:-1.516em;"><span class="pstrut" style="height:3.462em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.606em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.106em;"><span style="top:-5.728em;"><span class="pstrut" style="height:3.462em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">pq</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span><span style="top:-3.606em;"><span class="pstrut" style="height:3.462em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.462em;"><span style="top:-2.266em;"><span class="pstrut" style="height:3.216em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.864em;"><span class="pstrut" style="height:3.216em;"></span><span style="height:1.216em;width:0.3333em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.3333em' height='1.216em' style='width:0.3333em' viewBox='0 0 333.33000000000004 1216' preserveAspectRatio='xMinYMin'><path d='M145 0 H188 V1216 H145z M145 0 H188 V1216 H145z'/></svg></span></span><span style="top:-4.072em;"><span class="pstrut" style="height:3.216em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.462em;"><span style="top:-2.266em;"><span class="pstrut" style="height:3.216em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.864em;"><span class="pstrut" style="height:3.216em;"></span><span style="height:1.216em;width:0.3333em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.3333em' height='1.216em' style='width:0.3333em' viewBox='0 0 333.33000000000004 1216' preserveAspectRatio='xMinYMin'><path d='M145 0 H188 V1216 H145z M145 0 H188 V1216 H145z'/></svg></span></span><span style="top:-4.072em;"><span class="pstrut" style="height:3.216em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-1.516em;"><span class="pstrut" style="height:3.462em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.606em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cross</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;p, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;q, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (q[<span class="number">0</span>] - p[<span class="number">0</span>]) * (r[<span class="number">1</span>] - q[<span class="number">1</span>]) - (q[<span class="number">1</span>] - p[<span class="number">1</span>]) * (r[<span class="number">0</span>] - q[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、Andrew算法">3、Andrew算法</h3><p>那么应当以一种怎样的顺序来考察点集X中的各个点，以判断其是否属于凸包S呢？其实这也就是各种的凸包算法的不同之处。</p><p>Andrew的办法是将所有的点按照x坐标从小到大排序，若x坐标相同则按y坐标从小到大排序，设排序后的点集为sortX，按照凸包的定义可以知道x坐标最小的点也就是sortX[0]一定属于凸包。</p><p>我们再定义一个栈stack，这个栈里存放目前假定的凸包，自左向右遍历sortX，对取出的每一个点 r，做如下操作：</p><ol><li>若栈中元素个数少于2，直接将r入栈，遍历下一个元素，否则进入2。</li><li>取出栈中倒数第二个元素 p 和最后一个元素 q ，那么若cross(p, q, r)小于0，说明 r 位于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>p</mi><mi>q</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{pq}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9084em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">pq</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span></span> 的右边，则 q 不满足凸包的定义（若q属于凸包，所有的点都应当在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>p</mi><mi>q</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{pq}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9084em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">pq</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span></span> 的左边），将 q 出栈，进入1，否则将r入栈，遍历下一个元素。</li></ol><p>此番遍历后凸包的下半部分就计算完成了 ：</p><img src="/2022/Andrew_Algorithm/Hull_Low.gif" class="" title="计算凸包下半部分"><p>设此时栈中有size个元素，我们再自右向左遍历sortX（最右边的点不用再遍历了），对取出的每一个点 r，做如下操作：</p><ol><li>若该点已经存在于下半区了，跳过该点，遍历下一个元素，否则进入2。</li><li>若栈中元素个数少于m + 1，直接将r入栈，遍历下一个元素，否则进入3。</li><li>取出栈中倒数第二个元素 p 和最后一个元素 q ，那么若cross(p, q, r)小于0，说明 r 位于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>p</mi><mi>q</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{pq}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9084em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">pq</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span></span> 的右边，则 q 不满足凸包的定义，将 q 出栈，进入2，否则将r入栈，遍历下一个元素。</li></ol><p>此番遍历后凸包的上半部分就计算完成了：</p><img src="/2022/Andrew_Algorithm/Hull_Up.gif" class="" title="计算凸包上半部分"><p>综上，我们可以写出Andrew算法的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">outerTrees</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; trees) &#123;</span><br><span class="line">    <span class="comment">//我们以安装栅栏为例，每棵树就是一个点</span></span><br><span class="line">    <span class="type">int</span> i, n = trees.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">4</span>)<span class="comment">//当点集X的点的个数少于4个的话，则点集X中所有点都属于凸包</span></span><br><span class="line">        <span class="keyword">return</span> trees;</span><br><span class="line">    <span class="built_in">sort</span>(trees.<span class="built_in">begin</span>(), trees.<span class="built_in">end</span>(), [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; </span><br><span class="line">    &#125;);<span class="comment">//按坐标的x值的大小进行排序（从小到大），若x值相同则按y值大小排序（从小到大）</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; hull;<span class="comment">//单调栈（按照向量的叉积）</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(n, <span class="literal">false</span>)</span></span>;<span class="comment">//记录下半区已经使用过的点</span></span><br><span class="line">    hull.<span class="built_in">emplace_back</span>(<span class="number">0</span>);<span class="comment">//第一个点不用记录，因为计算上半区时需要计算这个点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++i)<span class="comment">//计算下半区</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(hull.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">cross</span>(trees[hull[hull.<span class="built_in">size</span>() - <span class="number">2</span>]], trees[hull.<span class="built_in">back</span>()], trees[i]) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;<span class="comment">// 当前点在右边</span></span><br><span class="line">            used[hull.<span class="built_in">back</span>()] = <span class="literal">false</span>;</span><br><span class="line">            hull.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        hull.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = hull.<span class="built_in">size</span>();<span class="comment">//下半区的点的个数</span></span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">2</span>; i &gt; <span class="number">-1</span>; --i)<span class="comment">//计算上半区</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(used[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span> (hull.<span class="built_in">size</span>() &gt; m &amp;&amp;<span class="built_in">cross</span>(trees[hull[hull.<span class="built_in">size</span>() - <span class="number">2</span>]], trees[hull.<span class="built_in">back</span>()], trees[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            hull.<span class="built_in">pop_back</span>();<span class="comment">//此处为何不需要将used[i]置为false？因为之后再也不会使用到used[i]了</span></span><br><span class="line">        hull.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    hull.<span class="built_in">pop_back</span>();<span class="comment">//第一个点重复入栈了，对于第一个点，既然其一定是在凸包中的，那么为什么计算上半区时需要遍历第一个点呢？如果不遍历的话，此处还可以少一步退栈，岂不是更方便？其实你可以试试上面的gif图给出的例子，看看计算上半区时不考虑第一个点会有什么错误。</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; rst;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> &amp;x : hull)</span><br><span class="line">        rst.<span class="built_in">emplace_back</span>(trees[x]);</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 凸包 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建好了！</title>
      <link href="/2022/BlogCreated/"/>
      <url>/2022/BlogCreated/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>时隔两年，我又用<a href="https://hexo.io/zh-cn/">Hexo</a>搭建了博客，之前第一次搭建博客的时候是抱着一种玩的态度搭建的，然后没多久就不愿意维护了，不是很负责任（虽然也没有别的人打开过那个博客），但这一次我会努力经营好这个博客的。</p><h2 id="博客主题">博客主题</h2><p>博客使用的是Jerry大佬的<a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a>主题，这个主题真的很不错，他在他自己的<a href="https://butterfly.js.org/">博客</a>里对这个主题的使用方法有很详细的教程，即便是我这样很少触碰前端的人也可以很容易的使用和自定义（当然，涉及一些比较复杂的东西我还没有弄清楚，还得继续学习）。</p><h2 id="博客内容">博客内容</h2><p>计划是在这个博客里发布一些编程方面的经验和技巧，以及Leetcode上的题目的题解。另外博主目前正在准备考研，可能会分享一些复习过程中的感想和趣事。</p><h2 id="最后">最后</h2><p>欢迎访问我的博客，有什么建议和意见欢迎留言，祝生活愉快！</p>]]></content>
      
      
      <categories>
          
          <category> 记事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode C++ 多文件编译</title>
      <link href="/2022/vscode_Multi-file_compilation/"/>
      <url>/2022/vscode_Multi-file_compilation/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言-2">一、前言</h2><p>​这篇文章是windows系统下的VSCode的C++项目（C应该也差不多）的多文件编译的教程（未使用CMake），笔者也才刚刚学会方法，如果有什么错误或者问题还请指出。这个教程是循序渐进的，所以有基础的或者只是想知道launch.json和tasks.json怎么配置的可以直接看最后面的配置代码，但是如果是想知道为什么要这么配置的建议全文看完并跟着做一遍。</p><h2 id="二、准备工作">二、准备工作</h2><h3 id="1、下载VSCode（废话），官网链接">1、下载VSCode（废话），<a href="https://code.visualstudio.com/">官网链接</a></h3><h3 id="2、下载MinGW编译器，官网链接">2、下载MinGW编译器，<a href="https://www.mingw-w64.org/">官网链接</a></h3><p>​这个网站国内可能进不去，但是网上有很多资源和安装教程，或者去b站搜索一下教程，然后一定要把环境变量配好，这个并不是很难，所以就不细说了。</p><h3 id="2、安装插件">2、安装插件</h3><p>​打开VSCode，点击左侧的扩展选项：</p><p>​<img src="/2022/vscode_Multi-file_compilation/image-20220422115203068.png" class="" title="VSCode扩展"></p><p>​安装简体中文插件（英语好的可以不安装）：搜索chinese即可</p><img src="/2022/vscode_Multi-file_compilation/image-20220422115303385.png" class="" title="VSCode中文插件"><p>​安装C/C++插件：搜索C/C++即可，这个插件建议不要下载最新版本，如果已经安装了最新版本，可以点击卸载按钮，在下拉框中选择安装之前的版本，我是1.8.4版本。新的版本在后面生成launch.json时可能不会给出预制模板。</p><img src="/2022/vscode_Multi-file_compilation/image-20220422115409475.png" class="" title="VSCode C&#x2F;C++插件"><h2 id="三、正式开始">三、正式开始</h2><h3 id="1、创建工程">1、创建工程</h3><p>在电脑中合适的位置创建一个文件夹（假设文件夹名为Test）作为项目文件夹，然后在VSCode中点击左上角文件-&gt;打开文件夹，打开刚才创建的文件夹，创建新的文件，创建方式有以下两种（其实不止两种，只是这两种比较方便）：</p><ol><li>在左侧项目文件夹处<img src="/2022/vscode_Multi-file_compilation/image-20220422120451103.png" class="" title="VSCode资源管理器">点击<img src="/2022/vscode_Multi-file_compilation/image-20220422120512588.png" class="" title="VSCode 创建文件"></li><li>在左侧项目文件夹空白（虽然是黑的)处双击：<img src="/2022/vscode_Multi-file_compilation/image-20220422120617146.png" class="" title="VSCode资源管理器"></li><li>方法2的空白处右键后选择新建文件夹。</li></ol><p>​创建一个名为main.cpp的cpp文件，写一个最简单的helloworld程序：</p><p>​main.cpp：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、控制台编译（非常重要，建议一定要跟着做一遍才能理解后面在干什么）">2、控制台编译（非常重要，建议一定要跟着做一遍才能理解后面在干什么）</h3><h4 id="1、单文件编译">1、单文件编译</h4><p>​点击终端-&gt;新建终端，然后下面就会出现一个终端窗口，他会直接进入到工程目录下：</p><img src="/2022/vscode_Multi-file_compilation/image-20220422115913507.png" class="" title="VSCode"><img src="/2022/vscode_Multi-file_compilation/image-20220422115934888.png" class="" title="VSCode终端"><p>​在终端中键入<code>g++ .\main.cpp</code>回车，<code>g++</code>意思是使用g++编译器，如果是C项目则使用gcc编译器，后面的<code>.\main.cpp</code>是要编译的文件（<code>.\</code>是当前文件夹的意思），编译完后Test目录下就会出现一个名为a.exe的可执行文件，这时候在终端中键入<code>.\a.exe</code>回车，就会执行这个文件，若终端中显示Hello World!就说明编译没有问题。</p><img src="/2022/vscode_Multi-file_compilation/image-20220422120244290.png" class="" title="VSCode终端"><p>​然后在终端中键入<code>g++ -g .\main.cpp -o main.exe</code>回车，这时候会发现Test目录下会出现一个main.exe，此时在终端中键入<code>.\main.exe </code>回车，那么终端中依旧会显示Hello World!，那么a.exe和main.exe有什么区别呢？</p><img src="/2022/vscode_Multi-file_compilation/image-20220422120334142.png" class="" title="VSCode终端"><p>​我们可以在终端中键入<code>ls</code>回车查看这两个文件的大小：</p><img src="/2022/vscode_Multi-file_compilation/image-20220422010905260.png" class="" title="VSCode终端"><p>​我们发现，main.exe比a.exe大了一些，那么我们来解释一下<code>g++ .\main.cpp</code>和<code>g++ -g.\main.cpp -o main.exe</code>，</p><p>​g++是使用g++编译器编译（C++文件），-g是指编译出的可执行文件中包含调试信息（所以main.exe会比a.exe大）这样这个文件就可以被调试了（调试的事情之后再说），-o是指定生成的可执行文件的名称。</p><h4 id="2、多文件编译">2、多文件编译</h4><p>​在项目文件夹中再创建hello.cpp和hello.h两个文件，并在hello.h中声明一个名为printHello的函数：</p><p>​hello.h：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHello</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>并在hello.cpp中实现这个函数，在main.cpp中调用这个函数：</p><p>​hello.cpp：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​main.cpp：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printHello</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​我们先将之前生成的a.exe和main.exe删除了（项目中选中文件右键删除即可，若显示无法删除则说明你的程序正在运行），这时我们在终端中键入<code>g++ -g .\main.cpp -o main.exe</code>回车，此时我们发现项目中并没有生成main.exe，并且终端报错：</p><img src="/2022/vscode_Multi-file_compilation/image-20220422115824698.png" class="" title="VSCode终端"><p>​这是因为main.cpp调用的方法是hello.cpp的，但是我们只编译了main.cpp，故而报错printHello方法未定义。</p><blockquote><p>​另外，如果在上面的main.cpp中若<code>#include &quot;hello.h&quot;</code>下方显示有波浪线（一般情况下不会有这个错误，因为头文件是在项目文件夹中的），并报错找不到头文件，则可以按下<code>ctrl + shift + p</code>在弹出的搜索框中键入<code>C/C++ Edit Configurations </code>，选择C/C++ 编辑配置（JSON），如果没有安装中文插件的选择C/C++ edit configration（JSON）</p><img src="/2022/vscode_Multi-file_compilation/image-20220422121910174.png" class="" title="VSCode C&#x2F;C++ Edit Configurations"><p>​这时项目中会出现一个名为.vscode的文件夹，并且里面有一个名为c_cpp_properties.json的文件，打开后如下显示：</p><img src="/2022/vscode_Multi-file_compilation/image-20220422122114076.png" class="" title="VSCode c_cpp_properties.json"><p>​其他的不同没什么关系，也不一定要和我配的一样，主要是&quot;includePath&quot;字段，<code>&quot;$&#123;workspaceFolder&#125;/**&quot;</code>表示包含你这个项目文件夹中的所有文件（<code>/**</code>表示递归包含），如果你的头文件在别的文件夹中（不在项目文件夹中，也不在项目文件夹的子文件夹中），就需要把那个文件夹的地址写进这里，或者你可以直接把那个文件夹拷贝到项目文件夹中。但其实这个只是影响编写代码的智能补全，并不影响之后的编译。</p></blockquote><p>​既然如此，那是不是只要把hello.cpp和main.cpp都编译了就行了呢？我们在终端中键入<code>g++ -g .\main.cpp .\hello.cpp -o main.exe</code>回车，这时项目文件夹中出现了main.exe，且终端也没有报错，说明编译成功，键入<code>.\main.exe</code>终端中也显示出了Hello World!。</p><p>​那么也就是说多文件其实也可以编译成功，但是如果我们每一次编译都要这样输入的话太麻烦了，而且这种编译的方法不就是传统的在控制台中编译的方法吗？这甚至和vscode没有什么关系（只是我们借用了vscode的内部终端而已），我们直接按<code>win + r</code>键入<code>cmd</code>，直接在cmd中也可以这样编译，那么vscode有没有什么好的方法可以让我们更快的编译？这时就需要用到launch.json和tasks.json了。</p><h3 id="3、vscode编译">3、vscode编译</h3><h4 id="1、配置launch-json和tasks-json">1、配置launch.json和tasks.json</h4><p>点击左侧调试按钮：<img src="/2022/vscode_Multi-file_compilation/image-20220422124928506.png" class="" title="VSCode 调试">然后点击创建launch.json文件。</p><p>​选择C++(GDB/LLDB)</p><img src="/2022/vscode_Multi-file_compilation/image-20220422125101265.png" class="" title="VSCode 编译环境"><p>​再选择g++.exe - 生成和调试活动文件</p><img src="/2022/vscode_Multi-file_compilation/image-20220422125128644.png" class="" title="VSCode 生成和调试活动文件"><blockquote><p>​如果在选择了C++(GDB/LLDB)后就没有这一步选择的话那么可能的因为C/C++插件的版本问题，因为笔者之前安装最新版本时出现过这个问题，但如果你安装的是旧的版本还有这个问题，那么我就不知道是怎么原因了（因为我没有遇到过，当然不知道怎么处理)但是也不要慌，这个问题只是会让你的launch.json文件没有预制的模板，你可以去网上找一个模板，或者按照我下面给出的代码配置。</p></blockquote><p>​此时会进入编译过程，然后显示调试失败：</p><img src="/2022/vscode_Multi-file_compilation/image-20220422125838921.png" class="" title="VSCode 调试失败"><p>​直接×掉这个提示框（如果点击了打开&quot;launch.json&quot;则会出现之前的选择配置的选择框，按esc关掉选择框就行了）。此时项目中会有.vscode文件夹（可能你之前就有了，反正无论如何现在有这个文件夹就行）。里面会有launch.json和tasks.json两个文件（之前配置过includePath的话还会有c_cpp_properties.json），其中launch.json是调试的配置，tasks.json是编译的配置。我们先打开launch.json，正常情况下会是下面这个情况（当然不会有我这么详细的注释）：</p><p>​launch.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="comment">//没有加注释的地方可以自己把鼠标放在相应的kay上会有说明(注意是在vscode里的launch.json里把鼠标放在相应key上，你在这个makedown文档上当然没有用)</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g++.exe - 生成和调试活动文件&quot;</span><span class="punctuation">,</span><span class="comment">//这里就是你刚才点创建launch.json选的配置</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span><span class="comment">//cpp文件debug</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span><span class="comment">//需要调试的文件的路径，$&#123;fileDirname&#125;就是你之后按下调试按钮时正打开的文件所在的文件夹，$&#123;fileBasenameNoExtension&#125;就是你按下调试时正打开的文件的文件名，与tasks.json的args下的-o指定的位置对应</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="comment">//调试时传递给程序的参数，一般为空</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span><span class="comment">//在目标的入口点暂停（main函数处暂停），相当于在入口处加了一个断点</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span><span class="comment">//调试程序所在的目录，$&#123;fileDirname&#125;上面已经解释过了</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="comment">//环境变量</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span><span class="comment">//是否使用单独的窗口，如果是flase，就会在vscode的内置终端中调试，true则会打开一个cmd窗口进行调试</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span><span class="comment">//调试器，可以是gdb或者lldb，注意，你的MinGW里一定要有这个调试器，像我之前不知道搁哪下载的MinGW居然没有，一般是有的</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\MinGW\\MinGW\\bin\\gdb.exe&quot;</span><span class="punctuation">,</span><span class="comment">//调试器的地址</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="comment">//好像可以更好的显示STL容器内容，没怎么研究（反正我之前用的STL的stack或者vector之类的数据结构感觉调试时都不是很好显示内容）</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;为 gdb 启用整齐打印&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;将反汇编风格设置为 Intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: g++.exe 生成活动文件&quot;</span><span class="comment">//调试前的任务，一般是编译程序，所以他这里是和tasks.json的label对应的，如果是没有安装中文插件的话，他是英文的，但是不要紧，只要和tasks.json的label对应就行</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>​如果你的launch.json只有两行：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>   </span><br><span class="line"><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>​那么就是我上面说的没有预制模板，可能最新版本是C/C++插件的问题，但是你可以直接把我的这个配置复制过去，然后把<code>&quot;miDebuggerPath&quot;</code>的value设置成你安装的MinGW里的gdb的地址（或者你选用别的调试器，那么<code>&quot;MIMode&quot;</code>的value也改成你选的调试器），并且你的<code>&quot;preLaunchTask&quot;</code>的value要和你的tasks.json里的<code>&quot;label&quot;</code>的value对应。</p><p>​然后我们再打开tasks.json：</p><p>​tasks.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="comment">//没有加注释的地方可以自己把鼠标放在相应的kay上会有说明(注意是在vscode里的tasks.json里把鼠标放在相应key上，你在这个makedown文档上当然没有用)</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span><span class="comment">//编译类型，cppbuild就是cpp文件编译，还可以是shell，具体上面区别可以百度</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: g++.exe 生成活动文件&quot;</span><span class="punctuation">,</span><span class="comment">//任务名称，要和launch.json的&quot;preLaunchTask&quot;字段对应</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\MinGW\\MinGW\\bin\\g++.exe&quot;</span><span class="punctuation">,</span><span class="comment">//要使用的编译器的路径</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="comment">//这个东西就是我们之前控制台编译时g++ 后面的参数，除了以下的参数外还有很多参数，具体情况可以百度，这些就够我们多文件编译了</span></span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span><span class="comment">//编译时警告信息是彩色的</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span><span class="comment">//熟不熟悉？就是之前控制台编译时输入的-g，表示生成调试有关信息，这样编译生成的可执行文件就可以调试了</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span><span class="comment">//要编译的文件，我们发现这样的话就只能编译单个文件了，怎么修改看之后的操作</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span><span class="comment">//指定生成的可执行文件的名字，不加的话就是a.exe</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="comment">//$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;表示的地址在launch.json说过了，一定要和launch.json的&quot;program&quot;对应</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="comment">//当前工作目录</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="comment">// 开启编译快捷键，ctrl + shift + B</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;调试器生成的任务。&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>​在这两个文件中最重要的就是</p><ul><li>​launch.json的<code>&quot;program&quot;</code>要和tasks.json的<code>&quot;args&quot;</code>的&quot;-o&quot;所指定生成的可执行文件的名字要一致，不然找不到要调试的文件。</li><li>​launch.json的<code>&quot;preLaunchTask&quot;</code>要和tasks.json的<code>&quot;label&quot;</code>对应，不然调试前无法编译。</li></ul><p>​我们先将之前控制台编译生成的main.exe删除，然后根据之前控制台编译的情况，我们将tasks.json中的<code>&quot;args&quot;</code>作如下修改：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">     <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;$&#123;workspaceFolder&#125;\\main.cpp&quot;</span><span class="punctuation">,</span><span class="comment">//$&#123;workspaceFolder&#125;表示当前的项目文件夹路径</span></span><br><span class="line">     <span class="string">&quot;$&#123;workspaceFolder&#125;\\hello.cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;$&#123;workspaceFolder&#125;\\main.exe&quot;</span><span class="comment">//设置生成的可执行文件的路径</span></span><br><span class="line"> <span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>​然后将launch.json的<code>&quot;program&quot;</code>设置成 <code>&quot;$&#123;workspaceFolder&#125;\\main.exe&quot;,</code>（与tasks.json的<code>&quot;-o&quot;</code>参数对应）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;\\main.exe&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>​我们点击上面的运行-&gt;启动调试：<img src="/2022/vscode_Multi-file_compilation/image-20220422144402348.png" class="" title="VSCode">（或者按快捷键F5)。</p><p>​这时下方的终端中的C/C++:g++.exe生成活动文件窗口会显示生成成功完成：</p><img src="/2022/vscode_Multi-file_compilation/image-20220422144708775.png" class="" title="VSCode 终端"><p>​然后点击调试控制台，里面会显示Hello World!说明编译正确，并且程序成功运行。</p><blockquote><p>​如果你的launch.json中的<code>&quot;externalConsole&quot;</code>设置成true，则表示调试时在控制台中运行程序，那么你点击调试后会有一个窗口一闪而过，因为main函数执行后就退出了，可以在main函数的return 0;之前加一句<code>getchar();</code>（注意导入头文件）来避免这个情况。点击调试后是下面这个情况。</p><img src="/2022/vscode_Multi-file_compilation/image-20220422145558355.png" class="" title="Hello World!"></blockquote><p>​这种方式来编译其实就相当于在控制台编译中键入<code>g++ -g .\main.cpp .\hello.cpp -o main.exe</code>，那么如果有很多文件岂不是很麻烦？要把每一个要编译的cpp文件都写进tasks.json？其实可以将tasks.json的<code>&quot;args&quot;</code>进行如下设置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;$&#123;workspaceFolder&#125;\\*.cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;$&#123;workspaceFolder&#125;\\main.exe&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>​<code>&quot;$&#123;workspaceFolder&#125;\\*.cpp&quot;,</code>就表示将工作目录（也就是项目的目录）下的所有cpp文件都编译，此时再启动调试，依旧成功编译，成功调试。</p><p>​那么如果我的头文件和cpp文件都是在不同目录下的呢？例如，在项目目录下创建两个文件夹（和创建文件的方式差不多，在Test下的空白区右键创建），分别叫heads和sources，然后将hello.h放到heads文件夹中，将main.cpp和hello.cpp放到sources文件夹中。</p><img src="/2022/vscode_Multi-file_compilation/image-20220422152920581.png" class="" title="VSCode 资源管理器"><p>​此时启动调试会发现终端中的C/C++:g++.exe生成活动文件窗口报告编译错误：</p><img src="/2022/vscode_Multi-file_compilation/image-20220422152602287.png" class="" title="VSCode 编译错误"><p>​但是调试控制台（或者cmd窗口）依旧显示了Hello World!。</p><p>​<img src="/2022/vscode_Multi-file_compilation/image-20220422152713456.png" class="" title="VSCode 调试控制台"></p><p>​编译错误是因为你的cpp文件已经不是直接放在工作目录（项目目录）下了（虽然sources目录依旧在工作目录下），那么就没有编译到cpp文件，从而报错。</p><p>​而调试控制台（或cmd窗口）中仍然显示Hello World!是因为我们只是规定调试前要做编译的工作，但是至于编译是否成功并不关心，甚至没有编译都行（例如将launch.json的<code>&quot;preLaunchTask&quot;: &quot;C/C++: g++.exe 生成活动文件&quot;</code>注释掉），只要launch.json的<code>&quot;program&quot;: &quot;$&#123;workspaceFolder&#125;\\main.exe&quot;,</code>的可执行文件是存在的并且可执行文件中有调试信息即可。编译失败只是没有重新生成新的main.exe，但是原来的main.exe依旧存在并且可以调试。</p><p>​那么我们可以将tasks.json的<code>&quot;args&quot;</code>进行如下设置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;$&#123;workspaceFolder&#125;\\sources\\*.cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;-I&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;$&#123;workspaceFolder&#125;\\heads&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;$&#123;workspaceFolder&#125;\\main.exe&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>​再启动调试，那么终端中的C/C++:g++.exe生成活动文件窗口就会显示生成成功：</p><img src="/2022/vscode_Multi-file_compilation/image-20220422153746087.png" class="" title="VSCode 终端"><p>​而此时的main.exe是新生成的main.exe（可以删除了main.exe之后再启动调试试试看）。</p><p>​对于<code>&quot;-g&quot;</code>后面的<code>&quot;$&#123;workspaceFolder&#125;\\sources\\*.cpp&quot;</code>应该不需要再解释了吧，而<code>&quot;-I&quot;</code>是之前控制台编译所没有讲到的，其表示的是需要包含的头文件的文件夹，也就是<code>&quot;$&#123;workspaceFolder&#125;\\heads&quot;</code>。我们可以在终端处试试控制台调试，新建终端，在终端中键入<code>g++ -g .\sources\main.cpp .\sources\hello.cpp -I .\heads -o main.exe</code>回车，没有报错就是编译成功（可以把main.exe删了再试试有没有重新生成main.exe），此时在终端中键入<code>.\main.exe</code>回车则显示Hello World!。</p><p>​如果你的项目中有别的地方的头文件那么也需要把他加入到<code>&quot;-I&quot;</code>后面</p><p>​由此，多文件编译就差不多配置好了，有一些建议：</p><ul><li><p>如果在上述操作中发现main.exe无法删除，那么是因为main.exe正在运行，得结束运行才行。</p></li><li><p>我们可以把<code>&quot;-o&quot;</code>指定的生成路径改成<code>&quot;$&#123;workspaceFolder&#125;\\bin\\main.exe&quot;</code>，同样的launch.json的<code>&quot;program&quot;</code>后的路径也要改成<code>&quot;$&#123;workspaceFolder&#125;\\bin\\main.exe&quot;</code>。并且在项目目录下建立bin文件夹（不然会报错），这样生成的可执行文件就在bin目录下了。</p></li><li><p>launch.json中的<code>&quot;cwd&quot;</code>和tasks.json的<code>&quot;options&quot;</code>下的<code>&quot;cwd&quot;</code>（可能你的tasks.json里没有这个东西，可以加上）设置成<code>&quot;$&#123;workspaceFolder&#125;&quot;</code>。</p></li></ul><p>​最后贴上我最终设置的launch.json和tasks.json：</p><p>​launch.json:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g++.exe - 生成和调试活动文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;\\bin\\main.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\MinGW\\MinGW\\bin\\gdb.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;为 gdb 启用整齐打印&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;将反汇编风格设置为 Intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: g++.exe 生成活动文件&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>​tasks.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: g++.exe 生成活动文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\MinGW\\MinGW\\bin\\g++.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;\\sources\\*.cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-I&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;\\heads&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;\\bin\\main.exe&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;调试器生成的任务。&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>​做别的项目时只要相应的进行一些小调整就行。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> VSCode </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
